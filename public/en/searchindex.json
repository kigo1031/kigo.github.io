[{
  "section": "Blog",
  "slug": "/en/blog/hugo-blog-posting-guide/",
  "title": "Complete Hugo Blog Posting Guide - Tips from Real Experience",
  "description": "A practical blogging guide for Hugo and GitHub Pages users. Sharing know-how gained through trial and error.",
  "date": "August 3, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Development Tools, Web Development",
  "tags": "Hugo, GitHub Pages, Blog, Markdown, Static Site",
  "content":"Based on the trial and error I experienced while running a Hugo blog, I\u0026rsquo;ll share efficient posting methods and useful tips. This will be especially helpful if you\u0026rsquo;re using it with GitHub Pages.\nWhy Hugo? When I first started blogging, there were several options:\nWordPress: Heavy and complex Jekyll: GitHub Pages default but Ruby dependency Gatsby: React-based but overkill Hugo: Fast and simple, Go-based I chose Hugo because of its speed and simplicity. Build times are really fast, and configuration is intuitive.\nUnderstanding Blog Structure Basic Directory Structure your-blog/ ‚îú‚îÄ‚îÄ content/ # Where posts go ‚îÇ ‚îú‚îÄ‚îÄ korean/ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ blog/ # Korean posts ‚îÇ ‚îî‚îÄ‚îÄ english/ ‚îÇ ‚îî‚îÄ‚îÄ blog/ # English posts ‚îú‚îÄ‚îÄ static/ # Static files like images, CSS ‚îÇ ‚îî‚îÄ‚îÄ images/ ‚îú‚îÄ‚îÄ layouts/ # Template files ‚îú‚îÄ‚îÄ config/ # Configuration files ‚îî‚îÄ‚îÄ themes/ # Theme folder Important Configuration Files hugo.toml: Basic site configuration config/_default/params.toml: Detailed parameters config/_default/menus.en.toml: Menu structure Creating New Posts 1. Using Hugo Commands (Recommended) # Korean post hugo new content/korean/blog/post-title.md # English post hugo new content/english/blog/post-title.md This automatically generates the Front Matter.\n2. Manual Creation When creating files manually, use this template:\n--- title: \u0026#34;Post Title\u0026#34; meta_title: \u0026#34;\u0026#34; # Uses title if empty description: \u0026#34;SEO-important description\u0026#34; date: 2025-08-03T15:00:00+09:00 image: \u0026#34;/images/service-1.png\u0026#34; # Thumbnail categories: [\u0026#34;Category1\u0026#34;, \u0026#34;Category2\u0026#34;] author: \u0026#34;Kigo\u0026#34; tags: [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;] draft: false # true for unpublished --- Front Matter Optimization Tips Required Fields title: \u0026#34;Clear and search-friendly title\u0026#34; description: \u0026#34;Summary shown in Google search (under 155 chars)\u0026#34; date: 2025-08-03T15:00:00+09:00 # Timezone required categories: [\u0026#34;Use existing categories\u0026#34;] tags: [\u0026#34;3-5 highly relevant tags\u0026#34;] draft: false Date Format Notes # ‚úÖ Correct format date: 2025-08-03T15:00:00+09:00 # ‚ùå Wrong format date: 2025-08-03 date: \u0026#34;August 3, 2025\u0026#34; Maintaining Category Consistency Check existing categories and use them consistently:\n# Check existing categories find content -name \u0026#34;*.md\u0026#34; -exec grep -h \u0026#34;categories:\u0026#34; {} \\; | sort | uniq Practical Markdown Writing Tips 1. Title Structure Optimization # Post Title (H1 is auto-generated, don\u0026#39;t use) ## Main Section (H2) ### Sub Section (H3) #### Details (H4) 2. Code Block Usage ```java // Specify language for highlighting public class Example { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } # Terminal commands hugo server -D 3. Image Optimization ![Meaningful description](/images/screenshot.png) \u0026lt;!-- Use HTML for image size control --\u0026gt; \u0026lt;img src=\u0026#34;/images/large-image.png\u0026#34; alt=\u0026#34;Description\u0026#34; width=\u0026#34;600\u0026#34;\u0026gt; 4. Link Writing [Internal link](/blog/other-post/) [External link](https://example.com){:target=\u0026#34;_blank\u0026#34;} Image Management Strategy File Structure static/images/ ‚îú‚îÄ‚îÄ posts/ # Images per post ‚îÇ ‚îú‚îÄ‚îÄ 2025-08/ ‚îÇ ‚îî‚îÄ‚îÄ hugo-guide/ ‚îú‚îÄ‚îÄ common/ # Common images ‚îî‚îÄ‚îÄ thumbnails/ # Thumbnails Image Optimization # Optimize with ImageMagick convert original.png -quality 85 -resize 800x600 optimized.jpg # Convert to WebP (space saving) cwebp original.png -q 80 -o optimized.webp Development Workflow 1. Run Development Server hugo server -D --navigateToChanged # -D: Include draft posts # --navigateToChanged: Auto-refresh on file changes 2. Real-time Preview The browser automatically refreshes when you save files. It\u0026rsquo;s really convenient!\n3. Build and Deploy # Production build hugo --minify # Deploy to GitHub Pages (when using GitHub Actions) git add . git commit -m \u0026#34;New post: Hugo Blog Guide\u0026#34; git push origin main Common Mistakes 1. Front Matter Syntax Errors # ‚ùå Quote mismatch title: \u0026#34;Hugo Guide\u0026#39; # ‚ùå Array syntax error tags: [tag1, tag2, tag3 # ‚úÖ Correct format title: \u0026#34;Hugo Guide\u0026#34; tags: [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;, \u0026#34;tag3\u0026#34;] 2. Image Path Errors \u0026lt;!-- ‚ùå Absolute path --\u0026gt; ![Image](file:///Users/name/blog/static/images/pic.png) \u0026lt;!-- ‚ùå Relative path --\u0026gt; ![Image](../static/images/pic.png) \u0026lt;!-- ‚úÖ Correct path --\u0026gt; ![Image](/images/pic.png) 3. Date Order Issues If posts don\u0026rsquo;t appear in the intended order, check the dates. Hugo sorts by date.\nPerformance Optimization Tips 1. Image Lazy Loading If supported by the theme:\n![Image](/images/large-pic.png){: loading=\u0026#34;lazy\u0026#34;} 2. Build Optimization # Measure build time time hugo --minify # Find large files find public -type f -size +1M -ls 3. Search Optimization # config/_default/params.toml [search] enable = true include_sections = [\u0026#34;blog\u0026#34;] show_description = true Useful Hugo Commands # Create new site hugo new site my-blog # Add theme git submodule add https://github.com/theme/repo themes/theme-name # Content statistics hugo list all # Detailed build info hugo --verbose # Check configuration hugo config Backup Strategy 1. Using Git # Track all changes git add . git commit -m \u0026#34;Add post: $(date)\u0026#34; git push 2. Automated Backup Script #!/bin/bash # backup.sh DATE=$(date +%Y%m%d) tar -czf \u0026#34;blog-backup-$DATE.tar.gz\u0026#34; content static config Troubleshooting Fixing Build Errors # Check detailed error messages hugo --verbose --debug # Clear cache hugo --gc rm -rf public resources Template Issues # Check template syntax hugo --templateMetrics Conclusion Hugo blogs may seem complex at first, but once you get used to them, they\u0026rsquo;re really efficient. Especially:\nFast Build Speed - Hundreds of posts in seconds Flexible Structure - Customizable as you want Search Optimization - SEO-friendly static sites Free Hosting - Perfect GitHub Pages compatibility I hope this guide helps with your Hugo blog management. If you have any questions, feel free to ask in the comments!\nReference Links:\nHugo Official Documentation GitHub Pages Guide Markdown Syntax Guide "},{
  "section": "Blog",
  "slug": "/en/blog/quarkus-cloud-native-java/",
  "title": "Getting Started with Cloud Native Java Development using Quarkus",
  "description": "Introduction to Quarkus, the Kubernetes-era Java framework, and comparison with Spring Boot",
  "date": "August 3, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend",
  "tags": "Java, Quarkus, Cloud Native, Kubernetes, GraalVM",
  "content":"Recently, there\u0026rsquo;s been a lot of discussion about the limitations of Java applications in cloud-native environments. Particularly, high memory usage and slow startup times have made Java somewhat disadvantageous in containerized environments. Quarkus emerged to solve these exact problems.\nWhat is Quarkus? Quarkus is a Kubernetes Native Java framework developed by Red Hat. True to its slogan \u0026ldquo;Supersonic Subatomic Java,\u0026rdquo; it boasts much faster startup times and lower memory usage compared to traditional Java applications.\nKey Features Fast startup time: Millisecond-level startup times Low memory usage: 1/10th of traditional usage GraalVM Native Image support: Native compilation capable Developer-friendly: Live Coding for immediate reflection Spring Boot vs Quarkus Memory Usage Comparison # Spring Boot Application Memory: ~200MB # Quarkus JVM Mode Memory: ~50MB # Quarkus Native Mode Memory: ~20MB Startup Time Comparison # Spring Boot Started in 3.2 seconds # Quarkus JVM Mode Started in 1.1 seconds # Quarkus Native Mode Started in 0.016 seconds Getting Started with Quarkus Project 1. Project Creation mvn io.quarkus.platform:quarkus-maven-plugin:3.2.4.Final:create \\ -DprojectGroupId=com.kigo.example \\ -DprojectArtifactId=quarkus-demo \\ -DclassName=\u0026#34;com.kigo.example.GreetingResource\u0026#34; \\ -Dpath=\u0026#34;/hello\u0026#34; 2. Basic REST API Implementation @Path(\u0026#34;/hello\u0026#34;) public class GreetingResource { @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return \u0026#34;Hello from Quarkus!\u0026#34;; } } 3. Database Integration (Hibernate ORM with Panache) @Entity @Table(name = \u0026#34;users\u0026#34;) public class User extends PanacheEntity { public String name; public String email; public static List\u0026lt;User\u0026gt; findByName(String name) { return find(\u0026#34;name\u0026#34;, name).list(); } } Benefits of Quarkus in Production 1. Container Environment Optimization In Kubernetes, faster startup times enable quicker response to traffic spikes during Pod scaling.\n# Requesting fewer resources in Kubernetes Deployment resources: requests: memory: \u0026#34;32Mi\u0026#34; cpu: \u0026#34;100m\u0026#34; limits: memory: \u0026#34;64Mi\u0026#34; cpu: \u0026#34;200m\u0026#34; 2. Improved Development Productivity Live Coding feature reflects code changes immediately without application restart.\n# Run in development mode mvn quarkus:dev 3. GraalVM Native Image When compiled to native image, it can run without JVM.\n# Build native image mvn clean package -Pnative # Check executable size and startup time ls -lh target/*-runner time ./target/quarkus-demo-1.0.0-SNAPSHOT-runner Quarkus Migration for Spring Boot Developers Dependency Injection // Spring Boot @Autowired private UserService userService; // Quarkus (CDI) @Inject UserService userService; Configuration // Spring Boot @Value(\u0026#34;${app.name}\u0026#34;) private String appName; // Quarkus @ConfigProperty(name = \u0026#34;app.name\u0026#34;) String appName; REST Controller // Spring Boot @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class UserController { @GetMapping(\u0026#34;/users\u0026#34;) public List\u0026lt;User\u0026gt; getUsers() { ... } } // Quarkus @Path(\u0026#34;/api/users\u0026#34;) public class UserResource { @GET public List\u0026lt;User\u0026gt; getUsers() { ... } } When to Choose Quarkus? Quarkus is Suitable for: Microservices Architecture Container-based Deployment Serverless Environments (AWS Lambda, etc.) Resource-constrained Environments Spring Boot is Still Great for: Deep Dependency on Spring Ecosystem Large Monolithic Applications Need for Rich Community Support Performance Test Results Results measured from actual projects:\n# Based on identical REST API ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ Spring Boot ‚îÇ Quarkus JVM ‚îÇ Quarkus Native ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Startup Time ‚îÇ 3.2s ‚îÇ 1.1s ‚îÇ 0.016s ‚îÇ ‚îÇ Memory Usage ‚îÇ 200MB ‚îÇ 50MB ‚îÇ 20MB ‚îÇ ‚îÇ Throughput ‚îÇ 1,200 RPS ‚îÇ 1,180 RPS ‚îÇ 1,100 RPS ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Conclusion Quarkus is a Java framework suited for the cloud-native era. Rather than being a complete replacement for Spring Boot, it can be a better choice in specific situations.\nParticularly, consider adopting Quarkus in the following scenarios:\nWhen container resource cost optimization is important Microservices requiring fast scale-out Java usage in serverless environments I\u0026rsquo;ll continue to share practical application cases as I use Quarkus in more projects!\nReferences:\nQuarkus Official Documentation Quarkus vs Spring Boot Benchmark GraalVM Native Image "},{
  "section": "Blog",
  "slug": "/en/blog/quarkus-jpa-guide/",
  "title": "Complete Quarkus JPA Guide - From Entity to Transaction",
  "description": "Everything backend developers need to know about using JPA in Quarkus, from database integration to advanced features.",
  "date": "August 3, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "backend",
  "tags": "Quarkus, JPA, Database, Java, Backend, Hibernate, PostgreSQL",
  "content":"When transitioning from Spring Boot to Quarkus, one of the first questions that comes to mind is \u0026ldquo;How do I handle database integration?\u0026rdquo; Fortunately, Quarkus provides excellent JPA support, often with better performance and simpler configuration.\nProject Setup Adding Dependencies Add the necessary dependencies to your pom.xml:\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- Quarkus JPA Extension --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.quarkus\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;quarkus-hibernate-orm-panache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- PostgreSQL Driver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.quarkus\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;quarkus-jdbc-postgresql\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- DevServices for Development --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.quarkus\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;quarkus-devservices-postgresql\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Database Configuration Configure your database in application.properties:\n# Database Connection Settings quarkus.datasource.db-kind=postgresql quarkus.datasource.username=postgres quarkus.datasource.password=password quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_jpa # Hibernate Settings quarkus.hibernate-orm.database.generation=drop-and-create quarkus.hibernate-orm.log.sql=true quarkus.hibernate-orm.log.bind-parameters=true # Environment-specific settings %dev.quarkus.hibernate-orm.database.generation=drop-and-create %prod.quarkus.hibernate-orm.database.generation=validate Entity Definition Quarkus uses standard JPA annotations:\n@Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String name; @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List\u0026lt;Post\u0026gt; posts = new ArrayList\u0026lt;\u0026gt;(); // Default constructor (required by JPA) public User() {} public User(String email, String name) { this.email = email; this.name = name; this.createdAt = LocalDateTime.now(); } // getters/setters omitted } @Entity @Table(name = \u0026#34;posts\u0026#34;) public class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String title; @Column(columnDefinition = \u0026#34;TEXT\u0026#34;) private String content; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;user_id\u0026#34;) private User user; @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt; public Post() {} public Post(String title, String content, User user) { this.title = title; this.content = content; this.user = user; this.createdAt = LocalDateTime.now(); } // getters/setters omitted } Repository Pattern vs Panache Pattern Quarkus supports both approaches:\n1. Traditional Repository Pattern @ApplicationScoped public class UserRepository { @Inject EntityManager em; @Transactional public User save(User user) { if (user.getId() == null) { em.persist(user); return user; } else { return em.merge(user); } } public Optional\u0026lt;User\u0026gt; findById(Long id) { return Optional.ofNullable(em.find(User.class, id)); } public Optional\u0026lt;User\u0026gt; findByEmail(String email) { try { User user = em.createQuery( \u0026#34;SELECT u FROM User u WHERE u.email = :email\u0026#34;, User.class) .setParameter(\u0026#34;email\u0026#34;, email) .getSingleResult(); return Optional.of(user); } catch (NoResultException e) { return Optional.empty(); } } public List\u0026lt;User\u0026gt; findAll() { return em.createQuery(\u0026#34;SELECT u FROM User u\u0026#34;, User.class) .getResultList(); } @Transactional public void delete(User user) { em.remove(em.merge(user)); } } 2. Panache Pattern (Recommended) Using Panache makes everything much simpler:\n@Entity @Table(name = \u0026#34;users\u0026#34;) public class User extends PanacheEntity { @Column(nullable = false, unique = true) public String email; @Column(nullable = false) public String name; @Column(name = \u0026#34;created_at\u0026#34;) public LocalDateTime createdAt; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, fetch = FetchType.LAZY) public List\u0026lt;Post\u0026gt; posts = new ArrayList\u0026lt;\u0026gt;(); public User() {} public User(String email, String name) { this.email = email; this.name = name; this.createdAt = LocalDateTime.now(); } // Custom query methods public static Optional\u0026lt;User\u0026gt; findByEmail(String email) { return find(\u0026#34;email\u0026#34;, email).firstResultOptional(); } public static List\u0026lt;User\u0026gt; findByNameContaining(String name) { return find(\u0026#34;name like ?1\u0026#34;, \u0026#34;%\u0026#34; + name + \u0026#34;%\u0026#34;).list(); } } If you prefer separate repository classes:\n@ApplicationScoped public class UserRepository implements PanacheRepository\u0026lt;User\u0026gt; { public Optional\u0026lt;User\u0026gt; findByEmail(String email) { return find(\u0026#34;email\u0026#34;, email).firstResultOptional(); } public List\u0026lt;User\u0026gt; findActiveUsers() { return find(\u0026#34;active = true\u0026#34;).list(); } public long countByDomain(String domain) { return count(\u0026#34;email like ?1\u0026#34;, \u0026#34;%@\u0026#34; + domain); } } Service Layer Implementation @ApplicationScoped public class UserService { @Inject UserRepository userRepository; @Transactional public User createUser(String email, String name) { // Check for duplicate email if (userRepository.findByEmail(email).isPresent()) { throw new IllegalArgumentException(\u0026#34;Email already exists\u0026#34;); } User user = new User(email, name); userRepository.persist(user); return user; } public Optional\u0026lt;User\u0026gt; getUserById(Long id) { return userRepository.findByIdOptional(id); } public List\u0026lt;User\u0026gt; getAllUsers() { return userRepository.listAll(); } @Transactional public User updateUser(Long id, String name) { User user = userRepository.findById(id); if (user == null) { throw new EntityNotFoundException(\u0026#34;User not found\u0026#34;); } user.name = name; return user; // Panache automatically detects changes } @Transactional public void deleteUser(Long id) { if (!userRepository.deleteById(id)) { throw new EntityNotFoundException(\u0026#34;User not found\u0026#34;); } } } REST API Implementation @Path(\u0026#34;/api/users\u0026#34;) @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public class UserResource { @Inject UserService userService; @GET public List\u0026lt;User\u0026gt; getAllUsers() { return userService.getAllUsers(); } @GET @Path(\u0026#34;/{id}\u0026#34;) public Response getUserById(@PathParam(\u0026#34;id\u0026#34;) Long id) { return userService.getUserById(id) .map(user -\u0026gt; Response.ok(user).build()) .orElse(Response.status(Response.Status.NOT_FOUND).build()); } @POST public Response createUser(CreateUserRequest request) { try { User user = userService.createUser(request.email, request.name); return Response.status(Response.Status.CREATED).entity(user).build(); } catch (IllegalArgumentException e) { return Response.status(Response.Status.BAD_REQUEST) .entity(Map.of(\u0026#34;error\u0026#34;, e.getMessage())) .build(); } } @PUT @Path(\u0026#34;/{id}\u0026#34;) public Response updateUser(@PathParam(\u0026#34;id\u0026#34;) Long id, UpdateUserRequest request) { try { User user = userService.updateUser(id, request.name); return Response.ok(user).build(); } catch (EntityNotFoundException e) { return Response.status(Response.Status.NOT_FOUND) .entity(Map.of(\u0026#34;error\u0026#34;, e.getMessage())) .build(); } } @DELETE @Path(\u0026#34;/{id}\u0026#34;) public Response deleteUser(@PathParam(\u0026#34;id\u0026#34;) Long id) { try { userService.deleteUser(id); return Response.noContent().build(); } catch (EntityNotFoundException e) { return Response.status(Response.Status.NOT_FOUND) .entity(Map.of(\u0026#34;error\u0026#34;, e.getMessage())) .build(); } } public static class CreateUserRequest { public String email; public String name; } public static class UpdateUserRequest { public String name; } } Advanced Features 1. Custom Queries @ApplicationScoped public class PostRepository implements PanacheRepository\u0026lt;Post\u0026gt; { // Using JPQL public List\u0026lt;Post\u0026gt; findByTitleContaining(String keyword) { return find(\u0026#34;title like ?1\u0026#34;, \u0026#34;%\u0026#34; + keyword + \u0026#34;%\u0026#34;).list(); } // Using native queries public List\u0026lt;Post\u0026gt; findRecentPosts(LocalDateTime since) { return getEntityManager() .createNativeQuery(\u0026#34;SELECT * FROM posts WHERE created_at \u0026gt;= ?1\u0026#34;, Post.class) .setParameter(1, since) .getResultList(); } // Complex conditional queries public List\u0026lt;Post\u0026gt; findPostsByUserAndPeriod(String userEmail, LocalDateTime startDate, LocalDateTime endDate) { return find(\u0026#34;user.email = ?1 and createdAt between ?2 and ?3\u0026#34;, userEmail, startDate, endDate).list(); } } 2. Transaction Management @ApplicationScoped public class PostService { @Inject PostRepository postRepository; @Inject UserRepository userRepository; // Basic transaction @Transactional public Post createPost(Long userId, String title, String content) { User user = userRepository.findById(userId); if (user == null) { throw new EntityNotFoundException(\u0026#34;User not found\u0026#34;); } Post post = new Post(title, content, user); postRepository.persist(post); return post; } // Read-only transaction @Transactional(Transactional.TxType.SUPPORTS) public List\u0026lt;Post\u0026gt; getPostsByUser(Long userId) { return postRepository.find(\u0026#34;user.id\u0026#34;, userId).list(); } // New transaction @Transactional(Transactional.TxType.REQUIRES_NEW) public void logActivity(String activity) { // Logs are processed in separate transaction // Logs persist even if main transaction rolls back } // Specify rollback conditions @Transactional(rollbackOn = {BusinessException.class}) public void complexBusinessLogic() { // Only rolls back on BusinessException } } 3. Pagination and Sorting @GET public Response getUsers(@QueryParam(\u0026#34;page\u0026#34;) @DefaultValue(\u0026#34;0\u0026#34;) int page, @QueryParam(\u0026#34;size\u0026#34;) @DefaultValue(\u0026#34;10\u0026#34;) int size, @QueryParam(\u0026#34;sort\u0026#34;) @DefaultValue(\u0026#34;id\u0026#34;) String sort) { PanacheQuery\u0026lt;User\u0026gt; query = User.findAll(Sort.by(sort)); List\u0026lt;User\u0026gt; users = query.page(page, size).list(); long totalCount = query.count(); int totalPages = (int) Math.ceil((double) totalCount / size); Map\u0026lt;String, Object\u0026gt; response = Map.of( \u0026#34;users\u0026#34;, users, \u0026#34;currentPage\u0026#34;, page, \u0026#34;totalPages\u0026#34;, totalPages, \u0026#34;totalCount\u0026#34;, totalCount ); return Response.ok(response).build(); } Development Environment Tips Using DevServices In development, DevServices automatically sets up databases:\n# DevServices automatically runs PostgreSQL container in dev/test %dev.quarkus.devservices.enabled=true %test.quarkus.devservices.enabled=true # Specify database version quarkus.datasource.devservices.image-name=postgres:14 Data Initialization @ApplicationScoped public class DataInitializer { @Inject UserService userService; @Inject PostService postService; void onStart(@Observes StartupEvent ev) { // Only run in development if (Profile.of(\u0026#34;dev\u0026#34;).equals(Profile.getCurrent())) { initializeData(); } } @Transactional void initializeData() { // Create test data User user1 = userService.createUser(\u0026#34;john@example.com\u0026#34;, \u0026#34;John Doe\u0026#34;); User user2 = userService.createUser(\u0026#34;jane@example.com\u0026#34;, \u0026#34;Jane Smith\u0026#34;); postService.createPost(user1.id, \u0026#34;First Post\u0026#34;, \u0026#34;This is my first post\u0026#34;); postService.createPost(user2.id, \u0026#34;Another Post\u0026#34;, \u0026#34;Hello world!\u0026#34;); } } Key Differences from Spring Boot Panache Pattern: No need to implement repository interfaces Fast Startup: Quick boot times in native images DevServices: Automatic development environment setup Configuration: application.properties focused Dependency Injection: CDI-based using @Inject Conclusion Quarkus JPA is remarkably similar to Spring Boot JPA while being simpler and more performant. The Panache pattern significantly reduces boilerplate code, improving development productivity.\nIf fast startup times and low memory usage are important for your cloud-native environment, I highly recommend Quarkus JPA. With existing JPA knowledge, the learning curve is minimal and adaptation is straightforward.\nIn the next post, we\u0026rsquo;ll explore Redis caching and messaging system integration in Quarkus.\n"},{
  "section": "Blog",
  "slug": "/en/blog/vscode-optimization/",
  "title": "Optimizing VS Code Development Environment",
  "description": "Introducing VS Code settings and extensions that boost development productivity.",
  "date": "August 2, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Development Tools",
  "tags": "VS Code, Development Environment, Productivity, Extensions",
  "content":"For developers, the editor is one of the most important tools. Today, I\u0026rsquo;d like to share ways to use VS Code more efficiently.\nEssential Extensions 1. Code Quality Management ESLint: JavaScript/TypeScript code quality management Prettier: Automatic code formatting SonarLint: Real-time code analysis 2. Development Productivity GitLens: Enhanced Git functionality Live Server: Real-time web page preview Auto Rename Tag: Automatic HTML tag renaming 3. Language Support Python: Python development support Go: Go language support Docker: Container development support Useful Settings Auto-save and Formatting { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.formatOnPaste\u0026#34;: true, \u0026#34;files.autoSave\u0026#34;: \u0026#34;afterDelay\u0026#34; } Editor Improvements { \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.lineHeight\u0026#34;: 1.5, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Fira Code\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true } Keyboard Shortcut Customization Set up shortcuts for quick access to frequently used features:\nCtrl+Shift+P: Command Palette Ctrl+`: Toggle Terminal Alt+Up/Down: Move Line Theme Recommendations Eye-friendly themes for comfortable development:\nOne Dark Pro: Popular dark theme Material Theme: Google Material Design Dracula: Elegant dark theme Conclusion The power of VS Code lies in its extensibility. Customize it to fit your development style and boost your productivity!\nWhat VS Code tips or extensions would you recommend? Please share in the comments! üöÄ\n"},{
  "section": "Blog",
  "slug": "/en/blog/react-hooks-guide/",
  "title": "React Functional Components and Hooks Guide",
  "description": "Learn how to use React functional components and essential Hooks with practical examples.",
  "date": "August 1, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Web Development",
  "tags": "React, Hooks, JavaScript, Frontend",
  "content":"React Hooks, introduced in React 16.8, enable state management and lifecycle features in functional components. Let\u0026rsquo;s explore the essential Hooks and their usage.\nuseState - State Management The most basic Hook for managing state in functional components.\nimport React, { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Increment \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count - 1)}\u0026gt; Decrement \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(0)}\u0026gt; Reset \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } // Managing object state function UserProfile() { const [user, setUser] = useState({ name: \u0026#39;\u0026#39;, email: \u0026#39;\u0026#39;, age: 0 }); const updateUser = (field, value) =\u0026gt; { setUser(prevUser =\u0026gt; ({ ...prevUser, [field]: value })); }; return ( \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Name\u0026#34; value={user.name} onChange={(e) =\u0026gt; updateUser(\u0026#39;name\u0026#39;, e.target.value)} /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; placeholder=\u0026#34;Email\u0026#34; value={user.email} onChange={(e) =\u0026gt; updateUser(\u0026#39;email\u0026#39;, e.target.value)} /\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; placeholder=\u0026#34;Age\u0026#34; value={user.age} onChange={(e) =\u0026gt; updateUser(\u0026#39;age\u0026#39;, parseInt(e.target.value))} /\u0026gt; \u0026lt;/form\u0026gt; ); } useEffect - Side Effects Handle side effects like data fetching, subscriptions, or manual DOM manipulation.\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; function UserList() { const [users, setUsers] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); // Effect without dependencies - runs on every render useEffect(() =\u0026gt; { console.log(\u0026#39;Component rendered\u0026#39;); }); // Effect with empty dependency array - runs once on mount useEffect(() =\u0026gt; { fetchUsers(); }, []); // Effect with dependencies - runs when dependencies change useEffect(() =\u0026gt; { document.title = `${users.length} users loaded`; }, [users.length]); // Effect with cleanup useEffect(() =\u0026gt; { const timer = setInterval(() =\u0026gt; { console.log(\u0026#39;Timer tick\u0026#39;); }, 1000); // Cleanup function return () =\u0026gt; { clearInterval(timer); }; }, []); const fetchUsers = async () =\u0026gt; { try { setLoading(true); const response = await fetch(\u0026#39;/api/users\u0026#39;); const userData = await response.json(); setUsers(userData); } catch (err) { setError(err.message); } finally { setLoading(false); } }; if (loading) return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; if (error) return \u0026lt;div\u0026gt;Error: {error}\u0026lt;/div\u0026gt;; return ( \u0026lt;ul\u0026gt; {users.map(user =\u0026gt; ( \u0026lt;li key={user.id}\u0026gt;{user.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ); } useContext - Context API Share data across components without prop drilling.\nimport React, { createContext, useContext, useState } from \u0026#39;react\u0026#39;; // Create context const AuthContext = createContext(); // Provider component function AuthProvider({ children }) { const [user, setUser] = useState(null); const [isLoggedIn, setIsLoggedIn] = useState(false); const login = async (credentials) =\u0026gt; { try { const response = await fetch(\u0026#39;/api/login\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(credentials) }); const userData = await response.json(); setUser(userData); setIsLoggedIn(true); } catch (error) { console.error(\u0026#39;Login failed:\u0026#39;, error); } }; const logout = () =\u0026gt; { setUser(null); setIsLoggedIn(false); }; const value = { user, isLoggedIn, login, logout }; return ( \u0026lt;AuthContext.Provider value={value}\u0026gt; {children} \u0026lt;/AuthContext.Provider\u0026gt; ); } // Custom hook for using auth context function useAuth() { const context = useContext(AuthContext); if (!context) { throw new Error(\u0026#39;useAuth must be used within AuthProvider\u0026#39;); } return context; } // Using the context function LoginButton() { const { isLoggedIn, login, logout, user } = useAuth(); if (isLoggedIn) { return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Welcome, {user.name}!\u0026lt;/span\u0026gt; \u0026lt;button onClick={logout}\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } return ( \u0026lt;button onClick={() =\u0026gt; login({ email: \u0026#39;user@example.com\u0026#39;, password: \u0026#39;password\u0026#39; })}\u0026gt; Login \u0026lt;/button\u0026gt; ); } useReducer - Complex State Management An alternative to useState for more complex state logic.\nimport React, { useReducer } from \u0026#39;react\u0026#39;; // Reducer function function todoReducer(state, action) { switch (action.type) { case \u0026#39;ADD_TODO\u0026#39;: return { ...state, todos: [...state.todos, { id: Date.now(), text: action.payload, completed: false }] }; case \u0026#39;TOGGLE_TODO\u0026#39;: return { ...state, todos: state.todos.map(todo =\u0026gt; todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo ) }; case \u0026#39;DELETE_TODO\u0026#39;: return { ...state, todos: state.todos.filter(todo =\u0026gt; todo.id !== action.payload) }; case \u0026#39;SET_FILTER\u0026#39;: return { ...state, filter: action.payload }; default: return state; } } function TodoApp() { const initialState = { todos: [], filter: \u0026#39;all\u0026#39; // \u0026#39;all\u0026#39;, \u0026#39;active\u0026#39;, \u0026#39;completed\u0026#39; }; const [state, dispatch] = useReducer(todoReducer, initialState); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const addTodo = () =\u0026gt; { if (inputValue.trim()) { dispatch({ type: \u0026#39;ADD_TODO\u0026#39;, payload: inputValue }); setInputValue(\u0026#39;\u0026#39;); } }; const filteredTodos = state.todos.filter(todo =\u0026gt; { if (state.filter === \u0026#39;active\u0026#39;) return !todo.completed; if (state.filter === \u0026#39;completed\u0026#39;) return todo.completed; return true; }); return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input value={inputValue} onChange={(e) =\u0026gt; setInputValue(e.target.value)} onKeyPress={(e) =\u0026gt; e.key === \u0026#39;Enter\u0026#39; \u0026amp;\u0026amp; addTodo()} placeholder=\u0026#34;Add a todo...\u0026#34; /\u0026gt; \u0026lt;button onClick={addTodo}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;SET_FILTER\u0026#39;, payload: \u0026#39;all\u0026#39; })} style={{ fontWeight: state.filter === \u0026#39;all\u0026#39; ? \u0026#39;bold\u0026#39; : \u0026#39;normal\u0026#39; }} \u0026gt; All \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;SET_FILTER\u0026#39;, payload: \u0026#39;active\u0026#39; })} style={{ fontWeight: state.filter === \u0026#39;active\u0026#39; ? \u0026#39;bold\u0026#39; : \u0026#39;normal\u0026#39; }} \u0026gt; Active \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;SET_FILTER\u0026#39;, payload: \u0026#39;completed\u0026#39; })} style={{ fontWeight: state.filter === \u0026#39;completed\u0026#39; ? \u0026#39;bold\u0026#39; : \u0026#39;normal\u0026#39; }} \u0026gt; Completed \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ul\u0026gt; {filteredTodos.map(todo =\u0026gt; ( \u0026lt;li key={todo.id}\u0026gt; \u0026lt;span style={{ textDecoration: todo.completed ? \u0026#39;line-through\u0026#39; : \u0026#39;none\u0026#39;, cursor: \u0026#39;pointer\u0026#39; }} onClick={() =\u0026gt; dispatch({ type: \u0026#39;TOGGLE_TODO\u0026#39;, payload: todo.id })} \u0026gt; {todo.text} \u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;DELETE_TODO\u0026#39;, payload: todo.id })}\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } useMemo - Performance Optimization Memoize expensive calculations.\nimport React, { useState, useMemo } from \u0026#39;react\u0026#39;; function ExpensiveComponent() { const [count, setCount] = useState(0); const [items, setItems] = useState([]); // Expensive calculation const expensiveValue = useMemo(() =\u0026gt; { console.log(\u0026#39;Calculating expensive value...\u0026#39;); let result = 0; for (let i = 0; i \u0026lt; 1000000; i++) { result += i; } return result; }, [count]); // Only recalculate when count changes // Memoized filtered items const expensiveItems = useMemo(() =\u0026gt; { console.log(\u0026#39;Filtering items...\u0026#39;); return items.filter(item =\u0026gt; item.value \u0026gt; 50); }, [items]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Expensive Value: {expensiveValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Filtered Items: {expensiveItems.length}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Increment Count \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setItems([...items, { value: Math.random() * 100 }])}\u0026gt; Add Random Item \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } useCallback - Function Memoization Memoize functions to prevent unnecessary re-renders.\nimport React, { useState, useCallback, memo } from \u0026#39;react\u0026#39;; // Child component that might re-render unnecessarily const TodoItem = memo(({ todo, onToggle, onDelete }) =\u0026gt; { console.log(`Rendering TodoItem ${todo.id}`); return ( \u0026lt;li\u0026gt; \u0026lt;span style={{ textDecoration: todo.completed ? \u0026#39;line-through\u0026#39; : \u0026#39;none\u0026#39; }} onClick={() =\u0026gt; onToggle(todo.id)} \u0026gt; {todo.text} \u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; onDelete(todo.id)}\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ); }); function TodoList() { const [todos, setTodos] = useState([]); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); // Memoized callback functions const handleToggle = useCallback((id) =\u0026gt; { setTodos(prevTodos =\u0026gt; prevTodos.map(todo =\u0026gt; todo.id === id ? { ...todo, completed: !todo.completed } : todo ) ); }, []); // Empty dependency array since setTodos is stable const handleDelete = useCallback((id) =\u0026gt; { setTodos(prevTodos =\u0026gt; prevTodos.filter(todo =\u0026gt; todo.id !== id)); }, []); const addTodo = useCallback(() =\u0026gt; { if (inputValue.trim()) { setTodos(prevTodos =\u0026gt; [...prevTodos, { id: Date.now(), text: inputValue, completed: false }]); setInputValue(\u0026#39;\u0026#39;); } }, [inputValue]); return ( \u0026lt;div\u0026gt; \u0026lt;input value={inputValue} onChange={(e) =\u0026gt; setInputValue(e.target.value)} onKeyPress={(e) =\u0026gt; e.key === \u0026#39;Enter\u0026#39; \u0026amp;\u0026amp; addTodo()} /\u0026gt; \u0026lt;button onClick={addTodo}\u0026gt;Add Todo\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {todos.map(todo =\u0026gt; ( \u0026lt;TodoItem key={todo.id} todo={todo} onToggle={handleToggle} onDelete={handleDelete} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } useRef - DOM References and Mutable Values Access DOM elements and store mutable values.\nimport React, { useRef, useEffect, useState } from \u0026#39;react\u0026#39;; function FocusInput() { const inputRef = useRef(null); const countRef = useRef(0); const [renderCount, setRenderCount] = useState(0); useEffect(() =\u0026gt; { // Focus input on mount inputRef.current.focus(); }, []); useEffect(() =\u0026gt; { // Update ref value without causing re-render countRef.current += 1; }); const handleClick = () =\u0026gt; { // Access DOM element inputRef.current.focus(); inputRef.current.select(); // Log ref value console.log(`Component rendered ${countRef.current} times`); }; return ( \u0026lt;div\u0026gt; \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Click button to focus\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setRenderCount(renderCount + 1)}\u0026gt; Force Re-render ({renderCount}) \u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Render count stored in ref: {countRef.current}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Custom Hooks Create reusable stateful logic.\nimport { useState, useEffect } from \u0026#39;react\u0026#39;; // Custom hook for API data fetching function useApi(url) { const [data, setData] = useState(null); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); useEffect(() =\u0026gt; { const fetchData = async () =\u0026gt; { try { setLoading(true); const response = await fetch(url); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const result = await response.json(); setData(result); } catch (err) { setError(err.message); } finally { setLoading(false); } }; fetchData(); }, [url]); return { data, loading, error }; } // Custom hook for local storage function useLocalStorage(key, initialValue) { const [storedValue, setStoredValue] = useState(() =\u0026gt; { try { const item = window.localStorage.getItem(key); return item ? JSON.parse(item) : initialValue; } catch (error) { console.error(`Error reading localStorage key \u0026#34;${key}\u0026#34;:`, error); return initialValue; } }); const setValue = (value) =\u0026gt; { try { setStoredValue(value); window.localStorage.setItem(key, JSON.stringify(value)); } catch (error) { console.error(`Error setting localStorage key \u0026#34;${key}\u0026#34;:`, error); } }; return [storedValue, setValue]; } // Using custom hooks function UserProfile() { const { data: user, loading, error } = useApi(\u0026#39;/api/user/profile\u0026#39;); const [preferences, setPreferences] = useLocalStorage(\u0026#39;userPreferences\u0026#39;, { theme: \u0026#39;light\u0026#39;, language: \u0026#39;en\u0026#39; }); if (loading) return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; if (error) return \u0026lt;div\u0026gt;Error: {error}\u0026lt;/div\u0026gt;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Welcome, {user.name}!\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; Theme: \u0026lt;select value={preferences.theme} onChange={(e) =\u0026gt; setPreferences({ ...preferences, theme: e.target.value })} \u0026gt; \u0026lt;option value=\u0026#34;light\u0026#34;\u0026gt;Light\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;dark\u0026#34;\u0026gt;Dark\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } Best Practices 1. Rules of Hooks Only call Hooks at the top level Only call Hooks from React functions Use ESLint plugin to enforce rules 2. Dependency Arrays // Good: Include all dependencies useEffect(() =\u0026gt; { fetchUser(userId); }, [userId]); // Bad: Missing dependencies useEffect(() =\u0026gt; { fetchUser(userId); // userId is used but not in dependencies }, []); // Good: Use callback if you need to avoid dependencies const fetchUser = useCallback(async (id) =\u0026gt; { const response = await fetch(`/api/users/${id}`); setUser(await response.json()); }, []); useEffect(() =\u0026gt; { fetchUser(userId); }, [userId, fetchUser]); 3. Performance Optimization // Use memo for expensive child components const ExpensiveChild = memo(({ data, onUpdate }) =\u0026gt; { // Expensive rendering logic return \u0026lt;div\u0026gt;{/* Complex UI */}\u0026lt;/div\u0026gt;; }); // Use useMemo for expensive calculations const expensiveValue = useMemo(() =\u0026gt; { return heavyCalculation(data); }, [data]); // Use useCallback for event handlers passed to children const handleClick = useCallback((id) =\u0026gt; { // Handle click }, []); Conclusion React Hooks provide a powerful and flexible way to build components. Start with useState and useEffect, then gradually incorporate other Hooks as needed. Custom Hooks are particularly useful for sharing logic between components.\nIn the next post, we\u0026rsquo;ll explore advanced React patterns and state management with Redux Toolkit.\n"},{
  "section": "Blog",
  "slug": "/en/blog/git-branching-strategy/",
  "title": "Git Branching Strategies and Collaboration Workflows",
  "description": "Learn effective Git branching strategies and workflows for team collaboration and version control.",
  "date": "July 31, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Development Tools",
  "tags": "Git, Branching Strategy, Collaboration, Version Control",
  "content":"Using Git effectively in team development is crucial for project success. Let\u0026rsquo;s explore popular Git branching strategies and collaboration workflows.\nGit Flow Strategy Git Flow is one of the most widely used branching strategies.\nBranch Structure main: Released stable code develop: Integration branch for development feature: New feature development release: Release preparation hotfix: Emergency bug fixes # Initialize Git Flow git flow init # Start a new feature git flow feature start user-authentication # Finish a feature git flow feature finish user-authentication # Start a release git flow release start v1.2.0 # Finish a release git flow release finish v1.2.0 # Start a hotfix git flow hotfix start critical-bug # Finish a hotfix git flow hotfix finish critical-bug Workflow Example # Developer A starts working on a new feature git checkout develop git pull origin develop git flow feature start shopping-cart # Make changes and commit git add . git commit -m \u0026#34;Add shopping cart functionality\u0026#34; # Push feature branch git push origin feature/shopping-cart # Finish feature (merges to develop) git flow feature finish shopping-cart # Prepare for release git flow release start v2.1.0 # Make final adjustments git commit -m \u0026#34;Update version number\u0026#34; # Finish release (merges to main and develop) git flow release finish v2.1.0 git push origin main git push origin develop git push --tags GitHub Flow Strategy A simpler strategy ideal for continuous deployment.\nWorkflow Create branch from main Add commits Open Pull Request Discuss and review Deploy and test Merge to main # Create and switch to new branch git checkout -b feature/user-profile git push -u origin feature/user-profile # Make changes and commit git add . git commit -m \u0026#34;Add user profile page\u0026#34; git push origin feature/user-profile # Create Pull Request on GitHub # After review and approval, merge to main git checkout main git pull origin main git branch -d feature/user-profile GitLab Flow Strategy Combines benefits of Git Flow and GitHub Flow with environment branches.\nBranch Structure main: Production code pre-production: Staging environment feature branches: Feature development # Feature development git checkout -b feature/payment-integration main # Development work git add . git commit -m \u0026#34;Implement payment gateway\u0026#34; git push origin feature/payment-integration # Merge to pre-production for testing git checkout pre-production git merge feature/payment-integration git push origin pre-production # After testing, merge to main git checkout main git merge pre-production git push origin main Feature Branch Workflow Simple workflow focusing on feature isolation.\n# Create feature branch git checkout -b feature/search-functionality # Work on feature echo \u0026#34;Search component\u0026#34; \u0026gt; search.js git add search.js git commit -m \u0026#34;Add search functionality\u0026#34; # Push and create pull request git push origin feature/search-functionality # After review, merge via Pull Request # Clean up git checkout main git pull origin main git branch -d feature/search-functionality git push origin --delete feature/search-functionality Advanced Git Techniques Interactive Rebase Clean up commit history before merging:\n# Interactive rebase last 3 commits git rebase -i HEAD~3 # Rebase options: # pick = use commit # reword = edit commit message # edit = edit commit # squash = combine with previous commit # drop = remove commit # Example rebase file: pick abc123 Add login feature squash def456 Fix login bug reword ghi789 Add tests Cherry Pick Apply specific commits to another branch:\n# Apply commit to current branch git cherry-pick abc123 # Apply multiple commits git cherry-pick abc123 def456 # Apply commit without committing git cherry-pick --no-commit abc123 Stashing Temporarily save changes:\n# Stash current changes git stash # Stash with message git stash push -m \u0026#34;Work in progress on feature X\u0026#34; # List stashes git stash list # Apply latest stash git stash pop # Apply specific stash git stash apply stash@{1} # Drop stash git stash drop stash@{0} Conflict Resolution Merge Conflicts # When merge conflicts occur git status # Edit conflicted files # \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD # Your changes # ======= # Their changes # \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; branch-name # After resolving conflicts git add conflicted-file.js git commit -m \u0026#34;Resolve merge conflict\u0026#34; Using Merge Tools # Configure merge tool git config --global merge.tool vimdiff # Use merge tool for conflicts git mergetool # Popular merge tools: # - VS Code: code --wait # - Sublime: subl --wait # - Atom: atom --wait Team Collaboration Best Practices Commit Message Conventions # Conventional Commits format \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;description\u0026gt; [optional body] [optional footer] # Examples: git commit -m \u0026#34;feat(auth): add user authentication\u0026#34; git commit -m \u0026#34;fix(api): resolve null pointer exception\u0026#34; git commit -m \u0026#34;docs(readme): update installation instructions\u0026#34; # Types: # feat: new feature # fix: bug fix # docs: documentation # style: formatting # refactor: code restructuring # test: adding tests # chore: maintenance Pull Request Guidelines ## Pull Request Template ### Description Brief description of changes ### Type of Change - [ ] Bug fix - [ ] New feature - [ ] Breaking change - [ ] Documentation update ### Testing - [ ] Unit tests pass - [ ] Integration tests pass - [ ] Manual testing completed ### Checklist - [ ] Code follows style guidelines - [ ] Self-review completed - [ ] Comments added for complex logic - [ ] Documentation updated Code Review Process # Reviewer checks out PR branch git fetch origin git checkout feature/new-feature # Run tests npm test # Review changes git diff main...feature/new-feature # Add review comments via GitHub/GitLab # Request changes or approve Automation and CI/CD Integration GitHub Actions Workflow # .github/workflows/ci.yml name: CI/CD Pipeline on: push: branches: [ main, develop ] pull_request: branches: [ main ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: \u0026#39;16\u0026#39; - name: Install dependencies run: npm ci - name: Run tests run: npm test - name: Run linting run: npm run lint - name: Build application run: npm run build deploy: needs: test runs-on: ubuntu-latest if: github.ref == \u0026#39;refs/heads/main\u0026#39; steps: - name: Deploy to production run: echo \u0026#34;Deploying to production...\u0026#34; Husky Pre-commit Hooks // package.json { \u0026#34;husky\u0026#34;: { \u0026#34;hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;lint-staged\u0026#34;, \u0026#34;commit-msg\u0026#34;: \u0026#34;commitlint -E HUSKY_GIT_PARAMS\u0026#34; } }, \u0026#34;lint-staged\u0026#34;: { \u0026#34;*.{js,jsx,ts,tsx}\u0026#34;: [ \u0026#34;eslint --fix\u0026#34;, \u0026#34;prettier --write\u0026#34;, \u0026#34;git add\u0026#34; ] } } Branch Protection Rules Protect important branches with rules:\n# GitHub CLI example gh api repos/:owner/:repo/branches/main/protection \\ --method PUT \\ --field required_status_checks=\u0026#39;{\u0026#34;strict\u0026#34;:true,\u0026#34;contexts\u0026#34;:[\u0026#34;ci/tests\u0026#34;]}\u0026#39; \\ --field enforce_admins=true \\ --field required_pull_request_reviews=\u0026#39;{\u0026#34;required_approving_review_count\u0026#34;:2}\u0026#39; \\ --field restrictions=null Release Management Semantic Versioning # Version format: MAJOR.MINOR.PATCH # 1.0.0 ‚Üí 1.0.1 (patch: bug fix) # 1.0.1 ‚Üí 1.1.0 (minor: new feature) # 1.1.0 ‚Üí 2.0.0 (major: breaking change) # Using npm version npm version patch # 1.0.0 ‚Üí 1.0.1 npm version minor # 1.0.1 ‚Üí 1.1.0 npm version major # 1.1.0 ‚Üí 2.0.0 Automated Releases # .github/workflows/release.yml name: Release on: push: tags: - \u0026#39;v*\u0026#39; jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Create Release uses: actions/create-release@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ github.ref }} release_name: Release ${{ github.ref }} draft: false prerelease: false Troubleshooting Common Issues Undo Last Commit # Undo last commit (keep changes) git reset HEAD~1 # Undo last commit (discard changes) git reset --hard HEAD~1 # Undo commit that was already pushed git revert HEAD Clean Working Directory # Remove untracked files git clean -fd # Remove ignored files git clean -fX # Remove all untracked and ignored files git clean -fx Recover Lost Commits # Show reflog git reflog # Recover lost commit git checkout \u0026lt;commit-hash\u0026gt; git checkout -b recovered-branch Choosing the Right Strategy Git Flow Best for: Traditional release cycles Team size: Medium to large Release frequency: Scheduled releases GitHub Flow Best for: Continuous deployment Team size: Small to medium Release frequency: Frequent deployments GitLab Flow Best for: Multiple environments Team size: Any size Release frequency: Regular releases with staging Conclusion Choose a branching strategy that fits your team size, release cycle, and deployment process. Start simple and evolve your workflow as the team grows. Consistency and clear guidelines are more important than the perfect strategy.\nIn the next post, we\u0026rsquo;ll explore advanced Git hooks and automation techniques for maintaining code quality.\n"},{
  "section": "Blog",
  "slug": "/en/blog/docker-development-environment/",
  "title": "Building Development Environment with Docker",
  "description": "Learn how to build consistent development environments using Docker and container-based development workflows.",
  "date": "July 30, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "DevOps, Container",
  "tags": "Docker, DevOps, Container, Development Environment",
  "content":"During development, you often hear \u0026ldquo;It worked on my machine!\u0026rdquo; Docker can solve this problem and help build consistent development environments.\nWhat is Docker? Docker is a container-based virtualization platform. You can package applications and everything needed to run them into a single container.\nAdvantages of Docker Consistency: Same environment anywhere Isolation: Each container runs independently Portability: Can run on any platform Efficiency: Lighter than virtual machines Basic Docker Commands Image Management # Search for images docker search nginx # Pull images docker pull nginx:latest # List images docker images # Remove images docker rmi nginx:latest Container Management # Run container docker run -d --name web-server -p 8080:80 nginx # List containers docker ps -a # Stop container docker stop web-server # Start container docker start web-server # Remove container docker rm web-server Dockerfile Create custom images using Dockerfile:\n# Base image FROM node:18-alpine # Set working directory WORKDIR /app # Copy package files COPY package*.json ./ # Install dependencies RUN npm install # Copy source code COPY . . # Expose port EXPOSE 3000 # Start command CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] Docker Compose Manage multi-container applications:\nversion: \u0026#39;3.8\u0026#39; services: web: build: . ports: - \u0026#34;3000:3000\u0026#34; environment: - NODE_ENV=development volumes: - .:/app - /app/node_modules depends_on: - database database: image: postgres:14 environment: POSTGRES_DB: myapp POSTGRES_USER: user POSTGRES_PASSWORD: password volumes: - postgres_data:/var/lib/postgresql/data ports: - \u0026#34;5432:5432\u0026#34; volumes: postgres_data: Development Environment Setup 1. Node.js Project # Create project directory mkdir my-node-app \u0026amp;\u0026amp; cd my-node-app # Create Dockerfile cat \u0026gt; Dockerfile \u0026lt;\u0026lt; EOF FROM node:18-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . EXPOSE 3000 CMD [\u0026#34;npm\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;dev\u0026#34;] EOF # Create docker-compose.yml cat \u0026gt; docker-compose.yml \u0026lt;\u0026lt; EOF version: \u0026#39;3.8\u0026#39; services: app: build: . ports: - \u0026#34;3000:3000\u0026#34; volumes: - .:/app - /app/node_modules environment: - NODE_ENV=development EOF # Start development environment docker-compose up 2. Java Spring Boot Project FROM openjdk:17-jdk-slim WORKDIR /app COPY pom.xml . COPY .mvn .mvn COPY mvnw . RUN chmod +x mvnw \u0026amp;\u0026amp; ./mvnw dependency:go-offline COPY src ./src EXPOSE 8080 CMD [\u0026#34;./mvnw\u0026#34;, \u0026#34;spring-boot:run\u0026#34;] Best Practices 1. .dockerignore node_modules npm-debug.log .git .gitignore README.md .env .nyc_output coverage .tmp 2. Multi-stage Build # Build stage FROM node:18-alpine AS builder WORKDIR /app COPY package*.json ./ RUN npm ci --only=production # Production stage FROM node:18-alpine WORKDIR /app COPY --from=builder /app/node_modules ./node_modules COPY . . EXPOSE 3000 CMD [\u0026#34;node\u0026#34;, \u0026#34;server.js\u0026#34;] 3. Health Checks HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\ CMD curl -f http://localhost:3000/health || exit 1 Development Workflow 1. Code ‚Üí Build ‚Üí Test ‚Üí Deploy # Build image docker build -t myapp:latest . # Run tests docker run --rm myapp:latest npm test # Deploy to staging docker run -d --name staging-app -p 3001:3000 myapp:latest 2. CI/CD Pipeline # .github/workflows/docker.yml name: Docker Build and Deploy on: push: branches: [ main ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Build Docker image run: docker build -t myapp . - name: Run tests run: docker run --rm myapp npm test - name: Deploy to production run: | docker tag myapp myregistry/myapp:latest docker push myregistry/myapp:latest Troubleshooting Common Issues Port conflicts\n# Check port usage lsof -i :3000 # Use different port docker run -p 3001:3000 myapp Volume mount issues\n# Check volume mounts docker inspect container_name # Fix permissions docker run --user $(id -u):$(id -g) myapp Network issues\n# Create custom network docker network create mynetwork # Run containers on same network docker run --network mynetwork myapp Conclusion Docker greatly improves development productivity by providing consistent environments. Start with simple Dockerfile and docker-compose.yml files, then gradually adopt more advanced features.\nIn the next post, we\u0026rsquo;ll explore Kubernetes orchestration and container deployment strategies.\n"},{
  "section": "Blog",
  "slug": "/en/blog/javascript-es6-features/",
  "title": "Essential JavaScript ES6+ Features",
  "description": "Explore core features of modern JavaScript with examples and learn how to use them in real-world projects.",
  "date": "July 29, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "JavaScript, Frontend",
  "tags": "JavaScript, ES6, Modern JavaScript, Frontend",
  "content":"JavaScript ES6 (ECMAScript 2015) introduced many new features. Let\u0026rsquo;s explore the essential features commonly used in real-world development.\n1. let and const Use let and const with block scope instead of var.\n// Problem with var for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 3, 3, 3 } // Solution with let for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 0, 1, 2 } // const for constants const API_URL = \u0026#39;https://api.example.com\u0026#39;; const config = { timeout: 5000, retries: 3 }; 2. Arrow Functions Concise function syntax with lexical this binding.\n// Traditional function function add(a, b) { return a + b; } // Arrow function const add = (a, b) =\u0026gt; a + b; // With single parameter const square = x =\u0026gt; x * x; // With multiple statements const processData = (data) =\u0026gt; { const processed = data.map(item =\u0026gt; item.value); return processed.filter(value =\u0026gt; value \u0026gt; 0); }; // Lexical this binding class Timer { constructor() { this.seconds = 0; } start() { // Arrow function preserves \u0026#39;this\u0026#39; setInterval(() =\u0026gt; { this.seconds++; console.log(this.seconds); }, 1000); } } 3. Template Literals String interpolation and multi-line strings.\nconst name = \u0026#39;John\u0026#39;; const age = 30; // String interpolation const message = `Hello, ${name}! You are ${age} years old.`; // Multi-line strings const html = ` \u0026lt;div class=\u0026#34;user-card\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Expression evaluation const price = 19.99; const tax = 0.08; const total = `Total: $${(price * (1 + tax)).toFixed(2)}`; 4. Destructuring Assignment Extract values from arrays and objects.\n// Array destructuring const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(rest); // [3, 4, 5] // Object destructuring const user = { name: \u0026#39;Alice\u0026#39;, email: \u0026#39;alice@example.com\u0026#39;, age: 25 }; const { name, email } = user; console.log(name); // \u0026#39;Alice\u0026#39; // Destructuring with default values const { name: userName, country = \u0026#39;Unknown\u0026#39; } = user; // Function parameter destructuring function createUser({ name, email, age = 18 }) { return { id: Date.now(), name, email, age }; } 5. Spread and Rest Operators Spread arrays/objects and collect function parameters.\n// Spread operator with arrays const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Spread operator with objects const defaults = { theme: \u0026#39;dark\u0026#39;, language: \u0026#39;en\u0026#39; }; const userPrefs = { language: \u0026#39;ko\u0026#39;, fontSize: 14 }; const settings = { ...defaults, ...userPrefs }; // { theme: \u0026#39;dark\u0026#39;, language: \u0026#39;ko\u0026#39;, fontSize: 14 } // Rest parameters function sum(...numbers) { return numbers.reduce((total, num) =\u0026gt; total + num, 0); } sum(1, 2, 3, 4); // 10 6. Enhanced Object Literals Concise property and method definitions.\nconst name = \u0026#39;Product\u0026#39;; const price = 29.99; // Shorthand property names const product = { name, // instead of name: name price, // instead of price: price // Method shorthand getDetails() { // instead of getDetails: function() return `${this.name}: $${this.price}`; }, // Computed property names [`${name.toLowerCase()}_id`]: 12345 }; 7. Classes Class-based object-oriented programming.\nclass Vehicle { constructor(make, model) { this.make = make; this.model = model; } getInfo() { return `${this.make} ${this.model}`; } // Static method static compare(v1, v2) { return v1.make === v2.make; } } class Car extends Vehicle { constructor(make, model, doors) { super(make, model); this.doors = doors; } getDetails() { return `${this.getInfo()} with ${this.doors} doors`; } } const myCar = new Car(\u0026#39;Toyota\u0026#39;, \u0026#39;Camry\u0026#39;, 4); console.log(myCar.getDetails()); // Toyota Camry with 4 doors 8. Modules Import and export functionality between files.\n// math.js export const PI = 3.14159; export function add(a, b) { return a + b; } export function multiply(a, b) { return a * b; } // Default export export default function subtract(a, b) { return a - b; } // main.js import subtract, { PI, add, multiply } from \u0026#39;./math.js\u0026#39;; console.log(PI); // 3.14159 console.log(add(2, 3)); // 5 console.log(subtract(5, 2)); // 3 9. Promises and Async/Await Handle asynchronous operations.\n// Promise function fetchUser(id) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { if (id \u0026gt; 0) { resolve({ id, name: `User ${id}` }); } else { reject(new Error(\u0026#39;Invalid user ID\u0026#39;)); } }, 1000); }); } // Using Promise fetchUser(1) .then(user =\u0026gt; console.log(user)) .catch(error =\u0026gt; console.error(error)); // Using async/await async function getUser(id) { try { const user = await fetchUser(id); console.log(user); return user; } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error.message); } } 10. Array Methods Powerful array manipulation methods.\nconst numbers = [1, 2, 3, 4, 5]; // map - transform elements const doubled = numbers.map(n =\u0026gt; n * 2); // [2, 4, 6, 8, 10] // filter - select elements const evens = numbers.filter(n =\u0026gt; n % 2 === 0); // [2, 4] // reduce - accumulate values const sum = numbers.reduce((total, n) =\u0026gt; total + n, 0); // 15 // find - find first match const found = numbers.find(n =\u0026gt; n \u0026gt; 3); // 4 // some/every - test conditions const hasEven = numbers.some(n =\u0026gt; n % 2 === 0); // true const allPositive = numbers.every(n =\u0026gt; n \u0026gt; 0); // true 11. Set and Map New collection types.\n// Set - unique values const uniqueNumbers = new Set([1, 2, 2, 3, 3, 4]); console.log(uniqueNumbers); // Set {1, 2, 3, 4} uniqueNumbers.add(5); uniqueNumbers.delete(1); console.log(uniqueNumbers.has(2)); // true // Map - key-value pairs const userRoles = new Map(); userRoles.set(\u0026#39;john\u0026#39;, \u0026#39;admin\u0026#39;); userRoles.set(\u0026#39;alice\u0026#39;, \u0026#39;user\u0026#39;); userRoles.set(\u0026#39;bob\u0026#39;, \u0026#39;moderator\u0026#39;); console.log(userRoles.get(\u0026#39;john\u0026#39;)); // \u0026#39;admin\u0026#39; console.log(userRoles.size); // 3 // Iterating for (const [user, role] of userRoles) { console.log(`${user}: ${role}`); } 12. Default Parameters Set default values for function parameters.\nfunction createUser(name, role = \u0026#39;user\u0026#39;, active = true) { return { name, role, active, createdAt: new Date() }; } const user1 = createUser(\u0026#39;John\u0026#39;); // { name: \u0026#39;John\u0026#39;, role: \u0026#39;user\u0026#39;, active: true, createdAt: ... } const user2 = createUser(\u0026#39;Alice\u0026#39;, \u0026#39;admin\u0026#39;, false); // { name: \u0026#39;Alice\u0026#39;, role: \u0026#39;admin\u0026#39;, active: false, createdAt: ... } Real-World Example Putting it all together in a practical example:\nclass TodoManager { constructor() { this.todos = new Map(); this.nextId = 1; } addTodo(text, priority = \u0026#39;medium\u0026#39;) { const todo = { id: this.nextId++, text, priority, completed: false, createdAt: new Date() }; this.todos.set(todo.id, todo); return todo; } async saveTodos() { const todosArray = [...this.todos.values()]; try { const response = await fetch(\u0026#39;/api/todos\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(todosArray) }); if (!response.ok) { throw new Error(\u0026#39;Failed to save todos\u0026#39;); } return await response.json(); } catch (error) { console.error(\u0026#39;Save failed:\u0026#39;, error); throw error; } } getFilteredTodos({ completed, priority } = {}) { return [...this.todos.values()] .filter(todo =\u0026gt; { if (completed !== undefined \u0026amp;\u0026amp; todo.completed !== completed) { return false; } if (priority \u0026amp;\u0026amp; todo.priority !== priority) { return false; } return true; }) .sort((a, b) =\u0026gt; b.createdAt - a.createdAt); } } // Usage const todoManager = new TodoManager(); todoManager.addTodo(\u0026#39;Learn ES6+\u0026#39;, \u0026#39;high\u0026#39;); todoManager.addTodo(\u0026#39;Build a project\u0026#39;); todoManager.addTodo(\u0026#39;Write documentation\u0026#39;, \u0026#39;low\u0026#39;); const highPriorityTodos = todoManager.getFilteredTodos({ priority: \u0026#39;high\u0026#39; }); console.log(highPriorityTodos); Conclusion These ES6+ features make JavaScript more expressive and powerful. Start incorporating them into your projects gradually, focusing on the ones that provide the most immediate benefit to your coding style.\nIn the next post, we\u0026rsquo;ll explore React Hooks and modern React development patterns.\n"},{
  "section": "Blog",
  "slug": "/en/blog/event-driven-architecture-cqrs/",
  "title": "Event-Driven Architecture and CQRS: Scalable System Design",
  "description": "Learn how to build scalable and resilient backend systems using event sourcing, CQRS, and event streaming with practical implementation examples.",
  "date": "January 18, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Architecture, DevOps",
  "tags": "Event-Driven Architecture, CQRS, Event Sourcing, Apache Kafka, Microservices",
  "content":"Event-driven architecture (EDA) and CQRS (Command Query Responsibility Segregation) have become core patterns for large-scale distributed systems in 2025 backend development. Let\u0026rsquo;s explore these essential patterns for modern applications requiring real-time data processing and high scalability with practical code examples.\nCore Concepts of Event-Driven Architecture 1. Event Store Implementation // Event definition interface Event { id: string streamId: string eventType: string eventVersion: number data: any metadata: any timestamp: Date } interface EventStore { append(streamId: string, events: Event[]): Promise\u0026lt;void\u0026gt; read(streamId: string, fromVersion?: number): Promise\u0026lt;Event[]\u0026gt; subscribe(eventType: string, handler: EventHandler): void } // PostgreSQL-based event store class PostgreSQLEventStore implements EventStore { constructor(private db: Pool) {} async append(streamId: string, events: Event[]): Promise\u0026lt;void\u0026gt; { const client = await this.db.connect() try { await client.query(\u0026#39;BEGIN\u0026#39;) for (const event of events) { await client.query(` INSERT INTO events ( id, stream_id, event_type, event_version, data, metadata, timestamp ) VALUES ($1, $2, $3, $4, $5, $6, $7) `, [ event.id, event.streamId, event.eventType, event.eventVersion, JSON.stringify(event.data), JSON.stringify(event.metadata), event.timestamp ]) } await client.query(\u0026#39;COMMIT\u0026#39;) } catch (error) { await client.query(\u0026#39;ROLLBACK\u0026#39;) throw error } finally { client.release() } } async read(streamId: string, fromVersion = 0): Promise\u0026lt;Event[]\u0026gt; { const result = await this.db.query(` SELECT * FROM events WHERE stream_id = $1 AND event_version \u0026gt;= $2 ORDER BY event_version ASC `, [streamId, fromVersion]) return result.rows.map(row =\u0026gt; ({ id: row.id, streamId: row.stream_id, eventType: row.event_type, eventVersion: row.event_version, data: JSON.parse(row.data), metadata: JSON.parse(row.metadata), timestamp: row.timestamp })) } subscribe(eventType: string, handler: EventHandler): void { // Using PostgreSQL LISTEN/NOTIFY this.db.connect().then(client =\u0026gt; { client.query(`LISTEN ${eventType}`) client.on(\u0026#39;notification\u0026#39;, (msg) =\u0026gt; { const event = JSON.parse(msg.payload) handler(event) }) }) } } 2. Aggregates and Event Sourcing // Domain event definition abstract class DomainEvent { abstract eventType: string constructor( public aggregateId: string, public timestamp: Date = new Date() ) {} } class UserRegisteredEvent extends DomainEvent { eventType = \u0026#39;UserRegistered\u0026#39; constructor( aggregateId: string, public email: string, public name: string ) { super(aggregateId) } } class UserEmailChangedEvent extends DomainEvent { eventType = \u0026#39;UserEmailChanged\u0026#39; constructor( aggregateId: string, public newEmail: string, public oldEmail: string ) { super(aggregateId) } } // Aggregate root abstract class AggregateRoot { protected uncommittedEvents: DomainEvent[] = [] protected version = 0 protected addEvent(event: DomainEvent): void { this.uncommittedEvents.push(event) this.apply(event) } abstract apply(event: DomainEvent): void getUncommittedEvents(): DomainEvent[] { return [...this.uncommittedEvents] } markEventsAsCommitted(): void { this.uncommittedEvents = [] } loadFromHistory(events: DomainEvent[]): void { events.forEach(event =\u0026gt; { this.apply(event) this.version++ }) } } // User aggregate class User extends AggregateRoot { private id: string private email: string private name: string private isActive: boolean static create(id: string, email: string, name: string): User { const user = new User() user.addEvent(new UserRegisteredEvent(id, email, name)) return user } changeEmail(newEmail: string): void { if (this.email === newEmail) return this.addEvent(new UserEmailChangedEvent( this.id, newEmail, this.email )) } apply(event: DomainEvent): void { switch (event.eventType) { case \u0026#39;UserRegistered\u0026#39;: const registered = event as UserRegisteredEvent this.id = registered.aggregateId this.email = registered.email this.name = registered.name this.isActive = true break case \u0026#39;UserEmailChanged\u0026#39;: const emailChanged = event as UserEmailChangedEvent this.email = emailChanged.newEmail break } } getId(): string { return this.id } getEmail(): string { return this.email } getName(): string { return this.name } } CQRS Pattern Implementation 1. Command and Query Separation // Command definition interface Command { id: string userId: string timestamp: Date } class RegisterUserCommand implements Command { constructor( public id: string, public userId: string, public email: string, public name: string, public timestamp: Date = new Date() ) {} } class ChangeUserEmailCommand implements Command { constructor( public id: string, public userId: string, public newEmail: string, public timestamp: Date = new Date() ) {} } // Command handler interface CommandHandler\u0026lt;T extends Command\u0026gt; { handle(command: T): Promise\u0026lt;void\u0026gt; } class RegisterUserCommandHandler implements CommandHandler\u0026lt;RegisterUserCommand\u0026gt; { constructor( private userRepository: UserRepository, private eventStore: EventStore ) {} async handle(command: RegisterUserCommand): Promise\u0026lt;void\u0026gt; { // Business rule validation const existingUser = await this.userRepository.findByEmail(command.email) if (existingUser) { throw new Error(\u0026#39;User with this email already exists\u0026#39;) } // Create aggregate const user = User.create(command.userId, command.email, command.name) // Store events const events = user.getUncommittedEvents().map(event =\u0026gt; ({ id: generateId(), streamId: user.getId(), eventType: event.eventType, eventVersion: 1, data: event, metadata: { commandId: command.id }, timestamp: event.timestamp })) await this.eventStore.append(user.getId(), events) user.markEventsAsCommitted() } } // Query model interface UserReadModel { id: string email: string name: string registeredAt: Date lastUpdated: Date } interface UserQueryRepository { findById(id: string): Promise\u0026lt;UserReadModel | null\u0026gt; findByEmail(email: string): Promise\u0026lt;UserReadModel | null\u0026gt; findAll(page: number, size: number): Promise\u0026lt;UserReadModel[]\u0026gt; } // Read model projection class UserProjection { constructor( private queryRepository: UserQueryRepository, private eventStore: EventStore ) { this.subscribeToEvents() } private subscribeToEvents(): void { this.eventStore.subscribe(\u0026#39;UserRegistered\u0026#39;, this.handleUserRegistered.bind(this)) this.eventStore.subscribe(\u0026#39;UserEmailChanged\u0026#39;, this.handleUserEmailChanged.bind(this)) } private async handleUserRegistered(event: UserRegisteredEvent): Promise\u0026lt;void\u0026gt; { const readModel: UserReadModel = { id: event.aggregateId, email: event.email, name: event.name, registeredAt: event.timestamp, lastUpdated: event.timestamp } await this.queryRepository.save(readModel) } private async handleUserEmailChanged(event: UserEmailChangedEvent): Promise\u0026lt;void\u0026gt; { const user = await this.queryRepository.findById(event.aggregateId) if (user) { user.email = event.newEmail user.lastUpdated = event.timestamp await this.queryRepository.save(user) } } } 2. Event Bus and Message Broker // Apache Kafka event bus import { Kafka, Producer, Consumer } from \u0026#39;kafkajs\u0026#39; class KafkaEventBus { private kafka: Kafka private producer: Producer private consumers: Map\u0026lt;string, Consumer\u0026gt; = new Map() constructor(brokers: string[]) { this.kafka = new Kafka({ clientId: \u0026#39;event-bus\u0026#39;, brokers }) this.producer = this.kafka.producer() } async initialize(): Promise\u0026lt;void\u0026gt; { await this.producer.connect() } async publish(topic: string, events: DomainEvent[]): Promise\u0026lt;void\u0026gt; { const messages = events.map(event =\u0026gt; ({ key: event.aggregateId, value: JSON.stringify(event), headers: { eventType: event.eventType, timestamp: event.timestamp.toISOString() } })) await this.producer.send({ topic, messages }) } async subscribe( topic: string, groupId: string, handler: (event: DomainEvent) =\u0026gt; Promise\u0026lt;void\u0026gt; ): Promise\u0026lt;void\u0026gt; { const consumer = this.kafka.consumer({ groupId }) await consumer.connect() await consumer.subscribe({ topic }) await consumer.run({ eachMessage: async ({ message }) =\u0026gt; { try { const event = JSON.parse(message.value?.toString() || \u0026#39;{}\u0026#39;) await handler(event) } catch (error) { console.error(\u0026#39;Event processing failed:\u0026#39;, error) // Send to dead letter queue or retry logic } } }) this.consumers.set(`${topic}-${groupId}`, consumer) } async shutdown(): Promise\u0026lt;void\u0026gt; { await this.producer.disconnect() for (const consumer of this.consumers.values()) { await consumer.disconnect() } } } Real-time Event Processing 1. Event Stream Processing // Event stream processor class EventStreamProcessor { private isRunning = false private checkpointInterval = 5000 // 5 seconds private lastCheckpoint = 0 constructor( private eventStore: EventStore, private projections: EventProjection[] ) {} async start(): Promise\u0026lt;void\u0026gt; { this.isRunning = true this.lastCheckpoint = await this.loadCheckpoint() console.log(`Starting event stream processor from checkpoint: ${this.lastCheckpoint}`) while (this.isRunning) { try { const events = await this.fetchEvents(this.lastCheckpoint, 100) if (events.length \u0026gt; 0) { await this.processEvents(events) this.lastCheckpoint = events[events.length - 1].eventVersion await this.saveCheckpoint(this.lastCheckpoint) } else { await this.sleep(1000) // Wait 1 second } } catch (error) { console.error(\u0026#39;Event processing error:\u0026#39;, error) await this.sleep(5000) // Wait 5 seconds on error } } } stop(): void { this.isRunning = false } private async processEvents(events: Event[]): Promise\u0026lt;void\u0026gt; { for (const event of events) { for (const projection of this.projections) { if (projection.canHandle(event.eventType)) { await projection.handle(event) } } } } private async fetchEvents(fromVersion: number, limit: number): Promise\u0026lt;Event[]\u0026gt; { // Fetch events from global event stream return this.eventStore.readGlobalStream(fromVersion, limit) } private async loadCheckpoint(): Promise\u0026lt;number\u0026gt; { // Load last processed event version from checkpoint store return 0 // Implementation needed } private async saveCheckpoint(version: number): Promise\u0026lt;void\u0026gt; { // Save checkpoint } private sleep(ms: number): Promise\u0026lt;void\u0026gt; { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)) } } 2. Complex Event Processing (CEP) // Complex event definition interface EventPattern { name: string events: string[] timeWindow: number // milliseconds condition: (events: DomainEvent[]) =\u0026gt; boolean } class ComplexEventProcessor { private eventBuffer: Map\u0026lt;string, DomainEvent[]\u0026gt; = new Map() private patterns: EventPattern[] = [] addPattern(pattern: EventPattern): void { this.patterns.push(pattern) } processEvent(event: DomainEvent): void { // Add event to buffer const key = `${event.aggregateId}-${event.eventType}` const events = this.eventBuffer.get(key) || [] events.push(event) this.eventBuffer.set(key, events) // Check pattern matching this.checkPatterns(event.aggregateId) // Clean up old events this.cleanupOldEvents() } private checkPatterns(aggregateId: string): void { for (const pattern of this.patterns) { const relevantEvents = this.getEventsForPattern(aggregateId, pattern) if (relevantEvents.length \u0026gt;= pattern.events.length) { const sortedEvents = relevantEvents.sort((a, b) =\u0026gt; a.timestamp.getTime() - b.timestamp.getTime() ) // Check time window const firstEvent = sortedEvents[0] const lastEvent = sortedEvents[sortedEvents.length - 1] const timeDiff = lastEvent.timestamp.getTime() - firstEvent.timestamp.getTime() if (timeDiff \u0026lt;= pattern.timeWindow \u0026amp;\u0026amp; pattern.condition(sortedEvents)) { this.triggerPattern(pattern, sortedEvents) } } } } private getEventsForPattern(aggregateId: string, pattern: EventPattern): DomainEvent[] { const events: DomainEvent[] = [] for (const eventType of pattern.events) { const key = `${aggregateId}-${eventType}` const bufferEvents = this.eventBuffer.get(key) || [] events.push(...bufferEvents) } return events } private triggerPattern(pattern: EventPattern, events: DomainEvent[]): void { console.log(`Pattern triggered: ${pattern.name}`, events) // Handle complex event occurrence } private cleanupOldEvents(): void { const now = Date.now() const maxAge = 60000 // 1 minute for (const [key, events] of this.eventBuffer.entries()) { const validEvents = events.filter(event =\u0026gt; now - event.timestamp.getTime() \u0026lt; maxAge ) if (validEvents.length === 0) { this.eventBuffer.delete(key) } else { this.eventBuffer.set(key, validEvents) } } } } // Usage example const cep = new ComplexEventProcessor() cep.addPattern({ name: \u0026#39;SuspiciousUserActivity\u0026#39;, events: [\u0026#39;UserLoginFailed\u0026#39;, \u0026#39;UserLoginFailed\u0026#39;, \u0026#39;UserLoginFailed\u0026#39;], timeWindow: 300000, // 5 minutes condition: (events) =\u0026gt; events.length \u0026gt;= 3 }) Error Handling and Resilience 1. Compensating Transactions (Saga Pattern) // Saga status enum SagaStatus { Started = \u0026#39;started\u0026#39;, Completed = \u0026#39;completed\u0026#39;, Failed = \u0026#39;failed\u0026#39;, Compensating = \u0026#39;compensating\u0026#39;, Compensated = \u0026#39;compensated\u0026#39; } interface SagaStep { name: string execute: () =\u0026gt; Promise\u0026lt;void\u0026gt; compensate: () =\u0026gt; Promise\u0026lt;void\u0026gt; } class Saga { private steps: SagaStep[] = [] private executedSteps: SagaStep[] = [] private status = SagaStatus.Started addStep(step: SagaStep): void { this.steps.push(step) } async execute(): Promise\u0026lt;void\u0026gt; { try { for (const step of this.steps) { await step.execute() this.executedSteps.push(step) } this.status = SagaStatus.Completed } catch (error) { this.status = SagaStatus.Failed await this.compensate() throw error } } private async compensate(): Promise\u0026lt;void\u0026gt; { this.status = SagaStatus.Compensating // Compensate executed steps in reverse order for (const step of this.executedSteps.reverse()) { try { await step.compensate() } catch (error) { console.error(`Compensation failed for step: ${step.name}`, error) } } this.status = SagaStatus.Compensated } } 2. Event Reprocessing and Idempotency class IdempotentEventHandler { private processedEvents = new Set\u0026lt;string\u0026gt;() async handle(event: DomainEvent, handler: () =\u0026gt; Promise\u0026lt;void\u0026gt;): Promise\u0026lt;void\u0026gt; { const eventId = this.generateEventId(event) if (this.processedEvents.has(eventId)) { console.log(`Event already processed: ${eventId}`) return } try { await handler() this.processedEvents.add(eventId) } catch (error) { console.error(`Event processing failed: ${eventId}`, error) throw error } } private generateEventId(event: DomainEvent): string { return `${event.aggregateId}-${event.eventType}-${event.timestamp.getTime()}` } } Conclusion Key benefits of event-driven architecture and CQRS:\nScalability: Independent scaling through read/write separation Resilience: Fault isolation and recovery capabilities Flexibility: Easy addition of new features Auditability: Complete change history tracking Real-time Processing: Event stream-based reactive systems These patterns are essential for large-scale distributed systems in 2025, especially for services requiring real-time data processing and high availability.\n"},{
  "section": "Blog",
  "slug": "/en/blog/ai-integrated-backend-development/",
  "title": "AI-Integrated Backend Development: Building Intelligent Systems",
  "description": "Learn how to build intelligent backend systems using LLM, RAG, and vector databases with practical implementation patterns and real-world code examples.",
  "date": "January 18, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Artificial Intelligence, Architecture",
  "tags": "AI, LLM, RAG, Vector Database, OpenAI, Machine Learning",
  "content":"AI integration in backend development has become essential, not optional, in 2025. Let\u0026rsquo;s explore how to build intelligent backend systems using LLM, RAG (Retrieval-Augmented Generation), and vector databases with practical code examples.\nAI Backend Architecture Design 1. Microservice-based AI System // AI service abstraction interface AIService { generateText(prompt: string, context?: any): Promise\u0026lt;string\u0026gt; embedText(text: string): Promise\u0026lt;number[]\u0026gt; analyzeImage(imageUrl: string): Promise\u0026lt;any\u0026gt; } class OpenAIService implements AIService { private openai: OpenAI constructor(apiKey: string) { this.openai = new OpenAI({ apiKey }) } async generateText(prompt: string, context?: any): Promise\u0026lt;string\u0026gt; { const response = await this.openai.chat.completions.create({ model: \u0026#34;gpt-4\u0026#34;, messages: [ { role: \u0026#34;system\u0026#34;, content: context?.systemPrompt || \u0026#34;You are a helpful assistant.\u0026#34; }, { role: \u0026#34;user\u0026#34;, content: prompt } ], temperature: 0.7, max_tokens: 2000 }) return response.choices[0].message.content || \u0026#34;\u0026#34; } async embedText(text: string): Promise\u0026lt;number[]\u0026gt; { const response = await this.openai.embeddings.create({ model: \u0026#34;text-embedding-ada-002\u0026#34;, input: text }) return response.data[0].embedding } } 2. RAG System Implementation // RAG pipeline class RAGSystem { private vectorDB: VectorDatabase private aiService: AIService private chunkSize = 1000 private overlapSize = 200 constructor(vectorDB: VectorDatabase, aiService: AIService) { this.vectorDB = vectorDB this.aiService = aiService } // Document indexing async indexDocument(content: string, metadata: any): Promise\u0026lt;void\u0026gt; { const chunks = this.chunkText(content) const embeddings = await Promise.all( chunks.map(chunk =\u0026gt; this.aiService.embedText(chunk)) ) const documents = chunks.map((chunk, index) =\u0026gt; ({ id: `${metadata.id}_chunk_${index}`, content: chunk, embedding: embeddings[index], metadata: { ...metadata, chunkIndex: index, totalChunks: chunks.length } })) await this.vectorDB.upsert(documents) } // Similar document search async searchSimilar(query: string, limit = 5): Promise\u0026lt;any[]\u0026gt; { const queryEmbedding = await this.aiService.embedText(query) const results = await this.vectorDB.search(queryEmbedding, limit) return results.map(result =\u0026gt; ({ content: result.content, similarity: result.score, metadata: result.metadata })) } // RAG-based answer generation async generateAnswer(question: string): Promise\u0026lt;string\u0026gt; { const relevantDocs = await this.searchSimilar(question, 3) const context = relevantDocs .map(doc =\u0026gt; `Document: ${doc.content}`) .join(\u0026#39;\\n\\n\u0026#39;) const prompt = ` Please answer the question based on the following documents: ${context} Question: ${question} Please provide an answer based on the provided documents, making it clear and helpful. ` return await this.aiService.generateText(prompt) } private chunkText(text: string): string[] { const chunks: string[] = [] let start = 0 while (start \u0026lt; text.length) { const end = Math.min(start + this.chunkSize, text.length) chunks.push(text.slice(start, end)) start = end - this.overlapSize } return chunks } } Vector Database Integration 1. Pinecone Integration // Pinecone vector database import { PineconeClient } from \u0026#39;@pinecone-database/pinecone\u0026#39; class PineconeVectorDB implements VectorDatabase { private client: PineconeClient private indexName: string constructor(apiKey: string, environment: string, indexName: string) { this.client = new PineconeClient() this.indexName = indexName this.init(apiKey, environment) } private async init(apiKey: string, environment: string) { await this.client.init({ apiKey, environment }) } async upsert(documents: any[]): Promise\u0026lt;void\u0026gt; { const index = this.client.Index(this.indexName) const vectors = documents.map(doc =\u0026gt; ({ id: doc.id, values: doc.embedding, metadata: { content: doc.content, ...doc.metadata } })) await index.upsert({ upsertRequest: { vectors: vectors } }) } async search(queryVector: number[], topK: number): Promise\u0026lt;any[]\u0026gt; { const index = this.client.Index(this.indexName) const response = await index.query({ queryRequest: { vector: queryVector, topK, includeMetadata: true } }) return response.matches?.map(match =\u0026gt; ({ id: match.id, score: match.score, content: match.metadata?.content, metadata: match.metadata })) || [] } } 2. Chroma DB Usage // Chroma DB local vector database import { ChromaClient } from \u0026#39;chromadb\u0026#39; class ChromaVectorDB implements VectorDatabase { private client: ChromaClient private collection: any constructor(private collectionName: string) { this.client = new ChromaClient() this.initCollection() } private async initCollection() { try { this.collection = await this.client.getCollection({ name: this.collectionName }) } catch { this.collection = await this.client.createCollection({ name: this.collectionName, metadata: { \u0026#34;hnsw:space\u0026#34;: \u0026#34;cosine\u0026#34; } }) } } async upsert(documents: any[]): Promise\u0026lt;void\u0026gt; { await this.collection.upsert({ ids: documents.map(doc =\u0026gt; doc.id), embeddings: documents.map(doc =\u0026gt; doc.embedding), documents: documents.map(doc =\u0026gt; doc.content), metadatas: documents.map(doc =\u0026gt; doc.metadata) }) } async search(queryVector: number[], topK: number): Promise\u0026lt;any[]\u0026gt; { const results = await this.collection.query({ queryEmbeddings: [queryVector], nResults: topK }) return results.ids[0].map((id: string, index: number) =\u0026gt; ({ id, score: 1 - results.distances[0][index], // Convert distance to similarity content: results.documents[0][index], metadata: results.metadatas[0][index] })) } } Real-time AI Feature Implementation 1. Streaming Response // Streaming AI response class StreamingAIService { async generateStreamingResponse(prompt: string): Promise\u0026lt;ReadableStream\u0026gt; { const stream = new ReadableStream({ async start(controller) { try { const response = await fetch(\u0026#39;https://api.openai.com/v1/chat/completions\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${process.env.OPENAI_API_KEY}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ model: \u0026#39;gpt-4\u0026#39;, messages: [{ role: \u0026#39;user\u0026#39;, content: prompt }], stream: true }) }) const reader = response.body?.getReader() if (!reader) throw new Error(\u0026#39;Failed to get stream reader\u0026#39;) while (true) { const { done, value } = await reader.read() if (done) break // Parse SSE format const chunk = new TextDecoder().decode(value) const lines = chunk.split(\u0026#39;\\n\u0026#39;).filter(line =\u0026gt; line.trim()) for (const line of lines) { if (line.startsWith(\u0026#39;data: \u0026#39;)) { const data = line.slice(6) if (data === \u0026#39;[DONE]\u0026#39;) { controller.close() return } try { const parsed = JSON.parse(data) const content = parsed.choices[0]?.delta?.content if (content) { controller.enqueue(new TextEncoder().encode(content)) } } catch (e) { // Ignore JSON parsing errors } } } } } catch (error) { controller.error(error) } } }) return stream } } 2. Function Calling // AI function calling system interface AIFunction { name: string description: string parameters: any execute: (args: any) =\u0026gt; Promise\u0026lt;any\u0026gt; } class FunctionCallingService { private functions = new Map\u0026lt;string, AIFunction\u0026gt;() registerFunction(func: AIFunction) { this.functions.set(func.name, func) } async processWithFunctions(prompt: string): Promise\u0026lt;any\u0026gt; { const functionSchemas = Array.from(this.functions.values()).map(func =\u0026gt; ({ name: func.name, description: func.description, parameters: func.parameters })) const response = await this.openai.chat.completions.create({ model: \u0026#34;gpt-4\u0026#34;, messages: [{ role: \u0026#34;user\u0026#34;, content: prompt }], functions: functionSchemas, function_call: \u0026#34;auto\u0026#34; }) const message = response.choices[0].message if (message.function_call) { const functionName = message.function_call.name const functionArgs = JSON.parse(message.function_call.arguments) const func = this.functions.get(functionName) if (func) { const result = await func.execute(functionArgs) // Send function result back to AI const followUpResponse = await this.openai.chat.completions.create({ model: \u0026#34;gpt-4\u0026#34;, messages: [ { role: \u0026#34;user\u0026#34;, content: prompt }, { role: \u0026#34;assistant\u0026#34;, content: null, function_call: message.function_call }, { role: \u0026#34;function\u0026#34;, name: functionName, content: JSON.stringify(result) } ] }) return followUpResponse.choices[0].message.content } } return message.content } } // Usage example const functionService = new FunctionCallingService() functionService.registerFunction({ name: \u0026#34;get_weather\u0026#34;, description: \u0026#34;Get current weather information for a location\u0026#34;, parameters: { type: \u0026#34;object\u0026#34;, properties: { location: { type: \u0026#34;string\u0026#34;, description: \u0026#34;The city and state, e.g. San Francisco, CA\u0026#34; } }, required: [\u0026#34;location\u0026#34;] }, execute: async (args) =\u0026gt; { // Actual weather API call const weather = await fetchWeatherData(args.location) return { temperature: weather.temp, description: weather.description } } }) Performance Optimization and Cost Management 1. Caching Strategy // AI response caching class AIResponseCache { private cache = new Map\u0026lt;string, any\u0026gt;() private readonly maxSize = 1000 private readonly ttl = 3600000 // 1 hour private generateKey(prompt: string, context?: any): string { const hash = createHash(\u0026#39;sha256\u0026#39;) hash.update(JSON.stringify({ prompt, context })) return hash.digest(\u0026#39;hex\u0026#39;) } async get(prompt: string, context?: any): Promise\u0026lt;string | null\u0026gt; { const key = this.generateKey(prompt, context) const cached = this.cache.get(key) if (cached \u0026amp;\u0026amp; Date.now() - cached.timestamp \u0026lt; this.ttl) { return cached.response } return null } async set(prompt: string, response: string, context?: any): Promise\u0026lt;void\u0026gt; { const key = this.generateKey(prompt, context) if (this.cache.size \u0026gt;= this.maxSize) { const firstKey = this.cache.keys().next().value this.cache.delete(firstKey) } this.cache.set(key, { response, timestamp: Date.now() }) } } 2. Cost Monitoring // AI usage tracking class AIUsageTracker { private usage = { totalTokens: 0, totalCost: 0, requestCount: 0 } private readonly tokenPrices = { \u0026#39;gpt-4\u0026#39;: { input: 0.03, output: 0.06 }, // per 1K tokens \u0026#39;gpt-3.5-turbo\u0026#39;: { input: 0.0015, output: 0.002 } } trackUsage(model: string, inputTokens: number, outputTokens: number) { const prices = this.tokenPrices[model] if (!prices) return const cost = (inputTokens / 1000 * prices.input) + (outputTokens / 1000 * prices.output) this.usage.totalTokens += inputTokens + outputTokens this.usage.totalCost += cost this.usage.requestCount += 1 // Cost threshold check if (this.usage.totalCost \u0026gt; 100) { // $100 threshold this.sendCostAlert() } } private async sendCostAlert() { // Alert sending logic console.warn(`AI usage cost exceeded $100: $${this.usage.totalCost.toFixed(2)}`) } getUsageStats() { return { ...this.usage } } } Security and Ethical Considerations 1. Content Filtering // Harmful content filtering class ContentModerator { private openai: OpenAI async moderateContent(text: string): Promise\u0026lt;boolean\u0026gt; { try { const response = await this.openai.moderations.create({ input: text }) const result = response.results[0] return !result.flagged // true means safe content } catch (error) { console.error(\u0026#39;Content moderation failed:\u0026#39;, error) return false // Assume unsafe on error } } async filterAndGenerate(prompt: string): Promise\u0026lt;string\u0026gt; { const isSafe = await this.moderateContent(prompt) if (!isSafe) { throw new Error(\u0026#39;Content violates usage policies\u0026#39;) } const response = await this.generateResponse(prompt) const responseIsSafe = await this.moderateContent(response) if (!responseIsSafe) { return \u0026#34;I\u0026#39;m sorry, I cannot generate an appropriate response.\u0026#34; } return response } } Conclusion Key points for AI-integrated backend development:\nRAG Systems: Accurate and contextual AI responses Vector Databases: Efficient similarity search Streaming: Real-time user experience Function Calling: AI and backend system integration Cost Optimization: Caching and usage monitoring Security: Content filtering and data protection In 2025, every backend system will include some form of AI functionality. Building AI integration experience now is crucial for staying competitive.\n"},{
  "section": "Blog",
  "slug": "/en/blog/serverless-edge-computing-backend/",
  "title": "Serverless Backend with Edge Computing: Next-Gen Architecture",
  "description": "Explore next-generation backend architecture patterns combining serverless functions with edge computing for ultra-low latency and global scale.",
  "date": "January 18, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Architecture, DevOps",
  "tags": "Serverless, Edge Computing, Vercel, Cloudflare Workers, AWS Lambda",
  "content":"The hottest backend development trend of 2025 is the convergence of serverless and edge computing. Learn how to minimize latency and maximize scalability with serverless functions running on globally distributed edge networks.\nWhy Edge Computing Matters 1. Minimizing Latency // Cloudflare Workers Example export default { async fetch(request: Request, env: Env): Promise\u0026lt;Response\u0026gt; { const { searchParams } = new URL(request.url) const userId = searchParams.get(\u0026#39;userId\u0026#39;) // Check edge cache first const cacheKey = `user:${userId}` const cached = await env.KV.get(cacheKey) if (cached) { return new Response(cached, { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }) } // Fetch from backend const userData = await fetchUserData(userId) // Store in edge cache (TTL: 5 minutes) await env.KV.put(cacheKey, JSON.stringify(userData), { expirationTtl: 300 }) return Response.json(userData) } } 2. Global Distributed Processing // Regional data processing interface RegionConfig { database: string cache: string storage: string } const getRegionConfig = (country: string): RegionConfig =\u0026gt; { const regionMap = { \u0026#39;US\u0026#39;: { database: \u0026#39;us-east-1\u0026#39;, cache: \u0026#39;us-cache\u0026#39;, storage: \u0026#39;us-s3\u0026#39; }, \u0026#39;EU\u0026#39;: { database: \u0026#39;eu-west-1\u0026#39;, cache: \u0026#39;eu-cache\u0026#39;, storage: \u0026#39;eu-s3\u0026#39; }, \u0026#39;ASIA\u0026#39;: { database: \u0026#39;ap-northeast-1\u0026#39;, cache: \u0026#39;asia-cache\u0026#39;, storage: \u0026#39;asia-s3\u0026#39; } } // IP-based region detection const region = detectRegion(country) return regionMap[region] || regionMap[\u0026#39;US\u0026#39;] } export const handleRequest = async (request: Request) =\u0026gt; { const country = request.headers.get(\u0026#39;cf-ipcountry\u0026#39;) || \u0026#39;US\u0026#39; const config = getRegionConfig(country) // Connect to region-optimized database const db = await connectToDatabase(config.database) const result = await db.query(\u0026#39;SELECT * FROM users WHERE active = true\u0026#39;) return Response.json(result) } Platform Comparison 1. Vercel Edge Functions // Next.js Edge API Route import { NextRequest, NextResponse } from \u0026#39;next/server\u0026#39; export const config = { runtime: \u0026#39;edge\u0026#39; } export default async function handler(req: NextRequest) { const { geo, ip } = req // Geographic location-based personalization const recommendations = await getRecommendations({ country: geo?.country, city: geo?.city, userIp: ip }) return NextResponse.json({ recommendations, location: { country: geo?.country, city: geo?.city, region: geo?.region } }) } 2. AWS Lambda@Edge // CloudFront Lambda@Edge exports.handler = async (event) =\u0026gt; { const request = event.Records[0].cf.request const headers = request.headers // A/B testing logic const testGroup = Math.random() \u0026lt; 0.5 ? \u0026#39;A\u0026#39; : \u0026#39;B\u0026#39; // Cookie setting const response = { status: \u0026#39;200\u0026#39;, statusDescription: \u0026#39;OK\u0026#39;, headers: { \u0026#39;set-cookie\u0026#39;: [{ key: \u0026#39;Set-Cookie\u0026#39;, value: `test-group=${testGroup}; Path=/; HttpOnly; Secure` }], \u0026#39;cache-control\u0026#39;: [{ key: \u0026#39;Cache-Control\u0026#39;, value: \u0026#39;max-age=300\u0026#39; }] }, body: JSON.stringify({ testGroup, timestamp: Date.now() }) } return response } 3. Deno Deploy // Deno Deploy Edge Function import { serve } from \u0026#34;https://deno.land/std@0.168.0/http/server.ts\u0026#34; const kv = await Deno.openKv() serve(async (req) =\u0026gt; { const url = new URL(req.url) const path = url.pathname if (path === \u0026#34;/api/analytics\u0026#34;) { // Real-time analytics data collection const event = await req.json() const key = [\u0026#34;analytics\u0026#34;, Date.now(), crypto.randomUUID()] await kv.set(key, { ...event, timestamp: Date.now(), userAgent: req.headers.get(\u0026#34;user-agent\u0026#34;), ip: req.headers.get(\u0026#34;x-forwarded-for\u0026#34;) }) return new Response(\u0026#34;OK\u0026#34;, { status: 200 }) } return new Response(\u0026#34;Not Found\u0026#34;, { status: 404 }) }) Real-time Data Processing Patterns 1. Stream Processing // Real-time data stream processing class EdgeStreamProcessor { private buffer: any[] = [] private readonly batchSize = 100 private readonly flushInterval = 5000 // 5 seconds constructor(private outputHandler: (batch: any[]) =\u0026gt; Promise\u0026lt;void\u0026gt;) { setInterval(() =\u0026gt; this.flush(), this.flushInterval) } async process(data: any) { this.buffer.push({ ...data, processedAt: Date.now(), edgeLocation: Deno.env.get(\u0026#39;DENO_REGION\u0026#39;) || \u0026#39;unknown\u0026#39; }) if (this.buffer.length \u0026gt;= this.batchSize) { await this.flush() } } private async flush() { if (this.buffer.length === 0) return const batch = this.buffer.splice(0, this.batchSize) try { await this.outputHandler(batch) } catch (error) { console.error(\u0026#39;Failed to process batch:\u0026#39;, error) // Re-add failed batch to buffer (retry logic) this.buffer.unshift(...batch) } } } 2. Caching Strategy // Multi-tier cache system class EdgeCacheManager { private memoryCache = new Map\u0026lt;string, any\u0026gt;() private readonly maxMemoryItems = 1000 async get(key: string): Promise\u0026lt;any\u0026gt; { // L1: Memory cache if (this.memoryCache.has(key)) { return this.memoryCache.get(key) } // L2: Edge KV store const edgeCached = await this.edgeKV.get(key) if (edgeCached) { this.setMemoryCache(key, edgeCached) return edgeCached } // L3: Central database const dbResult = await this.database.query(key) if (dbResult) { await this.edgeKV.put(key, dbResult, { ttl: 300 }) this.setMemoryCache(key, dbResult) } return dbResult } private setMemoryCache(key: string, value: any) { if (this.memoryCache.size \u0026gt;= this.maxMemoryItems) { const firstKey = this.memoryCache.keys().next().value this.memoryCache.delete(firstKey) } this.memoryCache.set(key, value) } } Monitoring and Observability 1. Distributed Tracing // OpenTelemetry edge tracing import { trace } from \u0026#39;@opentelemetry/api\u0026#39; const tracer = trace.getTracer(\u0026#39;edge-function\u0026#39;) export async function handleRequest(request: Request) { const span = tracer.startSpan(\u0026#39;edge-request-handler\u0026#39;) try { span.setAttributes({ \u0026#39;request.method\u0026#39;: request.method, \u0026#39;request.url\u0026#39;: request.url, \u0026#39;edge.region\u0026#39;: Deno.env.get(\u0026#39;DENO_REGION\u0026#39;) }) const childSpan = tracer.startSpan(\u0026#39;database-query\u0026#39;, { parent: span }) const result = await performDatabaseQuery() childSpan.end() span.setStatus({ code: 1 }) // OK return Response.json(result) } catch (error) { span.recordException(error) span.setStatus({ code: 2, message: error.message }) // ERROR throw error } finally { span.end() } } 2. Metrics Collection // Custom metrics collection class EdgeMetrics { private static instance: EdgeMetrics private metrics = new Map\u0026lt;string, number\u0026gt;() static getInstance(): EdgeMetrics { if (!EdgeMetrics.instance) { EdgeMetrics.instance = new EdgeMetrics() } return EdgeMetrics.instance } increment(metric: string, value = 1) { const current = this.metrics.get(metric) || 0 this.metrics.set(metric, current + value) } async flush() { const timestamp = Date.now() const payload = { timestamp, region: Deno.env.get(\u0026#39;DENO_REGION\u0026#39;), metrics: Object.fromEntries(this.metrics) } // Send metrics await fetch(\u0026#39;https://metrics-collector.example.com/edge\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: JSON.stringify(payload) }) this.metrics.clear() } } Security Considerations 1. Edge Authentication // JWT verification (edge optimized) import { verify } from \u0026#39;https://deno.land/x/djwt@v2.8/mod.ts\u0026#39; async function validateToken(token: string): Promise\u0026lt;boolean\u0026gt; { try { const key = await crypto.subtle.importKey( \u0026#39;raw\u0026#39;, new TextEncoder().encode(Deno.env.get(\u0026#39;JWT_SECRET\u0026#39;)), { name: \u0026#39;HMAC\u0026#39;, hash: \u0026#39;SHA-256\u0026#39; }, false, [\u0026#39;verify\u0026#39;] ) const payload = await verify(token, key) return payload.exp \u0026gt; Date.now() / 1000 } catch { return false } } Conclusion Serverless edge computing is the core paradigm of backend development in 2025. Key benefits include:\nUltra-low latency: Execution at the closest edge to users Auto-scaling: Automatic scaling based on traffic Global distribution: Simultaneous worldwide service capability Cost efficiency: Pay-per-use pricing model More backend workloads will migrate to the edge, making edge-ready architecture design and development experience crucial competitive advantages.\n"},{
  "section": "Blog",
  "slug": "/en/blog/kotlin-multiplatform-backend-integration/",
  "title": "Kotlin Multiplatform and Backend Development: 2025 Trends",
  "description": "Discover how to maximize development efficiency by integrating Kotlin Multiplatform Mobile (KMM) with backend systems.",
  "date": "January 15, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Architecture",
  "tags": "Kotlin, Multiplatform, KMM, Backend, Mobile",
  "content":"One of the backend development trends in 2025 is full-stack development using Kotlin Multiplatform. Let\u0026rsquo;s explore how to develop from mobile to backend using a single language by combining KMM (Kotlin Multiplatform Mobile) and Ktor.\nAdvantages of Kotlin Multiplatform 1. Code Sharing and Reusability // Common data model @Serializable data class User( val id: String, val email: String, val name: String, val createdAt: Instant ) // Common business logic class UserValidator { fun validateEmail(email: String): Boolean { return email.contains(\u0026#34;@\u0026#34;) \u0026amp;\u0026amp; email.length \u0026gt; 5 } fun validateName(name: String): Boolean { return name.isNotBlank() \u0026amp;\u0026amp; name.length \u0026gt;= 2 } } 2. Backend API Development (Ktor) // Ktor backend server fun Application.configureRouting() { routing { route(\u0026#34;/api/users\u0026#34;) { post { val user = call.receive\u0026lt;User\u0026gt;() val validator = UserValidator() if (!validator.validateEmail(user.email)) { call.respond(HttpStatusCode.BadRequest, \u0026#34;Invalid email\u0026#34;) return@post } // User save logic val savedUser = userService.save(user) call.respond(HttpStatusCode.Created, savedUser) } get(\u0026#34;/{id}\u0026#34;) { val id = call.parameters[\u0026#34;id\u0026#34;] ?: \u0026#34;\u0026#34; val user = userService.findById(id) call.respond(user ?: HttpStatusCode.NotFound) } } } } 3. Mobile Client Integration // Common network client class ApiClient { private val httpClient = HttpClient { install(ContentNegotiation) { json() } install(Logging) { level = LogLevel.ALL } } suspend fun createUser(user: User): Result\u0026lt;User\u0026gt; { return try { val response = httpClient.post(\u0026#34;${baseUrl}/api/users\u0026#34;) { contentType(ContentType.Application.Json) setBody(user) } Result.success(response.body\u0026lt;User\u0026gt;()) } catch (e: Exception) { Result.failure(e) } } } Real Project Structure kotlin-multiplatform-project/ ‚îú‚îÄ‚îÄ shared/ ‚îÇ ‚îú‚îÄ‚îÄ src/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ commonMain/kotlin/ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ models/ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ network/ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validators/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ androidMain/kotlin/ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ iosMain/kotlin/ ‚îú‚îÄ‚îÄ backend/ ‚îÇ ‚îú‚îÄ‚îÄ src/main/kotlin/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Application.kt ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ plugins/ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ routes/ ‚îú‚îÄ‚îÄ androidApp/ ‚îî‚îÄ‚îÄ iosApp/ Performance Optimization Tips 1. Common Module Optimization // Platform-specific implementation expect class DatabaseDriver actual class DatabaseDriver { // Android SQLite implementation } // iOS Core Data implementation actual class DatabaseDriver { // iOS Core Data implementation } 2. Network Optimization class NetworkConfig { companion object { const val CONNECT_TIMEOUT = 30_000L const val REQUEST_TIMEOUT = 60_000L const val SOCKET_TIMEOUT = 60_000L } } val httpClient = HttpClient { install(HttpTimeout) { connectTimeoutMillis = NetworkConfig.CONNECT_TIMEOUT requestTimeoutMillis = NetworkConfig.REQUEST_TIMEOUT socketTimeoutMillis = NetworkConfig.SOCKET_TIMEOUT } } Deployment Strategy Docker Containerization FROM openjdk:17-jdk-slim WORKDIR /app COPY backend/build/libs/backend-all.jar app.jar EXPOSE 8080 CMD [\u0026#34;java\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;app.jar\u0026#34;] CI/CD Pipeline name: Kotlin Multiplatform CI on: [push, pull_request] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-java@v3 with: java-version: \u0026#39;17\u0026#39; - run: ./gradlew test - run: ./gradlew backend:buildFatJar Conclusion Kotlin Multiplatform will be a game-changer for backend development in 2025. Being able to cover both mobile and backend with a single language can simultaneously improve development efficiency and code quality.\nKey Benefits:\nImproved Development Efficiency: One language, one toolchain Code Reusability: Sharing models, utilities, and business logic Type Safety: Compile-time error detection Performance: Native performance delivery More companies are expected to adopt Kotlin Multiplatform in the future, making it worthwhile for backend developers to learn.\n"},{
  "section": "Blog",
  "slug": "/en/blog/rest-api-design/",
  "title": "REST API Design Best Practices",
  "description": "Learn core principles and practical guides for designing scalable and maintainable REST APIs.",
  "date": "April 7, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, API",
  "tags": "REST API, API Design, Backend, Web Development",
  "content":"Well-designed REST APIs improve developer experience and ensure system scalability. Let\u0026rsquo;s explore REST API design principles and best practices that can be applied in real projects, along with Spring Boot examples.\nREST API Design Principles 1. Resource-Centered URL Design // ‚ùå Bad example - using verbs @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class BadUserController { @PostMapping(\u0026#34;/createUser\u0026#34;) public User createUser(@RequestBody CreateUserRequest request) { ... } @PostMapping(\u0026#34;/deleteUser/{id}\u0026#34;) public void deleteUser(@PathVariable Long id) { ... } @GetMapping(\u0026#34;/getUsersByStatus/{status}\u0026#34;) public List\u0026lt;User\u0026gt; getUsersByStatus(@PathVariable String status) { ... } } // ‚úÖ Good example - using nouns, HTTP methods express actions @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) @Validated @Slf4j public class UserController { private final UserService userService; @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity\u0026lt;UserResponse\u0026gt; createUser( @Valid @RequestBody CreateUserRequest request) { User user = userService.createUser(request); UserResponse response = UserResponse.from(user); URI location = ServletUriComponentsBuilder .fromCurrentRequest() .path(\u0026#34;/{id}\u0026#34;) .buildAndExpand(user.getId()) .toUri(); return ResponseEntity.created(location).body(response); } @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserResponse\u0026gt; getUser(@PathVariable Long id) { User user = userService.findById(id); return ResponseEntity.ok(UserResponse.from(user)); } @GetMapping public ResponseEntity\u0026lt;PagedResponse\u0026lt;UserResponse\u0026gt;\u0026gt; getUsers( @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;20\u0026#34;) int size, @RequestParam(required = false) String status, @RequestParam(defaultValue = \u0026#34;createdAt\u0026#34;) String sortBy, @RequestParam(defaultValue = \u0026#34;desc\u0026#34;) String sortDir) { UserSearchCriteria criteria = UserSearchCriteria.builder() .status(status) .page(page) .size(size) .sortBy(sortBy) .sortDirection(sortDir) .build(); Page\u0026lt;User\u0026gt; users = userService.findUsers(criteria); PagedResponse\u0026lt;UserResponse\u0026gt; response = PagedResponse.of( users.map(UserResponse::from) ); return ResponseEntity.ok(response); } @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserResponse\u0026gt; updateUser( @PathVariable Long id, @Valid @RequestBody UpdateUserRequest request) { User user = userService.updateUser(id, request); return ResponseEntity.ok(UserResponse.from(user)); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.NO_CONTENT) public ResponseEntity\u0026lt;Void\u0026gt; deleteUser(@PathVariable Long id) { userService.deleteUser(id); return ResponseEntity.noContent().build(); } } 2. Nested Resource Design @RestController @RequestMapping(\u0026#34;/api/users/{userId}/posts\u0026#34;) public class UserPostController { private final PostService postService; @GetMapping public ResponseEntity\u0026lt;PagedResponse\u0026lt;PostResponse\u0026gt;\u0026gt; getUserPosts( @PathVariable Long userId, @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) int size) { Page\u0026lt;Post\u0026gt; posts = postService.findByUserId(userId, PageRequest.of(page, size, Sort.by(\u0026#34;createdAt\u0026#34;).descending())); PagedResponse\u0026lt;PostResponse\u0026gt; response = PagedResponse.of( posts.map(PostResponse::from) ); return ResponseEntity.ok(response); } @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity\u0026lt;PostResponse\u0026gt; createPost( @PathVariable Long userId, @Valid @RequestBody CreatePostRequest request) { Post post = postService.createPost(userId, request); PostResponse response = PostResponse.from(post); URI location = ServletUriComponentsBuilder .fromCurrentRequest() .path(\u0026#34;/{postId}\u0026#34;) .buildAndExpand(post.getId()) .toUri(); return ResponseEntity.created(location).body(response); } } Request/Response DTO Design Request DTOs @Data @Builder @NoArgsConstructor @AllArgsConstructor public class CreateUserRequest { @NotBlank(message = \u0026#34;Email is required\u0026#34;) @Email(message = \u0026#34;Invalid email format\u0026#34;) @Size(max = 100, message = \u0026#34;Email cannot exceed 100 characters\u0026#34;) private String email; @NotBlank(message = \u0026#34;Name is required\u0026#34;) @Size(min = 2, max = 50, message = \u0026#34;Name must be between 2 and 50 characters\u0026#34;) private String name; @Size(max = 500, message = \u0026#34;Bio cannot exceed 500 characters\u0026#34;) private String bio; @Valid private CreateAddressRequest address; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) @Past(message = \u0026#34;Birth date must be in the past\u0026#34;) private LocalDate birthDate; } @Data @Builder @NoArgsConstructor @AllArgsConstructor public class UpdateUserRequest { @Size(min = 2, max = 50, message = \u0026#34;Name must be between 2 and 50 characters\u0026#34;) private String name; @Size(max = 500, message = \u0026#34;Bio cannot exceed 500 characters\u0026#34;) private String bio; @Valid private UpdateAddressRequest address; } Response DTOs @Data @Builder @NoArgsConstructor @AllArgsConstructor public class UserResponse { private Long id; private String email; private String name; private String bio; private AddressResponse address; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate birthDate; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss\u0026#34;) private LocalDateTime createdAt; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss\u0026#34;) private LocalDateTime updatedAt; // Related resource links private Map\u0026lt;String, String\u0026gt; links; public static UserResponse from(User user) { UserResponseBuilder builder = UserResponse.builder() .id(user.getId()) .email(user.getEmail()) .name(user.getName()) .bio(user.getBio()) .birthDate(user.getBirthDate()) .createdAt(user.getCreatedAt()) .updatedAt(user.getUpdatedAt()); if (user.getAddress() != null) { builder.address(AddressResponse.from(user.getAddress())); } // Add HATEOAS links Map\u0026lt;String, String\u0026gt; links = new HashMap\u0026lt;\u0026gt;(); links.put(\u0026#34;self\u0026#34;, \u0026#34;/api/users/\u0026#34; + user.getId()); links.put(\u0026#34;posts\u0026#34;, \u0026#34;/api/users/\u0026#34; + user.getId() + \u0026#34;/posts\u0026#34;); links.put(\u0026#34;profile\u0026#34;, \u0026#34;/api/users/\u0026#34; + user.getId() + \u0026#34;/profile\u0026#34;); builder.links(links); return builder.build(); } } Paginated Response @Data @Builder @NoArgsConstructor @AllArgsConstructor public class PagedResponse\u0026lt;T\u0026gt; { private List\u0026lt;T\u0026gt; content; private PageInfo page; private Map\u0026lt;String, String\u0026gt; links; @Data @Builder @NoArgsConstructor @AllArgsConstructor public static class PageInfo { private int number; private int size; private long totalElements; private int totalPages; private boolean first; private boolean last; private boolean hasNext; private boolean hasPrevious; } public static \u0026lt;T\u0026gt; PagedResponse\u0026lt;T\u0026gt; of(Page\u0026lt;T\u0026gt; page) { PageInfo pageInfo = PageInfo.builder() .number(page.getNumber()) .size(page.getSize()) .totalElements(page.getTotalElements()) .totalPages(page.getTotalPages()) .first(page.isFirst()) .last(page.isLast()) .hasNext(page.hasNext()) .hasPrevious(page.hasPrevious()) .build(); // Generate pagination links Map\u0026lt;String, String\u0026gt; links = createPaginationLinks(page); return PagedResponse.\u0026lt;T\u0026gt;builder() .content(page.getContent()) .page(pageInfo) .links(links) .build(); } private static Map\u0026lt;String, String\u0026gt; createPaginationLinks(Page\u0026lt;?\u0026gt; page) { Map\u0026lt;String, String\u0026gt; links = new HashMap\u0026lt;\u0026gt;(); String baseUrl = ServletUriComponentsBuilder.fromCurrentRequest() .replaceQueryParam(\u0026#34;page\u0026#34;, \u0026#34;{page}\u0026#34;) .toUriString(); links.put(\u0026#34;self\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, String.valueOf(page.getNumber()))); if (page.hasNext()) { links.put(\u0026#34;next\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, String.valueOf(page.getNumber() + 1))); } if (page.hasPrevious()) { links.put(\u0026#34;prev\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, String.valueOf(page.getNumber() - 1))); } links.put(\u0026#34;first\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, \u0026#34;0\u0026#34;)); links.put(\u0026#34;last\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, String.valueOf(page.getTotalPages() - 1))); return links; } } Error Handling Standard Error Response @Data @Builder @NoArgsConstructor @AllArgsConstructor public class ErrorResponse { private String error; private String message; private int status; private String path; private LocalDateTime timestamp; private List\u0026lt;FieldError\u0026gt; fieldErrors; private String correlationId; @Data @Builder @NoArgsConstructor @AllArgsConstructor public static class FieldError { private String field; private Object rejectedValue; private String message; } } @RestControllerAdvice @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public ErrorResponse handleValidationException( MethodArgumentNotValidException ex, HttpServletRequest request) { List\u0026lt;ErrorResponse.FieldError\u0026gt; fieldErrors = ex.getBindingResult() .getFieldErrors() .stream() .map(error -\u0026gt; ErrorResponse.FieldError.builder() .field(error.getField()) .rejectedValue(error.getRejectedValue()) .message(error.getDefaultMessage()) .build()) .collect(Collectors.toList()); String correlationId = request.getHeader(\u0026#34;X-Correlation-ID\u0026#34;); return ErrorResponse.builder() .error(\u0026#34;VALIDATION_FAILED\u0026#34;) .message(\u0026#34;Input validation failed\u0026#34;) .status(HttpStatus.BAD_REQUEST.value()) .path(request.getRequestURI()) .timestamp(LocalDateTime.now()) .fieldErrors(fieldErrors) .correlationId(correlationId) .build(); } @ExceptionHandler(EntityNotFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ErrorResponse handleEntityNotFoundException( EntityNotFoundException ex, HttpServletRequest request) { return ErrorResponse.builder() .error(\u0026#34;RESOURCE_NOT_FOUND\u0026#34;) .message(ex.getMessage()) .status(HttpStatus.NOT_FOUND.value()) .path(request.getRequestURI()) .timestamp(LocalDateTime.now()) .correlationId(request.getHeader(\u0026#34;X-Correlation-ID\u0026#34;)) .build(); } @ExceptionHandler(DataIntegrityViolationException.class) @ResponseStatus(HttpStatus.CONFLICT) public ErrorResponse handleDataIntegrityViolation( DataIntegrityViolationException ex, HttpServletRequest request) { String message = \u0026#34;Data integrity constraint violation\u0026#34;; if (ex.getMessage().contains(\u0026#34;email\u0026#34;)) { message = \u0026#34;Email already exists\u0026#34;; } return ErrorResponse.builder() .error(\u0026#34;DATA_INTEGRITY_VIOLATION\u0026#34;) .message(message) .status(HttpStatus.CONFLICT.value()) .path(request.getRequestURI()) .timestamp(LocalDateTime.now()) .correlationId(request.getHeader(\u0026#34;X-Correlation-ID\u0026#34;)) .build(); } } API Versioning URL-based Versioning @RestController @RequestMapping(\u0026#34;/api/v1/users\u0026#34;) public class UserV1Controller { @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserV1Response\u0026gt; getUser(@PathVariable Long id) { // v1 implementation } } @RestController @RequestMapping(\u0026#34;/api/v2/users\u0026#34;) public class UserV2Controller { @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserV2Response\u0026gt; getUser(@PathVariable Long id) { // v2 implementation - new fields added } } Header-based Versioning @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @GetMapping(value = \u0026#34;/{id}\u0026#34;, headers = \u0026#34;API-Version=v1\u0026#34;) public ResponseEntity\u0026lt;UserV1Response\u0026gt; getUserV1(@PathVariable Long id) { // v1 implementation } @GetMapping(value = \u0026#34;/{id}\u0026#34;, headers = \u0026#34;API-Version=v2\u0026#34;) public ResponseEntity\u0026lt;UserV2Response\u0026gt; getUserV2(@PathVariable Long id) { // v2 implementation } } API Documentation OpenAPI 3.0 Configuration @Configuration @OpenAPIDefinition( info = @Info( title = \u0026#34;User Management API\u0026#34;, version = \u0026#34;v1.0.0\u0026#34;, description = \u0026#34;REST API providing user registration, lookup, update, and delete functionality\u0026#34;, contact = @Contact( name = \u0026#34;Kigo\u0026#34;, email = \u0026#34;support@kigo.dev\u0026#34;, url = \u0026#34;https://kigo.dev\u0026#34; ), license = @License( name = \u0026#34;MIT License\u0026#34;, url = \u0026#34;https://opensource.org/licenses/MIT\u0026#34; ) ), servers = { @Server(url = \u0026#34;https://api.kigo.dev\u0026#34;, description = \u0026#34;Production server\u0026#34;), @Server(url = \u0026#34;https://staging-api.kigo.dev\u0026#34;, description = \u0026#34;Staging server\u0026#34;), @Server(url = \u0026#34;http://localhost:8080\u0026#34;, description = \u0026#34;Local development server\u0026#34;) } ) public class OpenApiConfig { @Bean public OpenAPI customOpenAPI() { return new OpenAPI() .components(new Components() .addSecuritySchemes(\u0026#34;bearer-jwt\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.HTTP) .scheme(\u0026#34;bearer\u0026#34;) .bearerFormat(\u0026#34;JWT\u0026#34;) .description(\u0026#34;Enter JWT token\u0026#34;))) .addSecurityItem(new SecurityRequirement().addList(\u0026#34;bearer-jwt\u0026#34;)); } } @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) @Tag(name = \u0026#34;User Management\u0026#34;, description = \u0026#34;APIs for user CRUD operations\u0026#34;) public class UserController { @Operation( summary = \u0026#34;Create user\u0026#34;, description = \u0026#34;Creates a new user.\u0026#34;, responses = { @ApiResponse( responseCode = \u0026#34;201\u0026#34;, description = \u0026#34;User created successfully\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UserResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;Bad request\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = ErrorResponse.class) ) ) } ) @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity\u0026lt;UserResponse\u0026gt; createUser( @Valid @RequestBody @Parameter(description = \u0026#34;User creation request information\u0026#34;, required = true) CreateUserRequest request) { // Implementation } @Operation( summary = \u0026#34;Get user list\u0026#34;, description = \u0026#34;Retrieves user list with pagination and filtering applied.\u0026#34; ) @GetMapping public ResponseEntity\u0026lt;PagedResponse\u0026lt;UserResponse\u0026gt;\u0026gt; getUsers( @Parameter(description = \u0026#34;Page number (starts from 0)\u0026#34;, example = \u0026#34;0\u0026#34;) @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @Parameter(description = \u0026#34;Page size\u0026#34;, example = \u0026#34;20\u0026#34;) @RequestParam(defaultValue = \u0026#34;20\u0026#34;) int size, @Parameter(description = \u0026#34;User status filter\u0026#34;, example = \u0026#34;ACTIVE\u0026#34;) @RequestParam(required = false) String status) { // Implementation } } Performance Optimization Caching Strategy @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @GetMapping(\u0026#34;/{id}\u0026#34;) @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public ResponseEntity\u0026lt;UserResponse\u0026gt; getUser(@PathVariable Long id) { User user = userService.findById(id); return ResponseEntity .ok() .cacheControl(CacheControl.maxAge(5, TimeUnit.MINUTES)) .eTag(String.valueOf(user.getVersion())) .body(UserResponse.from(user)); } @PutMapping(\u0026#34;/{id}\u0026#34;) @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public ResponseEntity\u0026lt;UserResponse\u0026gt; updateUser( @PathVariable Long id, @RequestHeader(value = \u0026#34;If-Match\u0026#34;, required = false) String ifMatch, @Valid @RequestBody UpdateUserRequest request) { // Optimistic locking check if (ifMatch != null) { User currentUser = userService.findById(id); if (!ifMatch.equals(String.valueOf(currentUser.getVersion()))) { return ResponseEntity.status(HttpStatus.PRECONDITION_FAILED).build(); } } User user = userService.updateUser(id, request); return ResponseEntity .ok() .eTag(String.valueOf(user.getVersion())) .body(UserResponse.from(user)); } } Compression Configuration # application.yml server: compression: enabled: true mime-types: - application/json - application/xml - text/html - text/xml - text/plain min-response-size: 1024 Security Configuration CORS Configuration @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/api/**\u0026#34;) .allowedOriginPatterns(\u0026#34;https://*.kigo.dev\u0026#34;, \u0026#34;http://localhost:*\u0026#34;) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;PATCH\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .allowCredentials(true) .maxAge(3600); } } Through these best practices, you can build developer-friendly and scalable REST APIs. Apply consistent design principles and proper documentation to improve API quality and usability.\n"},{
  "section": "Blog",
  "slug": "/en/blog/microservices-architecture/",
  "title": "Microservices Architecture with Spring Boot",
  "description": "Learn how to build scalable microservices architecture using Spring Boot and Spring Cloud framework.",
  "date": "April 6, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Architecture",
  "tags": "Spring Boot, Microservices, Spring Cloud, Architecture",
  "content":"To overcome the limitations of monolithic applications and build scalable and flexible systems, microservices architecture is gaining attention. Let\u0026rsquo;s explore how to build microservices that can be used in actual production environments using the Spring Boot and Spring Cloud ecosystem.\nMicroservices Architecture Overview Service Decomposition Strategy # Example of domain-based service separation services: user-service: responsibility: \u0026#34;User management, authentication\u0026#34; database: \u0026#34;user_db\u0026#34; port: 8081 product-service: responsibility: \u0026#34;Product management, catalog\u0026#34; database: \u0026#34;product_db\u0026#34; port: 8082 order-service: responsibility: \u0026#34;Order processing, payment\u0026#34; database: \u0026#34;order_db\u0026#34; port: 8083 notification-service: responsibility: \u0026#34;Notifications, email sending\u0026#34; database: \u0026#34;notification_db\u0026#34; port: 8084 Service Discovery Eureka Server Setup @SpringBootApplication @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } # application.yml (Eureka Server) server: port: 8761 eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ server: enable-self-preservation: false Service Registration (Client) @SpringBootApplication @EnableEurekaClient @EnableJpaAuditing public class UserServiceApplication { public static void main(String[] args) { SpringApplication.run(UserServiceApplication.class, args); } } # application.yml (User Service) server: port: 8081 spring: application: name: user-service datasource: url: jdbc:postgresql://localhost:5432/user_db username: ${DB_USERNAME:user} password: ${DB_PASSWORD:password} eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true lease-renewal-interval-in-seconds: 30 lease-expiration-duration-in-seconds: 90 API Gateway Spring Cloud Gateway Configuration @SpringBootApplication public class ApiGatewayApplication { public static void main(String[] args) { SpringApplication.run(ApiGatewayApplication.class, args); } @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return builder.routes() .route(\u0026#34;user-service\u0026#34;, r -\u0026gt; r.path(\u0026#34;/api/users/**\u0026#34;) .filters(f -\u0026gt; f .stripPrefix(1) .addRequestHeader(\u0026#34;X-Gateway-Name\u0026#34;, \u0026#34;api-gateway\u0026#34;) .circuitBreaker(c -\u0026gt; c.setName(\u0026#34;user-service-cb\u0026#34;))) .uri(\u0026#34;lb://user-service\u0026#34;)) .route(\u0026#34;product-service\u0026#34;, r -\u0026gt; r.path(\u0026#34;/api/products/**\u0026#34;) .filters(f -\u0026gt; f .stripPrefix(1) .retry(3)) .uri(\u0026#34;lb://product-service\u0026#34;)) .route(\u0026#34;order-service\u0026#34;, r -\u0026gt; r.path(\u0026#34;/api/orders/**\u0026#34;) .filters(f -\u0026gt; f .stripPrefix(1) .requestRateLimiter(c -\u0026gt; c .setRateLimiter(redisRateLimiter()) .setKeyResolver(userKeyResolver()))) .uri(\u0026#34;lb://order-service\u0026#34;)) .build(); } @Bean public RedisRateLimiter redisRateLimiter() { return new RedisRateLimiter(10, 20, 1); } @Bean public KeyResolver userKeyResolver() { return exchange -\u0026gt; exchange.getRequest() .getHeaders() .getFirst(\u0026#34;X-User-Id\u0026#34;) != null ? Mono.just(exchange.getRequest().getHeaders().getFirst(\u0026#34;X-User-Id\u0026#34;)) : Mono.just(\u0026#34;anonymous\u0026#34;); } } Global Filter @Component @Slf4j public class LoggingGlobalFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); String path = request.getPath().pathWithinApplication().value(); String method = request.getMethod().name(); String correlationId = UUID.randomUUID().toString(); log.info(\u0026#34;Request started - Method: {}, Path: {}, CorrelationId: {}\u0026#34;, method, path, correlationId); // Add correlation ID to request ServerHttpRequest mutatedRequest = request.mutate() .header(\u0026#34;X-Correlation-ID\u0026#34;, correlationId) .build(); ServerWebExchange mutatedExchange = exchange.mutate() .request(mutatedRequest) .build(); long startTime = System.currentTimeMillis(); return chain.filter(mutatedExchange) .doOnSuccess(aVoid -\u0026gt; { long duration = System.currentTimeMillis() - startTime; log.info(\u0026#34;Request completed - Path: {}, Duration: {}ms, CorrelationId: {}\u0026#34;, path, duration, correlationId); }) .doOnError(throwable -\u0026gt; { long duration = System.currentTimeMillis() - startTime; log.error(\u0026#34;Request failed - Path: {}, Duration: {}ms, CorrelationId: {}, Error: {}\u0026#34;, path, duration, correlationId, throwable.getMessage()); }); } @Override public int getOrder() { return -1; // Execute first } } Inter-Service Communication Synchronous Communication with OpenFeign @FeignClient(name = \u0026#34;user-service\u0026#34;, fallback = UserServiceFallback.class) public interface UserServiceClient { @GetMapping(\u0026#34;/users/{userId}\u0026#34;) UserDto getUser(@PathVariable(\u0026#34;userId\u0026#34;) Long userId); @PostMapping(\u0026#34;/users\u0026#34;) UserDto createUser(@RequestBody CreateUserRequest request); @GetMapping(\u0026#34;/users/{userId}/profile\u0026#34;) UserProfileDto getUserProfile(@PathVariable(\u0026#34;userId\u0026#34;) Long userId); } @Component @Slf4j public class UserServiceFallback implements UserServiceClient { @Override public UserDto getUser(Long userId) { log.warn(\u0026#34;User service call failed, executing fallback - userId: {}\u0026#34;, userId); return UserDto.builder() .id(userId) .name(\u0026#34;Unknown User\u0026#34;) .email(\u0026#34;unknown@example.com\u0026#34;) .build(); } @Override public UserDto createUser(CreateUserRequest request) { log.error(\u0026#34;User creation service call failed\u0026#34;); throw new ServiceUnavailableException(\u0026#34;User service is unavailable\u0026#34;); } @Override public UserProfileDto getUserProfile(Long userId) { log.warn(\u0026#34;User profile service call failed, returning default values\u0026#34;); return UserProfileDto.builder() .userId(userId) .displayName(\u0026#34;Unknown\u0026#34;) .build(); } } Asynchronous Message Communication (RabbitMQ) @Configuration @EnableRabbit public class RabbitConfig { public static final String ORDER_EXCHANGE = \u0026#34;order.exchange\u0026#34;; public static final String ORDER_CREATED_QUEUE = \u0026#34;order.created.queue\u0026#34;; public static final String ORDER_CREATED_ROUTING_KEY = \u0026#34;order.created\u0026#34;; @Bean public TopicExchange orderExchange() { return new TopicExchange(ORDER_EXCHANGE); } @Bean public Queue orderCreatedQueue() { return QueueBuilder.durable(ORDER_CREATED_QUEUE) .withArgument(\u0026#34;x-dead-letter-exchange\u0026#34;, \u0026#34;dlx.exchange\u0026#34;) .withArgument(\u0026#34;x-dead-letter-routing-key\u0026#34;, \u0026#34;dlx.order.created\u0026#34;) .build(); } @Bean public Binding orderCreatedBinding() { return BindingBuilder .bind(orderCreatedQueue()) .to(orderExchange()) .with(ORDER_CREATED_ROUTING_KEY); } @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate template = new RabbitTemplate(connectionFactory); template.setMessageConverter(new Jackson2JsonMessageConverter()); return template; } } // Message Publishing (Order Service) @Service @Slf4j public class OrderEventPublisher { private final RabbitTemplate rabbitTemplate; public void publishOrderCreated(OrderCreatedEvent event) { try { rabbitTemplate.convertAndSend( RabbitConfig.ORDER_EXCHANGE, RabbitConfig.ORDER_CREATED_ROUTING_KEY, event ); log.info(\u0026#34;Order created event published - orderId: {}\u0026#34;, event.getOrderId()); } catch (Exception e) { log.error(\u0026#34;Order created event publishing failed - orderId: {}\u0026#34;, event.getOrderId(), e); throw new EventPublishException(\u0026#34;Failed to publish event\u0026#34;, e); } } } // Message Subscription (Notification Service) @RabbitListener(queues = RabbitConfig.ORDER_CREATED_QUEUE) @Component @Slf4j public class OrderEventListener { private final NotificationService notificationService; private final UserServiceClient userServiceClient; @RabbitHandler public void handleOrderCreated(OrderCreatedEvent event) { try { log.info(\u0026#34;Order created event received - orderId: {}\u0026#34;, event.getOrderId()); UserDto user = userServiceClient.getUser(event.getUserId()); NotificationRequest notification = NotificationRequest.builder() .userId(event.getUserId()) .email(user.getEmail()) .type(NotificationType.ORDER_CONFIRMATION) .title(\u0026#34;Your order has been received\u0026#34;) .content(String.format(\u0026#34;Order number %s has been successfully received.\u0026#34;, event.getOrderId())) .build(); notificationService.sendNotification(notification); } catch (Exception e) { log.error(\u0026#34;Order created event processing failed - orderId: {}\u0026#34;, event.getOrderId(), e); throw new MessageProcessingException(\u0026#34;Failed to process message\u0026#34;, e); } } } Circuit Breaker Pattern Resilience4j Configuration @Configuration public class ResilienceConfig { @Bean public CircuitBreaker userServiceCircuitBreaker() { return CircuitBreaker.of(\u0026#34;user-service\u0026#34;, CircuitBreakerConfig.custom() .failureRateThreshold(50) .waitDurationInOpenState(Duration.ofSeconds(30)) .slidingWindowSize(10) .minimumNumberOfCalls(5) .slowCallRateThreshold(50) .slowCallDurationThreshold(Duration.ofSeconds(2)) .build()); } @Bean public Retry userServiceRetry() { return Retry.of(\u0026#34;user-service\u0026#34;, RetryConfig.custom() .maxAttempts(3) .waitDuration(Duration.ofSeconds(1)) .retryExceptions(ConnectException.class, SocketTimeoutException.class) .build()); } @Bean public TimeLimiter userServiceTimeLimiter() { return TimeLimiter.of(\u0026#34;user-service\u0026#34;, TimeLimiterConfig.custom() .timeoutDuration(Duration.ofSeconds(3)) .build()); } } @Service public class OrderService { private final UserServiceClient userServiceClient; private final CircuitBreaker circuitBreaker; private final Retry retry; public Order createOrder(CreateOrderRequest request) { // User information lookup with Circuit Breaker + Retry UserDto user = Decorators.ofSupplier(() -\u0026gt; userServiceClient.getUser(request.getUserId())) .withCircuitBreaker(circuitBreaker) .withRetry(retry) .withFallback(Arrays.asList(Exception.class), ex -\u0026gt; createDefaultUser(request.getUserId())) .get(); // Order creation logic Order order = Order.builder() .userId(user.getId()) .productId(request.getProductId()) .quantity(request.getQuantity()) .status(OrderStatus.CREATED) .build(); return orderRepository.save(order); } private UserDto createDefaultUser(Long userId) { return UserDto.builder() .id(userId) .name(\u0026#34;Guest User\u0026#34;) .email(\u0026#34;guest@example.com\u0026#34;) .build(); } } Distributed Configuration Management Spring Cloud Config // Config Server @SpringBootApplication @EnableConfigServer public class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class, args); } } # Config Server - application.yml server: port: 8888 spring: cloud: config: server: git: uri: https://github.com/your-org/config-repo clone-on-start: true default-label: main encrypt: enabled: false Distributed Tracing Sleuth + Zipkin Configuration # application.yml for each service spring: sleuth: sampler: probability: 1.0 # 100% sampling in development zipkin: base-url: http://localhost:9411 enabled: true application: name: user-service @RestController @Slf4j public class UserController { private final UserService userService; private final Tracer tracer; @GetMapping(\u0026#34;/users/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; getUser(@PathVariable Long id) { Span customSpan = tracer.nextSpan() .name(\u0026#34;get-user-operation\u0026#34;) .tag(\u0026#34;user.id\u0026#34;, String.valueOf(id)) .start(); try (Tracer.SpanInScope ws = tracer.withSpanInScope(customSpan)) { log.info(\u0026#34;User lookup request - userId: {}\u0026#34;, id); UserDto user = userService.findById(id); customSpan.tag(\u0026#34;user.found\u0026#34;, \u0026#34;true\u0026#34;); return ResponseEntity.ok(user); } catch (Exception e) { customSpan.tag(\u0026#34;error\u0026#34;, e.getMessage()); throw e; } finally { customSpan.end(); } } } Monitoring and Health Checks Actuator Configuration # Common configuration for each service management: endpoints: web: exposure: include: health,info,metrics,prometheus,refresh endpoint: health: show-details: always health: circuitbreakers: enabled: true metrics: export: prometheus: enabled: true distribution: percentiles-histogram: http.server.requests: true @Component public class CustomHealthIndicator implements HealthIndicator { private final UserRepository userRepository; @Override public Health health() { try { long userCount = userRepository.count(); if (userCount \u0026gt;= 0) { return Health.up() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;Available\u0026#34;) .withDetail(\u0026#34;userCount\u0026#34;, userCount) .build(); } } catch (Exception e) { return Health.down() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;Unavailable\u0026#34;) .withException(e) .build(); } return Health.down().build(); } } Integration Testing @SpringBootTest @TestPropertySource(properties = { \u0026#34;spring.cloud.config.enabled=false\u0026#34;, \u0026#34;eureka.client.enabled=false\u0026#34; }) @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) @Testcontainers class UserServiceIntegrationTest { @Container static PostgreSQLContainer\u0026lt;?\u0026gt; postgres = new PostgreSQLContainer\u0026lt;\u0026gt;(\u0026#34;postgres:13\u0026#34;) .withDatabaseName(\u0026#34;test_db\u0026#34;) .withUsername(\u0026#34;test\u0026#34;) .withPassword(\u0026#34;test\u0026#34;); @MockBean private ProductServiceClient productServiceClient; @Autowired private TestRestTemplate restTemplate; @DynamicPropertySource static void configureProperties(DynamicPropertyRegistry registry) { registry.add(\u0026#34;spring.datasource.url\u0026#34;, postgres::getJdbcUrl); registry.add(\u0026#34;spring.datasource.username\u0026#34;, postgres::getUsername); registry.add(\u0026#34;spring.datasource.password\u0026#34;, postgres::getPassword); } @Test void user_creation_and_lookup_integration_test() { // Given CreateUserRequest request = new CreateUserRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); // When - Create user ResponseEntity\u0026lt;UserDto\u0026gt; createResponse = restTemplate.postForEntity( \u0026#34;/api/users\u0026#34;, request, UserDto.class); // Then assertThat(createResponse.getStatusCode()).isEqualTo(HttpStatus.CREATED); UserDto createdUser = createResponse.getBody(); assertThat(createdUser.getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); // When - Get user ResponseEntity\u0026lt;UserDto\u0026gt; getResponse = restTemplate.getForEntity( \u0026#34;/api/users/\u0026#34; + createdUser.getId(), UserDto.class); // Then assertThat(getResponse.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(getResponse.getBody().getId()).isEqualTo(createdUser.getId()); } } Through these patterns and configurations, you can build scalable and robust microservices architecture. Each service can be developed, deployed, and scaled independently, creating systems with fault isolation and resilience.\n"},{
  "section": "Blog",
  "slug": "/en/blog/database-design-patterns/",
  "title": "Database Design Patterns for Java Applications",
  "description": "Learn about efficient database design patterns and optimization techniques using JPA and Spring Data for Java applications.",
  "date": "April 5, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Database",
  "tags": "JPA, Spring Data, Database, Design Patterns",
  "content":"Solid database design is essential for efficient Java application development. Let\u0026rsquo;s explore database design patterns that satisfy both performance and maintainability using JPA and Spring Data.\nEntity Design Principles Basic Entity Structure @Entity @Table(name = \u0026#34;users\u0026#34;) @EntityListeners(AuditingEntityListener.class) @Data @NoArgsConstructor @AllArgsConstructor @Builder public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true, length = 100) private String email; @Column(nullable = false, length = 50) private String name; @Enumerated(EnumType.STRING) @Column(nullable = false) private UserStatus status; @CreatedDate @Column(nullable = false, updatable = false) private LocalDateTime createdAt; @LastModifiedDate @Column(nullable = false) private LocalDateTime updatedAt; @Version private Long version; } Inheritance Mapping Strategy // Joined Table Strategy (JOINED) @Entity @Table(name = \u0026#34;accounts\u0026#34;) @Inheritance(strategy = InheritanceType.JOINED) @DiscriminatorColumn(name = \u0026#34;account_type\u0026#34;) public abstract class Account { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String accountNumber; @Column(nullable = false, precision = 15, scale = 2) private BigDecimal balance; // Common fields } @Entity @Table(name = \u0026#34;savings_accounts\u0026#34;) @DiscriminatorValue(\u0026#34;SAVINGS\u0026#34;) public class SavingsAccount extends Account { @Column(nullable = false, precision = 5, scale = 4) private BigDecimal interestRate; private Integer minBalance; } @Entity @Table(name = \u0026#34;checking_accounts\u0026#34;) @DiscriminatorValue(\u0026#34;CHECKING\u0026#34;) public class CheckingAccount extends Account { @Column(nullable = false, precision = 10, scale = 2) private BigDecimal overdraftLimit; private Integer freeTransactions; } Association Mapping Patterns One-to-Many Association Optimization @Entity @Table(name = \u0026#34;categories\u0026#34;) public class Category { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 100) private String name; // Bidirectional association - LAZY loading for performance @OneToMany(mappedBy = \u0026#34;category\u0026#34;, fetch = FetchType.LAZY, cascade = CascadeType.ALL) @BatchSize(size = 20) // Solving N+1 problem private List\u0026lt;Product\u0026gt; products = new ArrayList\u0026lt;\u0026gt;(); // Convenience methods for associations public void addProduct(Product product) { products.add(product); product.setCategory(this); } public void removeProduct(Product product) { products.remove(product); product.setCategory(null); } } @Entity @Table(name = \u0026#34;products\u0026#34;) public class Product { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 200) private String name; @Column(nullable = false, precision = 10, scale = 2) private BigDecimal price; // Many-to-One association @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;category_id\u0026#34;, nullable = false) private Category category; } Many-to-Many Association with Additional Attributes @Entity @Table(name = \u0026#34;students\u0026#34;) public class Student { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 100) private String name; @OneToMany(mappedBy = \u0026#34;student\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) private List\u0026lt;Enrollment\u0026gt; enrollments = new ArrayList\u0026lt;\u0026gt;(); public void enrollInCourse(Course course, LocalDateTime enrollmentDate) { Enrollment enrollment = new Enrollment(this, course, enrollmentDate); enrollments.add(enrollment); course.getEnrollments().add(enrollment); } } @Entity @Table(name = \u0026#34;courses\u0026#34;) public class Course { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 200) private String title; @OneToMany(mappedBy = \u0026#34;course\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) private List\u0026lt;Enrollment\u0026gt; enrollments = new ArrayList\u0026lt;\u0026gt;(); } @Entity @Table(name = \u0026#34;enrollments\u0026#34;) public class Enrollment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;student_id\u0026#34;) private Student student; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;course_id\u0026#34;) private Course course; @Column(nullable = false) private LocalDateTime enrollmentDate; private BigDecimal grade; public Enrollment(Student student, Course course, LocalDateTime enrollmentDate) { this.student = student; this.course = course; this.enrollmentDate = enrollmentDate; } } Repository Pattern Custom Repository Implementation public interface UserRepositoryCustom { List\u0026lt;User\u0026gt; findUsersWithComplexCriteria(UserSearchCriteria criteria); Page\u0026lt;User\u0026gt; findActiveUsersWithPosts(Pageable pageable); } @Repository public class UserRepositoryImpl implements UserRepositoryCustom { @PersistenceContext private EntityManager entityManager; @Override public List\u0026lt;User\u0026gt; findUsersWithComplexCriteria(UserSearchCriteria criteria) { CriteriaBuilder cb = entityManager.getCriteriaBuilder(); CriteriaQuery\u0026lt;User\u0026gt; query = cb.createQuery(User.class); Root\u0026lt;User\u0026gt; root = query.from(User.class); List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); if (criteria.getName() != null) { predicates.add(cb.like(cb.lower(root.get(\u0026#34;name\u0026#34;)), \u0026#34;%\u0026#34; + criteria.getName().toLowerCase() + \u0026#34;%\u0026#34;)); } if (criteria.getStatus() != null) { predicates.add(cb.equal(root.get(\u0026#34;status\u0026#34;), criteria.getStatus())); } if (criteria.getCreatedAfter() != null) { predicates.add(cb.greaterThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), criteria.getCreatedAfter())); } query.where(predicates.toArray(new Predicate[0])); query.orderBy(cb.desc(root.get(\u0026#34;createdAt\u0026#34;))); return entityManager.createQuery(query) .setMaxResults(100) .getResultList(); } @Override public Page\u0026lt;User\u0026gt; findActiveUsersWithPosts(Pageable pageable) { String jpql = \u0026#34;\u0026#34;\u0026#34; SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.posts p WHERE u.status = :status ORDER BY u.createdAt DESC \u0026#34;\u0026#34;\u0026#34;; TypedQuery\u0026lt;User\u0026gt; query = entityManager.createQuery(jpql, User.class) .setParameter(\u0026#34;status\u0026#34;, UserStatus.ACTIVE) .setFirstResult((int) pageable.getOffset()) .setMaxResults(pageable.getPageSize()); List\u0026lt;User\u0026gt; users = query.getResultList(); // Count total results Long total = entityManager.createQuery( \u0026#34;SELECT COUNT(DISTINCT u) FROM User u WHERE u.status = :status\u0026#34;, Long.class) .setParameter(\u0026#34;status\u0026#34;, UserStatus.ACTIVE) .getSingleResult(); return new PageImpl\u0026lt;\u0026gt;(users, pageable, total); } } public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, UserRepositoryCustom { @Query(\u0026#34;SELECT u FROM User u WHERE u.email = :email\u0026#34;) Optional\u0026lt;User\u0026gt; findByEmail(@Param(\u0026#34;email\u0026#34;) String email); @Query(value = \u0026#34;\u0026#34;\u0026#34; SELECT u.* FROM users u WHERE u.status = :status AND u.created_at \u0026gt;= :since ORDER BY u.created_at DESC \u0026#34;\u0026#34;\u0026#34;, nativeQuery = true) List\u0026lt;User\u0026gt; findRecentActiveUsers(@Param(\u0026#34;status\u0026#34;) String status, @Param(\u0026#34;since\u0026#34;) LocalDateTime since); @Modifying @Query(\u0026#34;UPDATE User u SET u.status = :status WHERE u.id IN :ids\u0026#34;) int updateUserStatus(@Param(\u0026#34;ids\u0026#34;) List\u0026lt;Long\u0026gt; ids, @Param(\u0026#34;status\u0026#34;) UserStatus status); } Performance Optimization Patterns Pagination and Sorting @Service @Transactional(readOnly = true) public class ProductService { private final ProductRepository productRepository; public Page\u0026lt;ProductDto\u0026gt; getProducts(ProductSearchRequest request) { Pageable pageable = PageRequest.of( request.getPage(), request.getSize(), Sort.by(Sort.Direction.DESC, \u0026#34;createdAt\u0026#34;) ); Page\u0026lt;Product\u0026gt; products = productRepository.findByCategoryAndPriceRange( request.getCategoryId(), request.getMinPrice(), request.getMaxPrice(), pageable ); return products.map(this::convertToDto); } private ProductDto convertToDto(Product product) { return ProductDto.builder() .id(product.getId()) .name(product.getName()) .price(product.getPrice()) .categoryName(product.getCategory().getName()) .build(); } } Batch Processing Optimization @Service public class BatchUserService { @PersistenceContext private EntityManager entityManager; @Transactional public void batchUpdateUserStatus(List\u0026lt;Long\u0026gt; userIds, UserStatus newStatus) { final int batchSize = 100; for (int i = 0; i \u0026lt; userIds.size(); i += batchSize) { List\u0026lt;Long\u0026gt; batch = userIds.subList(i, Math.min(i + batchSize, userIds.size())); entityManager.createQuery( \u0026#34;UPDATE User u SET u.status = :status WHERE u.id IN :ids\u0026#34;) .setParameter(\u0026#34;status\u0026#34;, newStatus) .setParameter(\u0026#34;ids\u0026#34;, batch) .executeUpdate(); entityManager.flush(); entityManager.clear(); } } @Transactional public void batchInsertUsers(List\u0026lt;CreateUserRequest\u0026gt; requests) { final int batchSize = 50; for (int i = 0; i \u0026lt; requests.size(); i++) { User user = User.builder() .email(requests.get(i).getEmail()) .name(requests.get(i).getName()) .status(UserStatus.ACTIVE) .build(); entityManager.persist(user); if (i % batchSize == 0 \u0026amp;\u0026amp; i \u0026gt; 0) { entityManager.flush(); entityManager.clear(); } } } } Caching Strategy @Entity @Cacheable @org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE) public class Category { // Entity definition } @Service public class CategoryService { @Cacheable(value = \u0026#34;categories\u0026#34;, key = \u0026#34;#id\u0026#34;) public Category findById(Long id) { return categoryRepository.findById(id) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;Category not found\u0026#34;)); } @Cacheable(value = \u0026#34;categories\u0026#34;, key = \u0026#34;\u0026#39;all\u0026#39;\u0026#34;) public List\u0026lt;Category\u0026gt; findAll() { return categoryRepository.findAll(); } @CacheEvict(value = \u0026#34;categories\u0026#34;, allEntries = true) public Category save(Category category) { return categoryRepository.save(category); } } Transaction Management Declarative Transactions @Service @Transactional(readOnly = true) public class OrderService { private final OrderRepository orderRepository; private final ProductRepository productRepository; private final InventoryService inventoryService; @Transactional public Order createOrder(CreateOrderRequest request) { // Check product inventory Product product = productRepository.findById(request.getProductId()) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;Product not found\u0026#34;)); if (!inventoryService.hasStock(product.getId(), request.getQuantity())) { throw new InsufficientStockException(\u0026#34;Insufficient stock\u0026#34;); } // Create order Order order = Order.builder() .product(product) .quantity(request.getQuantity()) .totalPrice(product.getPrice().multiply(BigDecimal.valueOf(request.getQuantity()))) .status(OrderStatus.PENDING) .build(); Order savedOrder = orderRepository.save(order); // Decrease inventory inventoryService.decreaseStock(product.getId(), request.getQuantity()); return savedOrder; } @Transactional(propagation = Propagation.REQUIRES_NEW) public void processPayment(Long orderId, PaymentInfo paymentInfo) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;Order not found\u0026#34;)); try { // Payment processing logic paymentService.processPayment(paymentInfo); order.setStatus(OrderStatus.PAID); } catch (PaymentException e) { order.setStatus(OrderStatus.PAYMENT_FAILED); throw e; } finally { orderRepository.save(order); } } } Auditing Features @EntityListeners(AuditingEntityListener.class) @MappedSuperclass public abstract class BaseEntity { @CreatedDate @Column(name = \u0026#34;created_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime createdAt; @LastModifiedDate @Column(name = \u0026#34;updated_at\u0026#34;, nullable = false) private LocalDateTime updatedAt; @CreatedBy @Column(name = \u0026#34;created_by\u0026#34;, updatable = false) private String createdBy; @LastModifiedBy @Column(name = \u0026#34;updated_by\u0026#34;) private String updatedBy; } @Configuration @EnableJpaAuditing public class JpaAuditingConfig { @Bean public AuditorAware\u0026lt;String\u0026gt; auditorProvider() { return () -\u0026gt; { Authentication auth = SecurityContextHolder.getContext().getAuthentication(); if (auth != null \u0026amp;\u0026amp; auth.isAuthenticated() \u0026amp;\u0026amp; !auth.getPrincipal().equals(\u0026#34;anonymousUser\u0026#34;)) { return Optional.of(auth.getName()); } return Optional.of(\u0026#34;system\u0026#34;); }; } } Through these patterns, you can build a robust and high-performance database layer. Each pattern should be selectively applied according to specific situations to achieve optimal results.\n"},{
  "section": "Blog",
  "slug": "/en/blog/spring-boot-best-practices/",
  "title": "Spring Boot Production Best Practices",
  "description": "Learn essential configurations and coding conventions for stable Spring Boot applications in production environments.",
  "date": "April 4, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Java",
  "tags": "Spring Boot, Java, Backend, Best Practices",
  "content":"To create stable Spring Boot applications in production, you need more than just basic functionality. Let\u0026rsquo;s explore essential practices for building robust, secure, and maintainable applications.\nApplication Configuration Profile-based Configuration # application.yml spring: profiles: active: ${SPRING_PROFILES_ACTIVE:dev} --- # Development profile spring: config: activate: on-profile: dev datasource: url: jdbc:h2:mem:testdb driver-class-name: org.h2.Driver jpa: show-sql: true hibernate: ddl-auto: create-drop --- # Production profile spring: config: activate: on-profile: prod datasource: url: ${DATABASE_URL} username: ${DB_USERNAME} password: ${DB_PASSWORD} hikari: maximum-pool-size: 20 minimum-idle: 5 jpa: show-sql: false hibernate: ddl-auto: validate Externalized Configuration @ConfigurationProperties(prefix = \u0026#34;app\u0026#34;) @Component public class AppProperties { private String name; private String version; private Security security = new Security(); private Database database = new Database(); // Getters and setters public static class Security { private String jwtSecret; private long jwtExpirationMs = 86400000; // 24 hours // Getters and setters } public static class Database { private int maxConnections = 20; private int connectionTimeout = 30000; // Getters and setters } } Security Implementation JWT Authentication @Component public class JwtTokenProvider { private final String jwtSecret; private final int jwtExpirationMs; public JwtTokenProvider(AppProperties appProperties) { this.jwtSecret = appProperties.getSecurity().getJwtSecret(); this.jwtExpirationMs = appProperties.getSecurity().getJwtExpirationMs(); } public String generateToken(Authentication authentication) { UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal(); Date expiryDate = new Date(System.currentTimeMillis() + jwtExpirationMs); return Jwts.builder() .setSubject(Long.toString(userPrincipal.getId())) .setIssuedAt(new Date()) .setExpiration(expiryDate) .signWith(SignatureAlgorithm.HS512, jwtSecret) .compact(); } public boolean validateToken(String authToken) { try { Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken); return true; } catch (JwtException | IllegalArgumentException e) { log.error(\u0026#34;Invalid JWT token: {}\u0026#34;, e.getMessage()); } return false; } } Security Configuration @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig { @Autowired private JwtAuthenticationEntryPoint unauthorizedHandler; @Bean public JwtAuthenticationFilter jwtAuthenticationFilter() { return new JwtAuthenticationFilter(); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.cors() .and() .csrf().disable() .exceptionHandling() .authenticationEntryPoint(unauthorizedHandler) .and() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .antMatchers(\u0026#34;/api/auth/**\u0026#34;).permitAll() .antMatchers(\u0026#34;/api/public/**\u0026#34;).permitAll() .antMatchers(HttpMethod.GET, \u0026#34;/api/posts/**\u0026#34;).permitAll() .anyRequest().authenticated(); http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); } } Error Handling Global Exception Handler @RestControllerAdvice @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(ValidationException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public ApiResponse handleValidationException(ValidationException ex) { log.warn(\u0026#34;Validation error: {}\u0026#34;, ex.getMessage()); return ApiResponse.error(\u0026#34;Validation failed\u0026#34;, ex.getMessage()); } @ExceptionHandler(ResourceNotFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ApiResponse handleResourceNotFoundException(ResourceNotFoundException ex) { log.warn(\u0026#34;Resource not found: {}\u0026#34;, ex.getMessage()); return ApiResponse.error(\u0026#34;Resource not found\u0026#34;, ex.getMessage()); } @ExceptionHandler(DataIntegrityViolationException.class) @ResponseStatus(HttpStatus.CONFLICT) public ApiResponse handleDataIntegrityViolation(DataIntegrityViolationException ex) { log.error(\u0026#34;Data integrity violation: {}\u0026#34;, ex.getMessage()); return ApiResponse.error(\u0026#34;Data conflict\u0026#34;, \u0026#34;The requested operation conflicts with existing data\u0026#34;); } @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ApiResponse handleGenericException(Exception ex) { log.error(\u0026#34;Unexpected error occurred\u0026#34;, ex); return ApiResponse.error(\u0026#34;Internal server error\u0026#34;, \u0026#34;An unexpected error occurred\u0026#34;); } } Database Optimization Connection Pool Configuration spring: datasource: hikari: maximum-pool-size: 20 minimum-idle: 5 idle-timeout: 300000 max-lifetime: 1200000 connection-timeout: 20000 validation-timeout: 5000 leak-detection-threshold: 60000 JPA Performance Tuning @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_user_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_user_status\u0026#34;, columnList = \u0026#34;status\u0026#34;) }) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, fetch = FetchType.LAZY, cascade = CascadeType.ALL) @BatchSize(size = 20) private List\u0026lt;Post\u0026gt; posts = new ArrayList\u0026lt;\u0026gt;(); // Constructors, getters, setters } @Repository public class UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { @Query(\u0026#34;SELECT u FROM User u LEFT JOIN FETCH u.posts WHERE u.id = :id\u0026#34;) Optional\u0026lt;User\u0026gt; findByIdWithPosts(@Param(\u0026#34;id\u0026#34;) Long id); @Query(value = \u0026#34;SELECT * FROM users WHERE status = :status ORDER BY created_at DESC LIMIT :limit\u0026#34;, nativeQuery = true) List\u0026lt;User\u0026gt; findActiveUsersWithLimit(@Param(\u0026#34;status\u0026#34;) String status, @Param(\u0026#34;limit\u0026#34;) int limit); } Monitoring and Observability Actuator Configuration management: endpoints: web: exposure: include: health,info,metrics,prometheus endpoint: health: show-details: when-authorized metrics: export: prometheus: enabled: true Custom Health Indicator @Component public class DatabaseHealthIndicator implements HealthIndicator { private final DataSource dataSource; public DatabaseHealthIndicator(DataSource dataSource) { this.dataSource = dataSource; } @Override public Health health() { try (Connection connection = dataSource.getConnection()) { if (connection.isValid(1)) { return Health.up() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;Available\u0026#34;) .withDetail(\u0026#34;validationQuery\u0026#34;, \u0026#34;SELECT 1\u0026#34;) .build(); } } catch (SQLException e) { return Health.down() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;Unavailable\u0026#34;) .withException(e) .build(); } return Health.down().withDetail(\u0026#34;database\u0026#34;, \u0026#34;Connection validation failed\u0026#34;).build(); } } Application Metrics @Service @Slf4j public class UserService { private final UserRepository userRepository; private final MeterRegistry meterRegistry; private final Counter userCreationCounter; private final Timer userFetchTimer; public UserService(UserRepository userRepository, MeterRegistry meterRegistry) { this.userRepository = userRepository; this.meterRegistry = meterRegistry; this.userCreationCounter = Counter.builder(\u0026#34;user.creation.count\u0026#34;) .description(\u0026#34;Number of users created\u0026#34;) .register(meterRegistry); this.userFetchTimer = Timer.builder(\u0026#34;user.fetch.time\u0026#34;) .description(\u0026#34;Time taken to fetch users\u0026#34;) .register(meterRegistry); } public User createUser(CreateUserRequest request) { return userFetchTimer.recordCallable(() -\u0026gt; { User user = new User(request.getEmail(), request.getName()); User savedUser = userRepository.save(user); userCreationCounter.increment(); log.info(\u0026#34;User created with ID: {}\u0026#34;, savedUser.getId()); return savedUser; }); } } Testing Best Practices Integration Tests @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestPropertySource(properties = { \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34; }) class UserControllerIntegrationTest { @Autowired private TestRestTemplate restTemplate; @Autowired private UserRepository userRepository; @Test void createUser_Test() { CreateUserRequest request = new CreateUserRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.postForEntity(\u0026#34;/api/users\u0026#34;, request, User.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED); assertThat(response.getBody().getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); assertThat(userRepository.count()).isEqualTo(1); } } Unit Tests with Mocking @ExtendWith(MockitoExtension.class) class UserServiceTest { @Mock private UserRepository userRepository; @Mock private MeterRegistry meterRegistry; @InjectMocks private UserService userService; @Test void createUser_Success_Test() { // Given CreateUserRequest request = new CreateUserRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); User savedUser = new User(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); savedUser.setId(1L); when(userRepository.save(any(User.class))).thenReturn(savedUser); // When User result = userService.createUser(request); // Then assertThat(result.getId()).isEqualTo(1L); assertThat(result.getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); verify(userRepository).save(any(User.class)); } } Performance Optimization Caching Strategy @Service @EnableCaching public class UserService { @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public User findById(Long id) { return userRepository.findById(id) .orElseThrow(() -\u0026gt; new ResourceNotFoundException(\u0026#34;User not found\u0026#34;)); } @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User updateUser(User user) { return userRepository.save(user); } @CacheEvict(value = \u0026#34;users\u0026#34;, allEntries = true) public void clearUserCache() { // Cache will be cleared } } Asynchronous Processing @Service @Slf4j public class EmailService { @Async(\u0026#34;taskExecutor\u0026#34;) public CompletableFuture\u0026lt;Void\u0026gt; sendWelcomeEmail(String email, String name) { try { // Email sending simulation Thread.sleep(2000); log.info(\u0026#34;Welcome email sent to: {}\u0026#34;, email); return CompletableFuture.completedFuture(null); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } } @Configuration @EnableAsync public class AsyncConfig { @Bean(name = \u0026#34;taskExecutor\u0026#34;) public TaskExecutor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(2); executor.setMaxPoolSize(10); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;async-\u0026#34;); executor.initialize(); return executor; } } Through these practices, you can ensure that Spring Boot applications are safe and maintainable in production. Implement them gradually while adjusting to specific requirements.\n"}]

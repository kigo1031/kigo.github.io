[{
  "section": "Blog",
  "slug": "/en/blog/quarkus-cloud-native-java/",
  "title": "Getting Started with Cloud Native Java Development using Quarkus",
  "description": "Introduction to Quarkus, the Kubernetes-era Java framework, and comparison with Spring Boot",
  "date": "August 3, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend",
  "tags": "Java, Quarkus, Cloud Native, Kubernetes, GraalVM",
  "content":"Recently, there\u0026rsquo;s been a lot of discussion about the limitations of Java applications in cloud-native environments. Particularly, high memory usage and slow startup times have made Java somewhat disadvantageous in containerized environments. Quarkus emerged to solve these exact problems.\nWhat is Quarkus? Quarkus is a Kubernetes Native Java framework developed by Red Hat. True to its slogan \u0026ldquo;Supersonic Subatomic Java,\u0026rdquo; it boasts much faster startup times and lower memory usage compared to traditional Java applications.\nKey Features Fast startup time: Millisecond-level startup times Low memory usage: 1/10th of traditional usage GraalVM Native Image support: Native compilation capable Developer-friendly: Live Coding for immediate reflection Spring Boot vs Quarkus Memory Usage Comparison # Spring Boot Application Memory: ~200MB # Quarkus JVM Mode Memory: ~50MB # Quarkus Native Mode Memory: ~20MB Startup Time Comparison # Spring Boot Started in 3.2 seconds # Quarkus JVM Mode Started in 1.1 seconds # Quarkus Native Mode Started in 0.016 seconds Getting Started with Quarkus Project 1. Project Creation mvn io.quarkus.platform:quarkus-maven-plugin:3.2.4.Final:create \\ -DprojectGroupId=com.kigo.example \\ -DprojectArtifactId=quarkus-demo \\ -DclassName=\u0026#34;com.kigo.example.GreetingResource\u0026#34; \\ -Dpath=\u0026#34;/hello\u0026#34; 2. Basic REST API Implementation @Path(\u0026#34;/hello\u0026#34;) public class GreetingResource { @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return \u0026#34;Hello from Quarkus!\u0026#34;; } } 3. Database Integration (Hibernate ORM with Panache) @Entity @Table(name = \u0026#34;users\u0026#34;) public class User extends PanacheEntity { public String name; public String email; public static List\u0026lt;User\u0026gt; findByName(String name) { return find(\u0026#34;name\u0026#34;, name).list(); } } Benefits of Quarkus in Production 1. Container Environment Optimization In Kubernetes, faster startup times enable quicker response to traffic spikes during Pod scaling.\n# Requesting fewer resources in Kubernetes Deployment resources: requests: memory: \u0026#34;32Mi\u0026#34; cpu: \u0026#34;100m\u0026#34; limits: memory: \u0026#34;64Mi\u0026#34; cpu: \u0026#34;200m\u0026#34; 2. Improved Development Productivity Live Coding feature reflects code changes immediately without application restart.\n# Run in development mode mvn quarkus:dev 3. GraalVM Native Image When compiled to native image, it can run without JVM.\n# Build native image mvn clean package -Pnative # Check executable size and startup time ls -lh target/*-runner time ./target/quarkus-demo-1.0.0-SNAPSHOT-runner Quarkus Migration for Spring Boot Developers Dependency Injection // Spring Boot @Autowired private UserService userService; // Quarkus (CDI) @Inject UserService userService; Configuration // Spring Boot @Value(\u0026#34;${app.name}\u0026#34;) private String appName; // Quarkus @ConfigProperty(name = \u0026#34;app.name\u0026#34;) String appName; REST Controller // Spring Boot @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class UserController { @GetMapping(\u0026#34;/users\u0026#34;) public List\u0026lt;User\u0026gt; getUsers() { ... } } // Quarkus @Path(\u0026#34;/api/users\u0026#34;) public class UserResource { @GET public List\u0026lt;User\u0026gt; getUsers() { ... } } When to Choose Quarkus? Quarkus is Suitable for: Microservices Architecture Container-based Deployment Serverless Environments (AWS Lambda, etc.) Resource-constrained Environments Spring Boot is Still Great for: Deep Dependency on Spring Ecosystem Large Monolithic Applications Need for Rich Community Support Performance Test Results Results measured from actual projects:\n# Based on identical REST API ┌──────────────┬─────────────┬──────────────┬─────────────┐ │ │ Spring Boot │ Quarkus JVM │ Quarkus Native │ ├──────────────┼─────────────┼──────────────┼─────────────┤ │ Startup Time │ 3.2s │ 1.1s │ 0.016s │ │ Memory Usage │ 200MB │ 50MB │ 20MB │ │ Throughput │ 1,200 RPS │ 1,180 RPS │ 1,100 RPS │ └──────────────┴─────────────┴──────────────┴─────────────┘ Conclusion Quarkus is a Java framework suited for the cloud-native era. Rather than being a complete replacement for Spring Boot, it can be a better choice in specific situations.\nParticularly, consider adopting Quarkus in the following scenarios:\nWhen container resource cost optimization is important Microservices requiring fast scale-out Java usage in serverless environments I\u0026rsquo;ll continue to share practical application cases as I use Quarkus in more projects!\nReferences:\nQuarkus Official Documentation Quarkus vs Spring Boot Benchmark GraalVM Native Image "},{
  "section": "Blog",
  "slug": "/en/blog/quarkus-jpa-guide/",
  "title": "Complete Quarkus JPA Guide - From Entity to Transaction",
  "description": "Everything backend developers need to know about using JPA in Quarkus, from database integration to advanced features.",
  "date": "August 3, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "backend",
  "tags": "Quarkus, JPA, Database, Java, Backend, Hibernate, PostgreSQL",
  "content":"When transitioning from Spring Boot to Quarkus, one of the first questions that comes to mind is \u0026ldquo;How do I handle database integration?\u0026rdquo; Fortunately, Quarkus provides excellent JPA support, often with better performance and simpler configuration.\nProject Setup Adding Dependencies Add the necessary dependencies to your pom.xml:\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- Quarkus JPA Extension --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.quarkus\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;quarkus-hibernate-orm-panache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- PostgreSQL Driver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.quarkus\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;quarkus-jdbc-postgresql\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- DevServices for Development --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.quarkus\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;quarkus-devservices-postgresql\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Database Configuration Configure your database in application.properties:\n# Database Connection Settings quarkus.datasource.db-kind=postgresql quarkus.datasource.username=postgres quarkus.datasource.password=password quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_jpa # Hibernate Settings quarkus.hibernate-orm.database.generation=drop-and-create quarkus.hibernate-orm.log.sql=true quarkus.hibernate-orm.log.bind-parameters=true # Environment-specific settings %dev.quarkus.hibernate-orm.database.generation=drop-and-create %prod.quarkus.hibernate-orm.database.generation=validate Entity Definition Quarkus uses standard JPA annotations:\n@Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String name; @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List\u0026lt;Post\u0026gt; posts = new ArrayList\u0026lt;\u0026gt;(); // Default constructor (required by JPA) public User() {} public User(String email, String name) { this.email = email; this.name = name; this.createdAt = LocalDateTime.now(); } // getters/setters omitted } @Entity @Table(name = \u0026#34;posts\u0026#34;) public class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String title; @Column(columnDefinition = \u0026#34;TEXT\u0026#34;) private String content; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;user_id\u0026#34;) private User user; @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt; public Post() {} public Post(String title, String content, User user) { this.title = title; this.content = content; this.user = user; this.createdAt = LocalDateTime.now(); } // getters/setters omitted } Repository Pattern vs Panache Pattern Quarkus supports both approaches:\n1. Traditional Repository Pattern @ApplicationScoped public class UserRepository { @Inject EntityManager em; @Transactional public User save(User user) { if (user.getId() == null) { em.persist(user); return user; } else { return em.merge(user); } } public Optional\u0026lt;User\u0026gt; findById(Long id) { return Optional.ofNullable(em.find(User.class, id)); } public Optional\u0026lt;User\u0026gt; findByEmail(String email) { try { User user = em.createQuery( \u0026#34;SELECT u FROM User u WHERE u.email = :email\u0026#34;, User.class) .setParameter(\u0026#34;email\u0026#34;, email) .getSingleResult(); return Optional.of(user); } catch (NoResultException e) { return Optional.empty(); } } public List\u0026lt;User\u0026gt; findAll() { return em.createQuery(\u0026#34;SELECT u FROM User u\u0026#34;, User.class) .getResultList(); } @Transactional public void delete(User user) { em.remove(em.merge(user)); } } 2. Panache Pattern (Recommended) Using Panache makes everything much simpler:\n@Entity @Table(name = \u0026#34;users\u0026#34;) public class User extends PanacheEntity { @Column(nullable = false, unique = true) public String email; @Column(nullable = false) public String name; @Column(name = \u0026#34;created_at\u0026#34;) public LocalDateTime createdAt; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, fetch = FetchType.LAZY) public List\u0026lt;Post\u0026gt; posts = new ArrayList\u0026lt;\u0026gt;(); public User() {} public User(String email, String name) { this.email = email; this.name = name; this.createdAt = LocalDateTime.now(); } // Custom query methods public static Optional\u0026lt;User\u0026gt; findByEmail(String email) { return find(\u0026#34;email\u0026#34;, email).firstResultOptional(); } public static List\u0026lt;User\u0026gt; findByNameContaining(String name) { return find(\u0026#34;name like ?1\u0026#34;, \u0026#34;%\u0026#34; + name + \u0026#34;%\u0026#34;).list(); } } If you prefer separate repository classes:\n@ApplicationScoped public class UserRepository implements PanacheRepository\u0026lt;User\u0026gt; { public Optional\u0026lt;User\u0026gt; findByEmail(String email) { return find(\u0026#34;email\u0026#34;, email).firstResultOptional(); } public List\u0026lt;User\u0026gt; findActiveUsers() { return find(\u0026#34;active = true\u0026#34;).list(); } public long countByDomain(String domain) { return count(\u0026#34;email like ?1\u0026#34;, \u0026#34;%@\u0026#34; + domain); } } Service Layer Implementation @ApplicationScoped public class UserService { @Inject UserRepository userRepository; @Transactional public User createUser(String email, String name) { // Check for duplicate email if (userRepository.findByEmail(email).isPresent()) { throw new IllegalArgumentException(\u0026#34;Email already exists\u0026#34;); } User user = new User(email, name); userRepository.persist(user); return user; } public Optional\u0026lt;User\u0026gt; getUserById(Long id) { return userRepository.findByIdOptional(id); } public List\u0026lt;User\u0026gt; getAllUsers() { return userRepository.listAll(); } @Transactional public User updateUser(Long id, String name) { User user = userRepository.findById(id); if (user == null) { throw new EntityNotFoundException(\u0026#34;User not found\u0026#34;); } user.name = name; return user; // Panache automatically detects changes } @Transactional public void deleteUser(Long id) { if (!userRepository.deleteById(id)) { throw new EntityNotFoundException(\u0026#34;User not found\u0026#34;); } } } REST API Implementation @Path(\u0026#34;/api/users\u0026#34;) @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public class UserResource { @Inject UserService userService; @GET public List\u0026lt;User\u0026gt; getAllUsers() { return userService.getAllUsers(); } @GET @Path(\u0026#34;/{id}\u0026#34;) public Response getUserById(@PathParam(\u0026#34;id\u0026#34;) Long id) { return userService.getUserById(id) .map(user -\u0026gt; Response.ok(user).build()) .orElse(Response.status(Response.Status.NOT_FOUND).build()); } @POST public Response createUser(CreateUserRequest request) { try { User user = userService.createUser(request.email, request.name); return Response.status(Response.Status.CREATED).entity(user).build(); } catch (IllegalArgumentException e) { return Response.status(Response.Status.BAD_REQUEST) .entity(Map.of(\u0026#34;error\u0026#34;, e.getMessage())) .build(); } } @PUT @Path(\u0026#34;/{id}\u0026#34;) public Response updateUser(@PathParam(\u0026#34;id\u0026#34;) Long id, UpdateUserRequest request) { try { User user = userService.updateUser(id, request.name); return Response.ok(user).build(); } catch (EntityNotFoundException e) { return Response.status(Response.Status.NOT_FOUND) .entity(Map.of(\u0026#34;error\u0026#34;, e.getMessage())) .build(); } } @DELETE @Path(\u0026#34;/{id}\u0026#34;) public Response deleteUser(@PathParam(\u0026#34;id\u0026#34;) Long id) { try { userService.deleteUser(id); return Response.noContent().build(); } catch (EntityNotFoundException e) { return Response.status(Response.Status.NOT_FOUND) .entity(Map.of(\u0026#34;error\u0026#34;, e.getMessage())) .build(); } } public static class CreateUserRequest { public String email; public String name; } public static class UpdateUserRequest { public String name; } } Advanced Features 1. Custom Queries @ApplicationScoped public class PostRepository implements PanacheRepository\u0026lt;Post\u0026gt; { // Using JPQL public List\u0026lt;Post\u0026gt; findByTitleContaining(String keyword) { return find(\u0026#34;title like ?1\u0026#34;, \u0026#34;%\u0026#34; + keyword + \u0026#34;%\u0026#34;).list(); } // Using native queries public List\u0026lt;Post\u0026gt; findRecentPosts(LocalDateTime since) { return getEntityManager() .createNativeQuery(\u0026#34;SELECT * FROM posts WHERE created_at \u0026gt;= ?1\u0026#34;, Post.class) .setParameter(1, since) .getResultList(); } // Complex conditional queries public List\u0026lt;Post\u0026gt; findPostsByUserAndPeriod(String userEmail, LocalDateTime startDate, LocalDateTime endDate) { return find(\u0026#34;user.email = ?1 and createdAt between ?2 and ?3\u0026#34;, userEmail, startDate, endDate).list(); } } 2. Transaction Management @ApplicationScoped public class PostService { @Inject PostRepository postRepository; @Inject UserRepository userRepository; // Basic transaction @Transactional public Post createPost(Long userId, String title, String content) { User user = userRepository.findById(userId); if (user == null) { throw new EntityNotFoundException(\u0026#34;User not found\u0026#34;); } Post post = new Post(title, content, user); postRepository.persist(post); return post; } // Read-only transaction @Transactional(Transactional.TxType.SUPPORTS) public List\u0026lt;Post\u0026gt; getPostsByUser(Long userId) { return postRepository.find(\u0026#34;user.id\u0026#34;, userId).list(); } // New transaction @Transactional(Transactional.TxType.REQUIRES_NEW) public void logActivity(String activity) { // Logs are processed in separate transaction // Logs persist even if main transaction rolls back } // Specify rollback conditions @Transactional(rollbackOn = {BusinessException.class}) public void complexBusinessLogic() { // Only rolls back on BusinessException } } 3. Pagination and Sorting @GET public Response getUsers(@QueryParam(\u0026#34;page\u0026#34;) @DefaultValue(\u0026#34;0\u0026#34;) int page, @QueryParam(\u0026#34;size\u0026#34;) @DefaultValue(\u0026#34;10\u0026#34;) int size, @QueryParam(\u0026#34;sort\u0026#34;) @DefaultValue(\u0026#34;id\u0026#34;) String sort) { PanacheQuery\u0026lt;User\u0026gt; query = User.findAll(Sort.by(sort)); List\u0026lt;User\u0026gt; users = query.page(page, size).list(); long totalCount = query.count(); int totalPages = (int) Math.ceil((double) totalCount / size); Map\u0026lt;String, Object\u0026gt; response = Map.of( \u0026#34;users\u0026#34;, users, \u0026#34;currentPage\u0026#34;, page, \u0026#34;totalPages\u0026#34;, totalPages, \u0026#34;totalCount\u0026#34;, totalCount ); return Response.ok(response).build(); } Development Environment Tips Using DevServices In development, DevServices automatically sets up databases:\n# DevServices automatically runs PostgreSQL container in dev/test %dev.quarkus.devservices.enabled=true %test.quarkus.devservices.enabled=true # Specify database version quarkus.datasource.devservices.image-name=postgres:14 Data Initialization @ApplicationScoped public class DataInitializer { @Inject UserService userService; @Inject PostService postService; void onStart(@Observes StartupEvent ev) { // Only run in development if (Profile.of(\u0026#34;dev\u0026#34;).equals(Profile.getCurrent())) { initializeData(); } } @Transactional void initializeData() { // Create test data User user1 = userService.createUser(\u0026#34;john@example.com\u0026#34;, \u0026#34;John Doe\u0026#34;); User user2 = userService.createUser(\u0026#34;jane@example.com\u0026#34;, \u0026#34;Jane Smith\u0026#34;); postService.createPost(user1.id, \u0026#34;First Post\u0026#34;, \u0026#34;This is my first post\u0026#34;); postService.createPost(user2.id, \u0026#34;Another Post\u0026#34;, \u0026#34;Hello world!\u0026#34;); } } Key Differences from Spring Boot Panache Pattern: No need to implement repository interfaces Fast Startup: Quick boot times in native images DevServices: Automatic development environment setup Configuration: application.properties focused Dependency Injection: CDI-based using @Inject Conclusion Quarkus JPA is remarkably similar to Spring Boot JPA while being simpler and more performant. The Panache pattern significantly reduces boilerplate code, improving development productivity.\nIf fast startup times and low memory usage are important for your cloud-native environment, I highly recommend Quarkus JPA. With existing JPA knowledge, the learning curve is minimal and adaptation is straightforward.\nIn the next post, we\u0026rsquo;ll explore Redis caching and messaging system integration in Quarkus.\n"},{
  "section": "Blog",
  "slug": "/en/blog/vscode-optimization/",
  "title": "Optimizing VS Code Development Environment",
  "description": "Introducing VS Code settings and extensions that boost development productivity.",
  "date": "August 2, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Development Tools",
  "tags": "VS Code, Development Environment, Productivity, Extensions",
  "content":"For developers, the editor is one of the most important tools. Today, I\u0026rsquo;d like to share ways to use VS Code more efficiently.\nEssential Extensions 1. Code Quality Management ESLint: JavaScript/TypeScript code quality management Prettier: Automatic code formatting SonarLint: Real-time code analysis 2. Development Productivity GitLens: Enhanced Git functionality Live Server: Real-time web page preview Auto Rename Tag: Automatic HTML tag renaming 3. Language Support Python: Python development support Go: Go language support Docker: Container development support Useful Settings Auto-save and Formatting { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.formatOnPaste\u0026#34;: true, \u0026#34;files.autoSave\u0026#34;: \u0026#34;afterDelay\u0026#34; } Editor Improvements { \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.lineHeight\u0026#34;: 1.5, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Fira Code\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true } Keyboard Shortcut Customization Set up shortcuts for quick access to frequently used features:\nCtrl+Shift+P: Command Palette Ctrl+`: Toggle Terminal Alt+Up/Down: Move Line Theme Recommendations Eye-friendly themes for comfortable development:\nOne Dark Pro: Popular dark theme Material Theme: Google Material Design Dracula: Elegant dark theme Conclusion The power of VS Code lies in its extensibility. Customize it to fit your development style and boost your productivity!\nWhat VS Code tips or extensions would you recommend? Please share in the comments! 🚀\n"},{
  "section": "Blog",
  "slug": "/en/blog/react-hooks-guide/",
  "title": "React Functional Components and Hooks Guide",
  "description": "Learn how to use React functional components and essential Hooks with practical examples.",
  "date": "August 1, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Web Development",
  "tags": "React, Hooks, JavaScript, Frontend",
  "content":"React Hooks, introduced in React 16.8, enable state management and lifecycle features in functional components. Let\u0026rsquo;s explore the essential Hooks and their usage.\nuseState - State Management The most basic Hook for managing state in functional components.\nimport React, { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Increment \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count - 1)}\u0026gt; Decrement \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(0)}\u0026gt; Reset \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } // Managing object state function UserProfile() { const [user, setUser] = useState({ name: \u0026#39;\u0026#39;, email: \u0026#39;\u0026#39;, age: 0 }); const updateUser = (field, value) =\u0026gt; { setUser(prevUser =\u0026gt; ({ ...prevUser, [field]: value })); }; return ( \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Name\u0026#34; value={user.name} onChange={(e) =\u0026gt; updateUser(\u0026#39;name\u0026#39;, e.target.value)} /\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; placeholder=\u0026#34;Email\u0026#34; value={user.email} onChange={(e) =\u0026gt; updateUser(\u0026#39;email\u0026#39;, e.target.value)} /\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; placeholder=\u0026#34;Age\u0026#34; value={user.age} onChange={(e) =\u0026gt; updateUser(\u0026#39;age\u0026#39;, parseInt(e.target.value))} /\u0026gt; \u0026lt;/form\u0026gt; ); } useEffect - Side Effects Handle side effects like data fetching, subscriptions, or manual DOM manipulation.\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; function UserList() { const [users, setUsers] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); // Effect without dependencies - runs on every render useEffect(() =\u0026gt; { console.log(\u0026#39;Component rendered\u0026#39;); }); // Effect with empty dependency array - runs once on mount useEffect(() =\u0026gt; { fetchUsers(); }, []); // Effect with dependencies - runs when dependencies change useEffect(() =\u0026gt; { document.title = `${users.length} users loaded`; }, [users.length]); // Effect with cleanup useEffect(() =\u0026gt; { const timer = setInterval(() =\u0026gt; { console.log(\u0026#39;Timer tick\u0026#39;); }, 1000); // Cleanup function return () =\u0026gt; { clearInterval(timer); }; }, []); const fetchUsers = async () =\u0026gt; { try { setLoading(true); const response = await fetch(\u0026#39;/api/users\u0026#39;); const userData = await response.json(); setUsers(userData); } catch (err) { setError(err.message); } finally { setLoading(false); } }; if (loading) return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; if (error) return \u0026lt;div\u0026gt;Error: {error}\u0026lt;/div\u0026gt;; return ( \u0026lt;ul\u0026gt; {users.map(user =\u0026gt; ( \u0026lt;li key={user.id}\u0026gt;{user.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ); } useContext - Context API Share data across components without prop drilling.\nimport React, { createContext, useContext, useState } from \u0026#39;react\u0026#39;; // Create context const AuthContext = createContext(); // Provider component function AuthProvider({ children }) { const [user, setUser] = useState(null); const [isLoggedIn, setIsLoggedIn] = useState(false); const login = async (credentials) =\u0026gt; { try { const response = await fetch(\u0026#39;/api/login\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(credentials) }); const userData = await response.json(); setUser(userData); setIsLoggedIn(true); } catch (error) { console.error(\u0026#39;Login failed:\u0026#39;, error); } }; const logout = () =\u0026gt; { setUser(null); setIsLoggedIn(false); }; const value = { user, isLoggedIn, login, logout }; return ( \u0026lt;AuthContext.Provider value={value}\u0026gt; {children} \u0026lt;/AuthContext.Provider\u0026gt; ); } // Custom hook for using auth context function useAuth() { const context = useContext(AuthContext); if (!context) { throw new Error(\u0026#39;useAuth must be used within AuthProvider\u0026#39;); } return context; } // Using the context function LoginButton() { const { isLoggedIn, login, logout, user } = useAuth(); if (isLoggedIn) { return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;Welcome, {user.name}!\u0026lt;/span\u0026gt; \u0026lt;button onClick={logout}\u0026gt;Logout\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } return ( \u0026lt;button onClick={() =\u0026gt; login({ email: \u0026#39;user@example.com\u0026#39;, password: \u0026#39;password\u0026#39; })}\u0026gt; Login \u0026lt;/button\u0026gt; ); } useReducer - Complex State Management An alternative to useState for more complex state logic.\nimport React, { useReducer } from \u0026#39;react\u0026#39;; // Reducer function function todoReducer(state, action) { switch (action.type) { case \u0026#39;ADD_TODO\u0026#39;: return { ...state, todos: [...state.todos, { id: Date.now(), text: action.payload, completed: false }] }; case \u0026#39;TOGGLE_TODO\u0026#39;: return { ...state, todos: state.todos.map(todo =\u0026gt; todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo ) }; case \u0026#39;DELETE_TODO\u0026#39;: return { ...state, todos: state.todos.filter(todo =\u0026gt; todo.id !== action.payload) }; case \u0026#39;SET_FILTER\u0026#39;: return { ...state, filter: action.payload }; default: return state; } } function TodoApp() { const initialState = { todos: [], filter: \u0026#39;all\u0026#39; // \u0026#39;all\u0026#39;, \u0026#39;active\u0026#39;, \u0026#39;completed\u0026#39; }; const [state, dispatch] = useReducer(todoReducer, initialState); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); const addTodo = () =\u0026gt; { if (inputValue.trim()) { dispatch({ type: \u0026#39;ADD_TODO\u0026#39;, payload: inputValue }); setInputValue(\u0026#39;\u0026#39;); } }; const filteredTodos = state.todos.filter(todo =\u0026gt; { if (state.filter === \u0026#39;active\u0026#39;) return !todo.completed; if (state.filter === \u0026#39;completed\u0026#39;) return todo.completed; return true; }); return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input value={inputValue} onChange={(e) =\u0026gt; setInputValue(e.target.value)} onKeyPress={(e) =\u0026gt; e.key === \u0026#39;Enter\u0026#39; \u0026amp;\u0026amp; addTodo()} placeholder=\u0026#34;Add a todo...\u0026#34; /\u0026gt; \u0026lt;button onClick={addTodo}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;SET_FILTER\u0026#39;, payload: \u0026#39;all\u0026#39; })} style={{ fontWeight: state.filter === \u0026#39;all\u0026#39; ? \u0026#39;bold\u0026#39; : \u0026#39;normal\u0026#39; }} \u0026gt; All \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;SET_FILTER\u0026#39;, payload: \u0026#39;active\u0026#39; })} style={{ fontWeight: state.filter === \u0026#39;active\u0026#39; ? \u0026#39;bold\u0026#39; : \u0026#39;normal\u0026#39; }} \u0026gt; Active \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;SET_FILTER\u0026#39;, payload: \u0026#39;completed\u0026#39; })} style={{ fontWeight: state.filter === \u0026#39;completed\u0026#39; ? \u0026#39;bold\u0026#39; : \u0026#39;normal\u0026#39; }} \u0026gt; Completed \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ul\u0026gt; {filteredTodos.map(todo =\u0026gt; ( \u0026lt;li key={todo.id}\u0026gt; \u0026lt;span style={{ textDecoration: todo.completed ? \u0026#39;line-through\u0026#39; : \u0026#39;none\u0026#39;, cursor: \u0026#39;pointer\u0026#39; }} onClick={() =\u0026gt; dispatch({ type: \u0026#39;TOGGLE_TODO\u0026#39;, payload: todo.id })} \u0026gt; {todo.text} \u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;DELETE_TODO\u0026#39;, payload: todo.id })}\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } useMemo - Performance Optimization Memoize expensive calculations.\nimport React, { useState, useMemo } from \u0026#39;react\u0026#39;; function ExpensiveComponent() { const [count, setCount] = useState(0); const [items, setItems] = useState([]); // Expensive calculation const expensiveValue = useMemo(() =\u0026gt; { console.log(\u0026#39;Calculating expensive value...\u0026#39;); let result = 0; for (let i = 0; i \u0026lt; 1000000; i++) { result += i; } return result; }, [count]); // Only recalculate when count changes // Memoized filtered items const expensiveItems = useMemo(() =\u0026gt; { console.log(\u0026#39;Filtering items...\u0026#39;); return items.filter(item =\u0026gt; item.value \u0026gt; 50); }, [items]); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Expensive Value: {expensiveValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Filtered Items: {expensiveItems.length}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; Increment Count \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setItems([...items, { value: Math.random() * 100 }])}\u0026gt; Add Random Item \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } useCallback - Function Memoization Memoize functions to prevent unnecessary re-renders.\nimport React, { useState, useCallback, memo } from \u0026#39;react\u0026#39;; // Child component that might re-render unnecessarily const TodoItem = memo(({ todo, onToggle, onDelete }) =\u0026gt; { console.log(`Rendering TodoItem ${todo.id}`); return ( \u0026lt;li\u0026gt; \u0026lt;span style={{ textDecoration: todo.completed ? \u0026#39;line-through\u0026#39; : \u0026#39;none\u0026#39; }} onClick={() =\u0026gt; onToggle(todo.id)} \u0026gt; {todo.text} \u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; onDelete(todo.id)}\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ); }); function TodoList() { const [todos, setTodos] = useState([]); const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;); // Memoized callback functions const handleToggle = useCallback((id) =\u0026gt; { setTodos(prevTodos =\u0026gt; prevTodos.map(todo =\u0026gt; todo.id === id ? { ...todo, completed: !todo.completed } : todo ) ); }, []); // Empty dependency array since setTodos is stable const handleDelete = useCallback((id) =\u0026gt; { setTodos(prevTodos =\u0026gt; prevTodos.filter(todo =\u0026gt; todo.id !== id)); }, []); const addTodo = useCallback(() =\u0026gt; { if (inputValue.trim()) { setTodos(prevTodos =\u0026gt; [...prevTodos, { id: Date.now(), text: inputValue, completed: false }]); setInputValue(\u0026#39;\u0026#39;); } }, [inputValue]); return ( \u0026lt;div\u0026gt; \u0026lt;input value={inputValue} onChange={(e) =\u0026gt; setInputValue(e.target.value)} onKeyPress={(e) =\u0026gt; e.key === \u0026#39;Enter\u0026#39; \u0026amp;\u0026amp; addTodo()} /\u0026gt; \u0026lt;button onClick={addTodo}\u0026gt;Add Todo\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {todos.map(todo =\u0026gt; ( \u0026lt;TodoItem key={todo.id} todo={todo} onToggle={handleToggle} onDelete={handleDelete} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } useRef - DOM References and Mutable Values Access DOM elements and store mutable values.\nimport React, { useRef, useEffect, useState } from \u0026#39;react\u0026#39;; function FocusInput() { const inputRef = useRef(null); const countRef = useRef(0); const [renderCount, setRenderCount] = useState(0); useEffect(() =\u0026gt; { // Focus input on mount inputRef.current.focus(); }, []); useEffect(() =\u0026gt; { // Update ref value without causing re-render countRef.current += 1; }); const handleClick = () =\u0026gt; { // Access DOM element inputRef.current.focus(); inputRef.current.select(); // Log ref value console.log(`Component rendered ${countRef.current} times`); }; return ( \u0026lt;div\u0026gt; \u0026lt;input ref={inputRef} type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Click button to focus\u0026#34; /\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Focus Input\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setRenderCount(renderCount + 1)}\u0026gt; Force Re-render ({renderCount}) \u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Render count stored in ref: {countRef.current}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } Custom Hooks Create reusable stateful logic.\nimport { useState, useEffect } from \u0026#39;react\u0026#39;; // Custom hook for API data fetching function useApi(url) { const [data, setData] = useState(null); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); useEffect(() =\u0026gt; { const fetchData = async () =\u0026gt; { try { setLoading(true); const response = await fetch(url); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const result = await response.json(); setData(result); } catch (err) { setError(err.message); } finally { setLoading(false); } }; fetchData(); }, [url]); return { data, loading, error }; } // Custom hook for local storage function useLocalStorage(key, initialValue) { const [storedValue, setStoredValue] = useState(() =\u0026gt; { try { const item = window.localStorage.getItem(key); return item ? JSON.parse(item) : initialValue; } catch (error) { console.error(`Error reading localStorage key \u0026#34;${key}\u0026#34;:`, error); return initialValue; } }); const setValue = (value) =\u0026gt; { try { setStoredValue(value); window.localStorage.setItem(key, JSON.stringify(value)); } catch (error) { console.error(`Error setting localStorage key \u0026#34;${key}\u0026#34;:`, error); } }; return [storedValue, setValue]; } // Using custom hooks function UserProfile() { const { data: user, loading, error } = useApi(\u0026#39;/api/user/profile\u0026#39;); const [preferences, setPreferences] = useLocalStorage(\u0026#39;userPreferences\u0026#39;, { theme: \u0026#39;light\u0026#39;, language: \u0026#39;en\u0026#39; }); if (loading) return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; if (error) return \u0026lt;div\u0026gt;Error: {error}\u0026lt;/div\u0026gt;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Welcome, {user.name}!\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; Theme: \u0026lt;select value={preferences.theme} onChange={(e) =\u0026gt; setPreferences({ ...preferences, theme: e.target.value })} \u0026gt; \u0026lt;option value=\u0026#34;light\u0026#34;\u0026gt;Light\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;dark\u0026#34;\u0026gt;Dark\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } Best Practices 1. Rules of Hooks Only call Hooks at the top level Only call Hooks from React functions Use ESLint plugin to enforce rules 2. Dependency Arrays // Good: Include all dependencies useEffect(() =\u0026gt; { fetchUser(userId); }, [userId]); // Bad: Missing dependencies useEffect(() =\u0026gt; { fetchUser(userId); // userId is used but not in dependencies }, []); // Good: Use callback if you need to avoid dependencies const fetchUser = useCallback(async (id) =\u0026gt; { const response = await fetch(`/api/users/${id}`); setUser(await response.json()); }, []); useEffect(() =\u0026gt; { fetchUser(userId); }, [userId, fetchUser]); 3. Performance Optimization // Use memo for expensive child components const ExpensiveChild = memo(({ data, onUpdate }) =\u0026gt; { // Expensive rendering logic return \u0026lt;div\u0026gt;{/* Complex UI */}\u0026lt;/div\u0026gt;; }); // Use useMemo for expensive calculations const expensiveValue = useMemo(() =\u0026gt; { return heavyCalculation(data); }, [data]); // Use useCallback for event handlers passed to children const handleClick = useCallback((id) =\u0026gt; { // Handle click }, []); Conclusion React Hooks provide a powerful and flexible way to build components. Start with useState and useEffect, then gradually incorporate other Hooks as needed. Custom Hooks are particularly useful for sharing logic between components.\nIn the next post, we\u0026rsquo;ll explore advanced React patterns and state management with Redux Toolkit.\n"},{
  "section": "Blog",
  "slug": "/en/blog/git-branching-strategy/",
  "title": "Git Branching Strategies and Collaboration Workflows",
  "description": "Learn effective Git branching strategies and workflows for team collaboration and version control.",
  "date": "July 31, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Development Tools",
  "tags": "Git, Branching Strategy, Collaboration, Version Control",
  "content":"Using Git effectively in team development is crucial for project success. Let\u0026rsquo;s explore popular Git branching strategies and collaboration workflows.\nGit Flow Strategy Git Flow is one of the most widely used branching strategies.\nBranch Structure main: Released stable code develop: Integration branch for development feature: New feature development release: Release preparation hotfix: Emergency bug fixes # Initialize Git Flow git flow init # Start a new feature git flow feature start user-authentication # Finish a feature git flow feature finish user-authentication # Start a release git flow release start v1.2.0 # Finish a release git flow release finish v1.2.0 # Start a hotfix git flow hotfix start critical-bug # Finish a hotfix git flow hotfix finish critical-bug Workflow Example # Developer A starts working on a new feature git checkout develop git pull origin develop git flow feature start shopping-cart # Make changes and commit git add . git commit -m \u0026#34;Add shopping cart functionality\u0026#34; # Push feature branch git push origin feature/shopping-cart # Finish feature (merges to develop) git flow feature finish shopping-cart # Prepare for release git flow release start v2.1.0 # Make final adjustments git commit -m \u0026#34;Update version number\u0026#34; # Finish release (merges to main and develop) git flow release finish v2.1.0 git push origin main git push origin develop git push --tags GitHub Flow Strategy A simpler strategy ideal for continuous deployment.\nWorkflow Create branch from main Add commits Open Pull Request Discuss and review Deploy and test Merge to main # Create and switch to new branch git checkout -b feature/user-profile git push -u origin feature/user-profile # Make changes and commit git add . git commit -m \u0026#34;Add user profile page\u0026#34; git push origin feature/user-profile # Create Pull Request on GitHub # After review and approval, merge to main git checkout main git pull origin main git branch -d feature/user-profile GitLab Flow Strategy Combines benefits of Git Flow and GitHub Flow with environment branches.\nBranch Structure main: Production code pre-production: Staging environment feature branches: Feature development # Feature development git checkout -b feature/payment-integration main # Development work git add . git commit -m \u0026#34;Implement payment gateway\u0026#34; git push origin feature/payment-integration # Merge to pre-production for testing git checkout pre-production git merge feature/payment-integration git push origin pre-production # After testing, merge to main git checkout main git merge pre-production git push origin main Feature Branch Workflow Simple workflow focusing on feature isolation.\n# Create feature branch git checkout -b feature/search-functionality # Work on feature echo \u0026#34;Search component\u0026#34; \u0026gt; search.js git add search.js git commit -m \u0026#34;Add search functionality\u0026#34; # Push and create pull request git push origin feature/search-functionality # After review, merge via Pull Request # Clean up git checkout main git pull origin main git branch -d feature/search-functionality git push origin --delete feature/search-functionality Advanced Git Techniques Interactive Rebase Clean up commit history before merging:\n# Interactive rebase last 3 commits git rebase -i HEAD~3 # Rebase options: # pick = use commit # reword = edit commit message # edit = edit commit # squash = combine with previous commit # drop = remove commit # Example rebase file: pick abc123 Add login feature squash def456 Fix login bug reword ghi789 Add tests Cherry Pick Apply specific commits to another branch:\n# Apply commit to current branch git cherry-pick abc123 # Apply multiple commits git cherry-pick abc123 def456 # Apply commit without committing git cherry-pick --no-commit abc123 Stashing Temporarily save changes:\n# Stash current changes git stash # Stash with message git stash push -m \u0026#34;Work in progress on feature X\u0026#34; # List stashes git stash list # Apply latest stash git stash pop # Apply specific stash git stash apply stash@{1} # Drop stash git stash drop stash@{0} Conflict Resolution Merge Conflicts # When merge conflicts occur git status # Edit conflicted files # \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD # Your changes # ======= # Their changes # \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; branch-name # After resolving conflicts git add conflicted-file.js git commit -m \u0026#34;Resolve merge conflict\u0026#34; Using Merge Tools # Configure merge tool git config --global merge.tool vimdiff # Use merge tool for conflicts git mergetool # Popular merge tools: # - VS Code: code --wait # - Sublime: subl --wait # - Atom: atom --wait Team Collaboration Best Practices Commit Message Conventions # Conventional Commits format \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;description\u0026gt; [optional body] [optional footer] # Examples: git commit -m \u0026#34;feat(auth): add user authentication\u0026#34; git commit -m \u0026#34;fix(api): resolve null pointer exception\u0026#34; git commit -m \u0026#34;docs(readme): update installation instructions\u0026#34; # Types: # feat: new feature # fix: bug fix # docs: documentation # style: formatting # refactor: code restructuring # test: adding tests # chore: maintenance Pull Request Guidelines ## Pull Request Template ### Description Brief description of changes ### Type of Change - [ ] Bug fix - [ ] New feature - [ ] Breaking change - [ ] Documentation update ### Testing - [ ] Unit tests pass - [ ] Integration tests pass - [ ] Manual testing completed ### Checklist - [ ] Code follows style guidelines - [ ] Self-review completed - [ ] Comments added for complex logic - [ ] Documentation updated Code Review Process # Reviewer checks out PR branch git fetch origin git checkout feature/new-feature # Run tests npm test # Review changes git diff main...feature/new-feature # Add review comments via GitHub/GitLab # Request changes or approve Automation and CI/CD Integration GitHub Actions Workflow # .github/workflows/ci.yml name: CI/CD Pipeline on: push: branches: [ main, develop ] pull_request: branches: [ main ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v2 with: node-version: \u0026#39;16\u0026#39; - name: Install dependencies run: npm ci - name: Run tests run: npm test - name: Run linting run: npm run lint - name: Build application run: npm run build deploy: needs: test runs-on: ubuntu-latest if: github.ref == \u0026#39;refs/heads/main\u0026#39; steps: - name: Deploy to production run: echo \u0026#34;Deploying to production...\u0026#34; Husky Pre-commit Hooks // package.json { \u0026#34;husky\u0026#34;: { \u0026#34;hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;lint-staged\u0026#34;, \u0026#34;commit-msg\u0026#34;: \u0026#34;commitlint -E HUSKY_GIT_PARAMS\u0026#34; } }, \u0026#34;lint-staged\u0026#34;: { \u0026#34;*.{js,jsx,ts,tsx}\u0026#34;: [ \u0026#34;eslint --fix\u0026#34;, \u0026#34;prettier --write\u0026#34;, \u0026#34;git add\u0026#34; ] } } Branch Protection Rules Protect important branches with rules:\n# GitHub CLI example gh api repos/:owner/:repo/branches/main/protection \\ --method PUT \\ --field required_status_checks=\u0026#39;{\u0026#34;strict\u0026#34;:true,\u0026#34;contexts\u0026#34;:[\u0026#34;ci/tests\u0026#34;]}\u0026#39; \\ --field enforce_admins=true \\ --field required_pull_request_reviews=\u0026#39;{\u0026#34;required_approving_review_count\u0026#34;:2}\u0026#39; \\ --field restrictions=null Release Management Semantic Versioning # Version format: MAJOR.MINOR.PATCH # 1.0.0 → 1.0.1 (patch: bug fix) # 1.0.1 → 1.1.0 (minor: new feature) # 1.1.0 → 2.0.0 (major: breaking change) # Using npm version npm version patch # 1.0.0 → 1.0.1 npm version minor # 1.0.1 → 1.1.0 npm version major # 1.1.0 → 2.0.0 Automated Releases # .github/workflows/release.yml name: Release on: push: tags: - \u0026#39;v*\u0026#39; jobs: release: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Create Release uses: actions/create-release@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ github.ref }} release_name: Release ${{ github.ref }} draft: false prerelease: false Troubleshooting Common Issues Undo Last Commit # Undo last commit (keep changes) git reset HEAD~1 # Undo last commit (discard changes) git reset --hard HEAD~1 # Undo commit that was already pushed git revert HEAD Clean Working Directory # Remove untracked files git clean -fd # Remove ignored files git clean -fX # Remove all untracked and ignored files git clean -fx Recover Lost Commits # Show reflog git reflog # Recover lost commit git checkout \u0026lt;commit-hash\u0026gt; git checkout -b recovered-branch Choosing the Right Strategy Git Flow Best for: Traditional release cycles Team size: Medium to large Release frequency: Scheduled releases GitHub Flow Best for: Continuous deployment Team size: Small to medium Release frequency: Frequent deployments GitLab Flow Best for: Multiple environments Team size: Any size Release frequency: Regular releases with staging Conclusion Choose a branching strategy that fits your team size, release cycle, and deployment process. Start simple and evolve your workflow as the team grows. Consistency and clear guidelines are more important than the perfect strategy.\nIn the next post, we\u0026rsquo;ll explore advanced Git hooks and automation techniques for maintaining code quality.\n"},{
  "section": "Blog",
  "slug": "/en/blog/docker-development-environment/",
  "title": "Building Development Environment with Docker",
  "description": "Learn how to build consistent development environments using Docker and container-based development workflows.",
  "date": "July 30, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "DevOps, Container",
  "tags": "Docker, DevOps, Container, Development Environment",
  "content":"During development, you often hear \u0026ldquo;It worked on my machine!\u0026rdquo; Docker can solve this problem and help build consistent development environments.\nWhat is Docker? Docker is a container-based virtualization platform. You can package applications and everything needed to run them into a single container.\nAdvantages of Docker Consistency: Same environment anywhere Isolation: Each container runs independently Portability: Can run on any platform Efficiency: Lighter than virtual machines Basic Docker Commands Image Management # Search for images docker search nginx # Pull images docker pull nginx:latest # List images docker images # Remove images docker rmi nginx:latest Container Management # Run container docker run -d --name web-server -p 8080:80 nginx # List containers docker ps -a # Stop container docker stop web-server # Start container docker start web-server # Remove container docker rm web-server Dockerfile Create custom images using Dockerfile:\n# Base image FROM node:18-alpine # Set working directory WORKDIR /app # Copy package files COPY package*.json ./ # Install dependencies RUN npm install # Copy source code COPY . . # Expose port EXPOSE 3000 # Start command CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] Docker Compose Manage multi-container applications:\nversion: \u0026#39;3.8\u0026#39; services: web: build: . ports: - \u0026#34;3000:3000\u0026#34; environment: - NODE_ENV=development volumes: - .:/app - /app/node_modules depends_on: - database database: image: postgres:14 environment: POSTGRES_DB: myapp POSTGRES_USER: user POSTGRES_PASSWORD: password volumes: - postgres_data:/var/lib/postgresql/data ports: - \u0026#34;5432:5432\u0026#34; volumes: postgres_data: Development Environment Setup 1. Node.js Project # Create project directory mkdir my-node-app \u0026amp;\u0026amp; cd my-node-app # Create Dockerfile cat \u0026gt; Dockerfile \u0026lt;\u0026lt; EOF FROM node:18-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . EXPOSE 3000 CMD [\u0026#34;npm\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;dev\u0026#34;] EOF # Create docker-compose.yml cat \u0026gt; docker-compose.yml \u0026lt;\u0026lt; EOF version: \u0026#39;3.8\u0026#39; services: app: build: . ports: - \u0026#34;3000:3000\u0026#34; volumes: - .:/app - /app/node_modules environment: - NODE_ENV=development EOF # Start development environment docker-compose up 2. Java Spring Boot Project FROM openjdk:17-jdk-slim WORKDIR /app COPY pom.xml . COPY .mvn .mvn COPY mvnw . RUN chmod +x mvnw \u0026amp;\u0026amp; ./mvnw dependency:go-offline COPY src ./src EXPOSE 8080 CMD [\u0026#34;./mvnw\u0026#34;, \u0026#34;spring-boot:run\u0026#34;] Best Practices 1. .dockerignore node_modules npm-debug.log .git .gitignore README.md .env .nyc_output coverage .tmp 2. Multi-stage Build # Build stage FROM node:18-alpine AS builder WORKDIR /app COPY package*.json ./ RUN npm ci --only=production # Production stage FROM node:18-alpine WORKDIR /app COPY --from=builder /app/node_modules ./node_modules COPY . . EXPOSE 3000 CMD [\u0026#34;node\u0026#34;, \u0026#34;server.js\u0026#34;] 3. Health Checks HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\ CMD curl -f http://localhost:3000/health || exit 1 Development Workflow 1. Code → Build → Test → Deploy # Build image docker build -t myapp:latest . # Run tests docker run --rm myapp:latest npm test # Deploy to staging docker run -d --name staging-app -p 3001:3000 myapp:latest 2. CI/CD Pipeline # .github/workflows/docker.yml name: Docker Build and Deploy on: push: branches: [ main ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Build Docker image run: docker build -t myapp . - name: Run tests run: docker run --rm myapp npm test - name: Deploy to production run: | docker tag myapp myregistry/myapp:latest docker push myregistry/myapp:latest Troubleshooting Common Issues Port conflicts\n# Check port usage lsof -i :3000 # Use different port docker run -p 3001:3000 myapp Volume mount issues\n# Check volume mounts docker inspect container_name # Fix permissions docker run --user $(id -u):$(id -g) myapp Network issues\n# Create custom network docker network create mynetwork # Run containers on same network docker run --network mynetwork myapp Conclusion Docker greatly improves development productivity by providing consistent environments. Start with simple Dockerfile and docker-compose.yml files, then gradually adopt more advanced features.\nIn the next post, we\u0026rsquo;ll explore Kubernetes orchestration and container deployment strategies.\n"},{
  "section": "Blog",
  "slug": "/en/blog/javascript-es6-features/",
  "title": "Essential JavaScript ES6+ Features",
  "description": "Explore core features of modern JavaScript with examples and learn how to use them in real-world projects.",
  "date": "July 29, 2025",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "JavaScript, Frontend",
  "tags": "JavaScript, ES6, Modern JavaScript, Frontend",
  "content":"JavaScript ES6 (ECMAScript 2015) introduced many new features. Let\u0026rsquo;s explore the essential features commonly used in real-world development.\n1. let and const Use let and const with block scope instead of var.\n// Problem with var for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 3, 3, 3 } // Solution with let for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 0, 1, 2 } // const for constants const API_URL = \u0026#39;https://api.example.com\u0026#39;; const config = { timeout: 5000, retries: 3 }; 2. Arrow Functions Concise function syntax with lexical this binding.\n// Traditional function function add(a, b) { return a + b; } // Arrow function const add = (a, b) =\u0026gt; a + b; // With single parameter const square = x =\u0026gt; x * x; // With multiple statements const processData = (data) =\u0026gt; { const processed = data.map(item =\u0026gt; item.value); return processed.filter(value =\u0026gt; value \u0026gt; 0); }; // Lexical this binding class Timer { constructor() { this.seconds = 0; } start() { // Arrow function preserves \u0026#39;this\u0026#39; setInterval(() =\u0026gt; { this.seconds++; console.log(this.seconds); }, 1000); } } 3. Template Literals String interpolation and multi-line strings.\nconst name = \u0026#39;John\u0026#39;; const age = 30; // String interpolation const message = `Hello, ${name}! You are ${age} years old.`; // Multi-line strings const html = ` \u0026lt;div class=\u0026#34;user-card\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // Expression evaluation const price = 19.99; const tax = 0.08; const total = `Total: $${(price * (1 + tax)).toFixed(2)}`; 4. Destructuring Assignment Extract values from arrays and objects.\n// Array destructuring const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(rest); // [3, 4, 5] // Object destructuring const user = { name: \u0026#39;Alice\u0026#39;, email: \u0026#39;alice@example.com\u0026#39;, age: 25 }; const { name, email } = user; console.log(name); // \u0026#39;Alice\u0026#39; // Destructuring with default values const { name: userName, country = \u0026#39;Unknown\u0026#39; } = user; // Function parameter destructuring function createUser({ name, email, age = 18 }) { return { id: Date.now(), name, email, age }; } 5. Spread and Rest Operators Spread arrays/objects and collect function parameters.\n// Spread operator with arrays const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // Spread operator with objects const defaults = { theme: \u0026#39;dark\u0026#39;, language: \u0026#39;en\u0026#39; }; const userPrefs = { language: \u0026#39;ko\u0026#39;, fontSize: 14 }; const settings = { ...defaults, ...userPrefs }; // { theme: \u0026#39;dark\u0026#39;, language: \u0026#39;ko\u0026#39;, fontSize: 14 } // Rest parameters function sum(...numbers) { return numbers.reduce((total, num) =\u0026gt; total + num, 0); } sum(1, 2, 3, 4); // 10 6. Enhanced Object Literals Concise property and method definitions.\nconst name = \u0026#39;Product\u0026#39;; const price = 29.99; // Shorthand property names const product = { name, // instead of name: name price, // instead of price: price // Method shorthand getDetails() { // instead of getDetails: function() return `${this.name}: $${this.price}`; }, // Computed property names [`${name.toLowerCase()}_id`]: 12345 }; 7. Classes Class-based object-oriented programming.\nclass Vehicle { constructor(make, model) { this.make = make; this.model = model; } getInfo() { return `${this.make} ${this.model}`; } // Static method static compare(v1, v2) { return v1.make === v2.make; } } class Car extends Vehicle { constructor(make, model, doors) { super(make, model); this.doors = doors; } getDetails() { return `${this.getInfo()} with ${this.doors} doors`; } } const myCar = new Car(\u0026#39;Toyota\u0026#39;, \u0026#39;Camry\u0026#39;, 4); console.log(myCar.getDetails()); // Toyota Camry with 4 doors 8. Modules Import and export functionality between files.\n// math.js export const PI = 3.14159; export function add(a, b) { return a + b; } export function multiply(a, b) { return a * b; } // Default export export default function subtract(a, b) { return a - b; } // main.js import subtract, { PI, add, multiply } from \u0026#39;./math.js\u0026#39;; console.log(PI); // 3.14159 console.log(add(2, 3)); // 5 console.log(subtract(5, 2)); // 3 9. Promises and Async/Await Handle asynchronous operations.\n// Promise function fetchUser(id) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { if (id \u0026gt; 0) { resolve({ id, name: `User ${id}` }); } else { reject(new Error(\u0026#39;Invalid user ID\u0026#39;)); } }, 1000); }); } // Using Promise fetchUser(1) .then(user =\u0026gt; console.log(user)) .catch(error =\u0026gt; console.error(error)); // Using async/await async function getUser(id) { try { const user = await fetchUser(id); console.log(user); return user; } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error.message); } } 10. Array Methods Powerful array manipulation methods.\nconst numbers = [1, 2, 3, 4, 5]; // map - transform elements const doubled = numbers.map(n =\u0026gt; n * 2); // [2, 4, 6, 8, 10] // filter - select elements const evens = numbers.filter(n =\u0026gt; n % 2 === 0); // [2, 4] // reduce - accumulate values const sum = numbers.reduce((total, n) =\u0026gt; total + n, 0); // 15 // find - find first match const found = numbers.find(n =\u0026gt; n \u0026gt; 3); // 4 // some/every - test conditions const hasEven = numbers.some(n =\u0026gt; n % 2 === 0); // true const allPositive = numbers.every(n =\u0026gt; n \u0026gt; 0); // true 11. Set and Map New collection types.\n// Set - unique values const uniqueNumbers = new Set([1, 2, 2, 3, 3, 4]); console.log(uniqueNumbers); // Set {1, 2, 3, 4} uniqueNumbers.add(5); uniqueNumbers.delete(1); console.log(uniqueNumbers.has(2)); // true // Map - key-value pairs const userRoles = new Map(); userRoles.set(\u0026#39;john\u0026#39;, \u0026#39;admin\u0026#39;); userRoles.set(\u0026#39;alice\u0026#39;, \u0026#39;user\u0026#39;); userRoles.set(\u0026#39;bob\u0026#39;, \u0026#39;moderator\u0026#39;); console.log(userRoles.get(\u0026#39;john\u0026#39;)); // \u0026#39;admin\u0026#39; console.log(userRoles.size); // 3 // Iterating for (const [user, role] of userRoles) { console.log(`${user}: ${role}`); } 12. Default Parameters Set default values for function parameters.\nfunction createUser(name, role = \u0026#39;user\u0026#39;, active = true) { return { name, role, active, createdAt: new Date() }; } const user1 = createUser(\u0026#39;John\u0026#39;); // { name: \u0026#39;John\u0026#39;, role: \u0026#39;user\u0026#39;, active: true, createdAt: ... } const user2 = createUser(\u0026#39;Alice\u0026#39;, \u0026#39;admin\u0026#39;, false); // { name: \u0026#39;Alice\u0026#39;, role: \u0026#39;admin\u0026#39;, active: false, createdAt: ... } Real-World Example Putting it all together in a practical example:\nclass TodoManager { constructor() { this.todos = new Map(); this.nextId = 1; } addTodo(text, priority = \u0026#39;medium\u0026#39;) { const todo = { id: this.nextId++, text, priority, completed: false, createdAt: new Date() }; this.todos.set(todo.id, todo); return todo; } async saveTodos() { const todosArray = [...this.todos.values()]; try { const response = await fetch(\u0026#39;/api/todos\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(todosArray) }); if (!response.ok) { throw new Error(\u0026#39;Failed to save todos\u0026#39;); } return await response.json(); } catch (error) { console.error(\u0026#39;Save failed:\u0026#39;, error); throw error; } } getFilteredTodos({ completed, priority } = {}) { return [...this.todos.values()] .filter(todo =\u0026gt; { if (completed !== undefined \u0026amp;\u0026amp; todo.completed !== completed) { return false; } if (priority \u0026amp;\u0026amp; todo.priority !== priority) { return false; } return true; }) .sort((a, b) =\u0026gt; b.createdAt - a.createdAt); } } // Usage const todoManager = new TodoManager(); todoManager.addTodo(\u0026#39;Learn ES6+\u0026#39;, \u0026#39;high\u0026#39;); todoManager.addTodo(\u0026#39;Build a project\u0026#39;); todoManager.addTodo(\u0026#39;Write documentation\u0026#39;, \u0026#39;low\u0026#39;); const highPriorityTodos = todoManager.getFilteredTodos({ priority: \u0026#39;high\u0026#39; }); console.log(highPriorityTodos); Conclusion These ES6+ features make JavaScript more expressive and powerful. Start incorporating them into your projects gradually, focusing on the ones that provide the most immediate benefit to your coding style.\nIn the next post, we\u0026rsquo;ll explore React Hooks and modern React development patterns.\n"},{
  "section": "Blog",
  "slug": "/en/blog/post-4/",
  "title": "REST API Design Best Practices",
  "description": "Learn essential REST API design principles and best practices for building maintainable and scalable web services.",
  "date": "April 7, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, API Design",
  "tags": "REST API, API Design, Web Services, Backend, HTTP",
  "content":"Well-designed REST APIs are crucial for building maintainable and scalable applications. Let\u0026rsquo;s explore the essential principles and best practices for creating robust APIs.\nREST Principles 1. Resource-Based URLs Use nouns to represent resources, not verbs:\n✅ Good GET /api/users GET /api/users/123 POST /api/users PUT /api/users/123 DELETE /api/users/123 ❌ Bad GET /api/getUsers GET /api/getUserById/123 POST /api/createUser PUT /api/updateUser/123 DELETE /api/deleteUser/123 2. HTTP Methods Use appropriate HTTP methods for different operations:\n@RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { // GET - Retrieve resources @GetMapping public ResponseEntity\u0026lt;Page\u0026lt;UserDto\u0026gt;\u0026gt; getUsers( @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) int size) { // Implementation } @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; getUser(@PathVariable Long id) { // Implementation } // POST - Create new resource @PostMapping public ResponseEntity\u0026lt;UserDto\u0026gt; createUser(@RequestBody @Valid CreateUserRequest request) { // Implementation } // PUT - Update entire resource @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; updateUser( @PathVariable Long id, @RequestBody @Valid UpdateUserRequest request) { // Implementation } // PATCH - Partial update @PatchMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; patchUser( @PathVariable Long id, @RequestBody Map\u0026lt;String, Object\u0026gt; updates) { // Implementation } // DELETE - Remove resource @DeleteMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; deleteUser(@PathVariable Long id) { // Implementation } } URL Design Patterns Hierarchical Resources /api/users/{userId}/orders /api/users/{userId}/orders/{orderId} /api/orders/{orderId}/items /api/orders/{orderId}/items/{itemId} Query Parameters for Filtering and Pagination @GetMapping(\u0026#34;/api/products\u0026#34;) public ResponseEntity\u0026lt;PagedResponse\u0026lt;ProductDto\u0026gt;\u0026gt; getProducts( @RequestParam(required = false) String category, @RequestParam(required = false) BigDecimal minPrice, @RequestParam(required = false) BigDecimal maxPrice, @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) int size, @RequestParam(defaultValue = \u0026#34;id\u0026#34;) String sortBy, @RequestParam(defaultValue = \u0026#34;asc\u0026#34;) String sortDir) { ProductFilter filter = ProductFilter.builder() .category(category) .minPrice(minPrice) .maxPrice(maxPrice) .build(); Pageable pageable = PageRequest.of(page, size, Sort.Direction.fromString(sortDir), sortBy); Page\u0026lt;Product\u0026gt; products = productService.findProducts(filter, pageable); return ResponseEntity.ok(PagedResponse.of(products)); } Response Design Standard Response Structure public class ApiResponse\u0026lt;T\u0026gt; { private boolean success; private String message; private T data; private String timestamp; private List\u0026lt;String\u0026gt; errors; public static \u0026lt;T\u0026gt; ApiResponse\u0026lt;T\u0026gt; success(T data) { return ApiResponse.\u0026lt;T\u0026gt;builder() .success(true) .data(data) .timestamp(Instant.now().toString()) .build(); } public static \u0026lt;T\u0026gt; ApiResponse\u0026lt;T\u0026gt; error(String message, List\u0026lt;String\u0026gt; errors) { return ApiResponse.\u0026lt;T\u0026gt;builder() .success(false) .message(message) .errors(errors) .timestamp(Instant.now().toString()) .build(); } } // Paginated response public class PagedResponse\u0026lt;T\u0026gt; { private List\u0026lt;T\u0026gt; content; private int page; private int size; private long totalElements; private int totalPages; private boolean first; private boolean last; public static \u0026lt;T\u0026gt; PagedResponse\u0026lt;T\u0026gt; of(Page\u0026lt;T\u0026gt; page) { return PagedResponse.\u0026lt;T\u0026gt;builder() .content(page.getContent()) .page(page.getNumber()) .size(page.getSize()) .totalElements(page.getTotalElements()) .totalPages(page.getTotalPages()) .first(page.isFirst()) .last(page.isLast()) .build(); } } HTTP Status Codes @RestController public class UserController { @PostMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; createUser(@RequestBody @Valid CreateUserRequest request) { UserDto user = userService.createUser(request); URI location = ServletUriComponentsBuilder .fromCurrentRequest() .path(\u0026#34;/{id}\u0026#34;) .buildAndExpand(user.getId()) .toUri(); return ResponseEntity .created(location) // 201 Created .body(user); } @GetMapping(\u0026#34;/users/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; getUser(@PathVariable Long id) { Optional\u0026lt;UserDto\u0026gt; user = userService.findById(id); return user .map(u -\u0026gt; ResponseEntity.ok(u)) // 200 OK .orElse(ResponseEntity.notFound().build()); // 404 Not Found } @PutMapping(\u0026#34;/users/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; updateUser(@PathVariable Long id, @RequestBody @Valid UpdateUserRequest request) { try { UserDto user = userService.updateUser(id, request); return ResponseEntity.ok(user); // 200 OK } catch (UserNotFoundException e) { return ResponseEntity.notFound().build(); // 404 Not Found } } @DeleteMapping(\u0026#34;/users/{id}\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; deleteUser(@PathVariable Long id) { try { userService.deleteUser(id); return ResponseEntity.noContent().build(); // 204 No Content } catch (UserNotFoundException e) { return ResponseEntity.notFound().build(); // 404 Not Found } } } Error Handling Global Exception Handler @RestControllerAdvice @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public ApiResponse\u0026lt;Void\u0026gt; handleValidationExceptions(MethodArgumentNotValidException ex) { List\u0026lt;String\u0026gt; errors = ex.getBindingResult() .getFieldErrors() .stream() .map(error -\u0026gt; error.getField() + \u0026#34;: \u0026#34; + error.getDefaultMessage()) .collect(Collectors.toList()); return ApiResponse.error(\u0026#34;Validation failed\u0026#34;, errors); } @ExceptionHandler(ResourceNotFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ApiResponse\u0026lt;Void\u0026gt; handleResourceNotFoundException(ResourceNotFoundException ex) { return ApiResponse.error(ex.getMessage(), List.of()); } @ExceptionHandler(ConflictException.class) @ResponseStatus(HttpStatus.CONFLICT) public ApiResponse\u0026lt;Void\u0026gt; handleConflictException(ConflictException ex) { return ApiResponse.error(ex.getMessage(), List.of()); } @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ApiResponse\u0026lt;Void\u0026gt; handleGenericException(Exception ex) { log.error(\u0026#34;Unexpected error occurred\u0026#34;, ex); return ApiResponse.error(\u0026#34;Internal server error\u0026#34;, List.of()); } } // Custom exceptions public class ResourceNotFoundException extends RuntimeException { public ResourceNotFoundException(String message) { super(message); } } public class ConflictException extends RuntimeException { public ConflictException(String message) { super(message); } } Input Validation Request DTOs with Validation public class CreateUserRequest { @NotBlank(message = \u0026#34;Email is required\u0026#34;) @Email(message = \u0026#34;Email must be valid\u0026#34;) private String email; @NotBlank(message = \u0026#34;Name is required\u0026#34;) @Size(min = 2, max = 50, message = \u0026#34;Name must be between 2 and 50 characters\u0026#34;) private String name; @Past(message = \u0026#34;Date of birth must be in the past\u0026#34;) private LocalDate dateOfBirth; @Valid @NotNull(message = \u0026#34;Address is required\u0026#34;) private AddressDto address; // getters, setters } public class AddressDto { @NotBlank(message = \u0026#34;Street is required\u0026#34;) private String street; @NotBlank(message = \u0026#34;City is required\u0026#34;) private String city; @Pattern(regexp = \u0026#34;\\\\d{5}\u0026#34;, message = \u0026#34;Postal code must be 5 digits\u0026#34;) private String postalCode; // getters, setters } // Custom validator @Target({ElementType.FIELD, ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy = UniqueEmailValidator.class) public @interface UniqueEmail { String message() default \u0026#34;Email already exists\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; } @Component public class UniqueEmailValidator implements ConstraintValidator\u0026lt;UniqueEmail, String\u0026gt; { @Autowired private UserRepository userRepository; @Override public boolean isValid(String email, ConstraintValidatorContext context) { return email != null \u0026amp;\u0026amp; !userRepository.existsByEmail(email); } } Content Negotiation @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @GetMapping(produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE}) public ResponseEntity\u0026lt;List\u0026lt;UserDto\u0026gt;\u0026gt; getUsers() { // Returns JSON or XML based on Accept header List\u0026lt;UserDto\u0026gt; users = userService.findAll(); return ResponseEntity.ok(users); } @PostMapping( consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE}, produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE} ) public ResponseEntity\u0026lt;UserDto\u0026gt; createUser(@RequestBody CreateUserRequest request) { UserDto user = userService.createUser(request); return ResponseEntity.ok(user); } } Security Best Practices Authentication and Authorization @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .csrf(csrf -\u0026gt; csrf.disable()) .sessionManagement(session -\u0026gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .authorizeHttpRequests(authz -\u0026gt; authz .requestMatchers(\u0026#34;/api/auth/**\u0026#34;).permitAll() .requestMatchers(HttpMethod.GET, \u0026#34;/api/public/**\u0026#34;).permitAll() .requestMatchers(\u0026#34;/api/admin/**\u0026#34;).hasRole(\u0026#34;ADMIN\u0026#34;) .anyRequest().authenticated() ) .oauth2ResourceServer(oauth2 -\u0026gt; oauth2.jwt(Customizer.withDefaults())); return http.build(); } } @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @GetMapping @PreAuthorize(\u0026#34;hasRole(\u0026#39;USER\u0026#39;) or hasRole(\u0026#39;ADMIN\u0026#39;)\u0026#34;) public ResponseEntity\u0026lt;List\u0026lt;UserDto\u0026gt;\u0026gt; getUsers() { // Implementation } @PostMapping @PreAuthorize(\u0026#34;hasRole(\u0026#39;ADMIN\u0026#39;)\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; createUser(@RequestBody CreateUserRequest request) { // Implementation } @GetMapping(\u0026#34;/me\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; getCurrentUser(Authentication authentication) { String username = authentication.getName(); UserDto user = userService.findByUsername(username); return ResponseEntity.ok(user); } } Rate Limiting @Configuration public class RateLimitConfig { @Bean public RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate\u0026lt;String, String\u0026gt; template = new RedisTemplate\u0026lt;\u0026gt;(); template.setConnectionFactory(connectionFactory); template.setDefaultSerializer(new StringRedisSerializer()); return template; } } @Component public class RateLimitInterceptor implements HandlerInterceptor { private final RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String clientId = getClientId(request); String key = \u0026#34;rate_limit:\u0026#34; + clientId; String requests = redisTemplate.opsForValue().get(key); if (requests == null) { redisTemplate.opsForValue().set(key, \u0026#34;1\u0026#34;, Duration.ofMinutes(1)); } else if (Integer.parseInt(requests) \u0026lt; 100) { redisTemplate.opsForValue().increment(key); } else { response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value()); response.getWriter().write(\u0026#34;Rate limit exceeded\u0026#34;); return false; } return true; } private String getClientId(HttpServletRequest request) { // Extract client ID from JWT token or IP address return request.getRemoteAddr(); } } API Documentation OpenAPI/Swagger @Configuration public class OpenAPIConfig { @Bean public OpenAPI customOpenAPI() { return new OpenAPI() .info(new Info() .title(\u0026#34;User Management API\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .description(\u0026#34;API for managing users\u0026#34;) .contact(new Contact() .name(\u0026#34;API Team\u0026#34;) .email(\u0026#34;api-team@example.com\u0026#34;))) .servers(List.of( new Server().url(\u0026#34;http://localhost:8080\u0026#34;).description(\u0026#34;Development server\u0026#34;), new Server().url(\u0026#34;https://api.example.com\u0026#34;).description(\u0026#34;Production server\u0026#34;) )) .components(new Components() .addSecuritySchemes(\u0026#34;bearerAuth\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.HTTP) .scheme(\u0026#34;bearer\u0026#34;) .bearerFormat(\u0026#34;JWT\u0026#34;))); } } @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) @Tag(name = \u0026#34;User Management\u0026#34;, description = \u0026#34;Operations for managing users\u0026#34;) public class UserController { @Operation( summary = \u0026#34;Get all users\u0026#34;, description = \u0026#34;Retrieve a paginated list of all users\u0026#34;, responses = { @ApiResponse(responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;Successfully retrieved users\u0026#34;), @ApiResponse(responseCode = \u0026#34;401\u0026#34;, description = \u0026#34;Unauthorized\u0026#34;), @ApiResponse(responseCode = \u0026#34;403\u0026#34;, description = \u0026#34;Forbidden\u0026#34;) } ) @GetMapping public ResponseEntity\u0026lt;PagedResponse\u0026lt;UserDto\u0026gt;\u0026gt; getUsers( @Parameter(description = \u0026#34;Page number (0-based)\u0026#34;) @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @Parameter(description = \u0026#34;Page size\u0026#34;) @RequestParam(defaultValue = \u0026#34;10\u0026#34;) int size) { // Implementation } @Operation(summary = \u0026#34;Create a new user\u0026#34;) @ApiResponses(value = { @ApiResponse(responseCode = \u0026#34;201\u0026#34;, description = \u0026#34;User created successfully\u0026#34;), @ApiResponse(responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;Invalid input\u0026#34;), @ApiResponse(responseCode = \u0026#34;409\u0026#34;, description = \u0026#34;User already exists\u0026#34;) }) @PostMapping @SecurityRequirement(name = \u0026#34;bearerAuth\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; createUser( @Parameter(description = \u0026#34;User creation request\u0026#34;) @RequestBody @Valid CreateUserRequest request) { // Implementation } } Versioning Strategies URL Versioning @RestController @RequestMapping(\u0026#34;/api/v1/users\u0026#34;) public class UserV1Controller { // Version 1 implementation } @RestController @RequestMapping(\u0026#34;/api/v2/users\u0026#34;) public class UserV2Controller { // Version 2 implementation } Header Versioning @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @GetMapping(headers = \u0026#34;API-Version=1\u0026#34;) public ResponseEntity\u0026lt;List\u0026lt;UserV1Dto\u0026gt;\u0026gt; getUsersV1() { // Version 1 implementation } @GetMapping(headers = \u0026#34;API-Version=2\u0026#34;) public ResponseEntity\u0026lt;List\u0026lt;UserV2Dto\u0026gt;\u0026gt; getUsersV2() { // Version 2 implementation } } Testing APIs Integration Tests @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) @Testcontainers class UserControllerIntegrationTest { @Autowired private TestRestTemplate restTemplate; @Autowired private UserRepository userRepository; @Container static PostgreSQLContainer\u0026lt;?\u0026gt; postgres = new PostgreSQLContainer\u0026lt;\u0026gt;(\u0026#34;postgres:14\u0026#34;) .withDatabaseName(\u0026#34;testdb\u0026#34;) .withUsername(\u0026#34;test\u0026#34;) .withPassword(\u0026#34;test\u0026#34;); @Test void shouldCreateUser() { CreateUserRequest request = new CreateUserRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); ResponseEntity\u0026lt;UserDto\u0026gt; response = restTemplate.postForEntity( \u0026#34;/api/users\u0026#34;, request, UserDto.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED); assertThat(response.getBody().getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); assertThat(userRepository.count()).isEqualTo(1); } @Test void shouldReturnValidationErrorForInvalidEmail() { CreateUserRequest request = new CreateUserRequest(\u0026#34;invalid-email\u0026#34;, \u0026#34;Test User\u0026#34;); ResponseEntity\u0026lt;ApiResponse\u0026gt; response = restTemplate.postForEntity( \u0026#34;/api/users\u0026#34;, request, ApiResponse.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST); assertThat(response.getBody().isSuccess()).isFalse(); } } Contract Testing with WireMock @SpringBootTest class UserServiceTest { @RegisterExtension static WireMockExtension wireMock = WireMockExtension.newInstance() .options(wireMockConfig().port(8089)) .build(); @Autowired private UserService userService; @Test void shouldCallExternalAPISuccessfully() { // Given wireMock.stubFor(get(urlEqualTo(\u0026#34;/api/external/users/1\u0026#34;)) .willReturn(aResponse() .withStatus(200) .withHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(\u0026#34;{\\\u0026#34;id\\\u0026#34;:1,\\\u0026#34;name\\\u0026#34;:\\\u0026#34;External User\\\u0026#34;}\u0026#34;))); // When ExternalUser user = userService.fetchExternalUser(1L); // Then assertThat(user.getName()).isEqualTo(\u0026#34;External User\u0026#34;); wireMock.verify(getRequestedFor(urlEqualTo(\u0026#34;/api/external/users/1\u0026#34;))); } } Performance Optimization Caching @Service @CacheConfig(cacheNames = \u0026#34;users\u0026#34;) public class UserService { @Cacheable(key = \u0026#34;#id\u0026#34;) public UserDto findById(Long id) { return userRepository.findById(id) .map(this::toDto) .orElseThrow(() -\u0026gt; new UserNotFoundException(\u0026#34;User not found\u0026#34;)); } @CacheEvict(key = \u0026#34;#userDto.id\u0026#34;) public UserDto updateUser(UserDto userDto) { // Update logic return userDto; } @CacheEvict(allEntries = true) public void clearCache() { // Cache will be cleared } } Pagination and Filtering @Service public class ProductService { public Page\u0026lt;ProductDto\u0026gt; findProducts(ProductFilter filter, Pageable pageable) { Specification\u0026lt;Product\u0026gt; spec = Specification.where(null); if (filter.getCategory() != null) { spec = spec.and((root, query, cb) -\u0026gt; cb.equal(root.get(\u0026#34;category\u0026#34;), filter.getCategory())); } if (filter.getMinPrice() != null) { spec = spec.and((root, query, cb) -\u0026gt; cb.greaterThanOrEqualTo(root.get(\u0026#34;price\u0026#34;), filter.getMinPrice())); } if (filter.getMaxPrice() != null) { spec = spec.and((root, query, cb) -\u0026gt; cb.lessThanOrEqualTo(root.get(\u0026#34;price\u0026#34;), filter.getMaxPrice())); } return productRepository.findAll(spec, pageable) .map(this::toDto); } } Well-designed REST APIs are the foundation of maintainable microservices and web applications. Focus on consistency, clear documentation, and following HTTP standards to create APIs that developers love to use.\n"},{
  "section": "Blog",
  "slug": "/en/blog/post-3/",
  "title": "Microservices Architecture with Spring Boot",
  "description": "Learn how to design and implement microservices architecture using Spring Boot, Spring Cloud, and modern patterns.",
  "date": "April 6, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Architecture, Backend",
  "tags": "Microservices, Spring Boot, Spring Cloud, Architecture, Distributed Systems",
  "content":"Microservices architecture has become the preferred approach for building scalable, maintainable applications. Let\u0026rsquo;s explore how to implement microservices using Spring Boot and Spring Cloud.\nWhat are Microservices? Microservices are small, independent services that communicate over well-defined APIs. Each service owns its data and business logic, making the system more resilient and scalable.\nBenefits Scalability: Scale individual services based on demand Technology Diversity: Use different technologies for different services Team Independence: Teams can work independently on services Fault Isolation: Failure in one service doesn\u0026rsquo;t bring down the entire system Challenges Complexity: Distributed systems are inherently complex Network Latency: Inter-service communication overhead Data Consistency: Managing transactions across services Monitoring: Observing distributed system behavior Spring Cloud Overview Spring Cloud provides tools for common patterns in distributed systems:\n\u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2023.0.0\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Service Discovery --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Circuit Breaker --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-circuitbreaker-resilience4j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- API Gateway --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Configuration --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Service Discovery with Eureka Eureka Server @SpringBootApplication @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } # eureka-server application.yml server: port: 8761 eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ Eureka Client (Service) @SpringBootApplication @EnableEurekaClient public class UserServiceApplication { public static void main(String[] args) { SpringApplication.run(UserServiceApplication.class, args); } } # user-service application.yml server: port: 8081 spring: application: name: user-service eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true API Gateway Central entry point for all client requests:\n@SpringBootApplication public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } } # gateway application.yml server: port: 8080 spring: application: name: api-gateway cloud: gateway: discovery: locator: enabled: true lower-case-service-id: true routes: - id: user-service uri: lb://user-service predicates: - Path=/api/users/** filters: - StripPrefix=1 - id: order-service uri: lb://order-service predicates: - Path=/api/orders/** filters: - StripPrefix=1 eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ Inter-Service Communication Synchronous Communication with OpenFeign @FeignClient(name = \u0026#34;user-service\u0026#34;) public interface UserServiceClient { @GetMapping(\u0026#34;/users/{userId}\u0026#34;) UserDto getUser(@PathVariable Long userId); @PostMapping(\u0026#34;/users\u0026#34;) UserDto createUser(@RequestBody CreateUserRequest request); } @Service public class OrderService { private final UserServiceClient userServiceClient; private final OrderRepository orderRepository; public OrderService(UserServiceClient userServiceClient, OrderRepository orderRepository) { this.userServiceClient = userServiceClient; this.orderRepository = orderRepository; } public Order createOrder(CreateOrderRequest request) { // Validate user exists UserDto user = userServiceClient.getUser(request.getUserId()); Order order = new Order(request.getUserId(), request.getItems()); return orderRepository.save(order); } } Asynchronous Communication with RabbitMQ @Configuration @EnableRabbit public class RabbitConfig { @Bean public TopicExchange orderExchange() { return new TopicExchange(\u0026#34;order.exchange\u0026#34;); } @Bean public Queue orderCreatedQueue() { return QueueBuilder.durable(\u0026#34;order.created.queue\u0026#34;).build(); } @Bean public Binding orderCreatedBinding() { return BindingBuilder .bind(orderCreatedQueue()) .to(orderExchange()) .with(\u0026#34;order.created\u0026#34;); } } // Publisher (Order Service) @Service public class OrderEventPublisher { private final RabbitTemplate rabbitTemplate; public void publishOrderCreated(Order order) { OrderCreatedEvent event = new OrderCreatedEvent( order.getId(), order.getUserId(), order.getTotalAmount() ); rabbitTemplate.convertAndSend( \u0026#34;order.exchange\u0026#34;, \u0026#34;order.created\u0026#34;, event ); } } // Consumer (Inventory Service) @Component public class OrderEventListener { private final InventoryService inventoryService; @RabbitListener(queues = \u0026#34;order.created.queue\u0026#34;) public void handleOrderCreated(OrderCreatedEvent event) { inventoryService.reserveItems(event.getOrderId(), event.getItems()); } } Circuit Breaker Pattern Prevent cascading failures using Resilience4j:\n@Service public class OrderService { private final UserServiceClient userServiceClient; @CircuitBreaker(name = \u0026#34;user-service\u0026#34;, fallbackMethod = \u0026#34;fallbackGetUser\u0026#34;) @Retry(name = \u0026#34;user-service\u0026#34;) @TimeLimiter(name = \u0026#34;user-service\u0026#34;) public CompletableFuture\u0026lt;UserDto\u0026gt; getUser(Long userId) { return CompletableFuture.supplyAsync(() -\u0026gt; userServiceClient.getUser(userId)); } public CompletableFuture\u0026lt;UserDto\u0026gt; fallbackGetUser(Long userId, Exception ex) { return CompletableFuture.completedFuture( new UserDto(userId, \u0026#34;Unknown User\u0026#34;, \u0026#34;unknown@example.com\u0026#34;) ); } } # Circuit breaker configuration resilience4j: circuitbreaker: instances: user-service: register-health-indicator: true sliding-window-size: 10 minimum-number-of-calls: 5 permitted-number-of-calls-in-half-open-state: 3 automatic-transition-from-open-to-half-open-enabled: true wait-duration-in-open-state: 5s failure-rate-threshold: 50 event-consumer-buffer-size: 10 retry: instances: user-service: max-attempts: 3 wait-duration: 500ms timelimiter: instances: user-service: timeout-duration: 2s Distributed Configuration Config Server @SpringBootApplication @EnableConfigServer public class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class, args); } } # config-server application.yml server: port: 8888 spring: cloud: config: server: git: uri: https://github.com/your-org/config-repo search-paths: config Config Client # bootstrap.yml spring: application: name: user-service cloud: config: uri: http://localhost:8888 fail-fast: true Distributed Tracing Sleuth and Zipkin \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-sleuth\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-sleuth-zipkin\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; spring: sleuth: sampler: probability: 1.0 zipkin: base-url: http://localhost:9411 Data Management Patterns Database per Service // User Service - User Database @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String email; private String name; // No foreign keys to other services } // Order Service - Order Database @Entity @Table(name = \u0026#34;orders\u0026#34;) public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long userId; // Reference by ID only private BigDecimal totalAmount; @OneToMany(mappedBy = \u0026#34;order\u0026#34;, cascade = CascadeType.ALL) private List\u0026lt;OrderItem\u0026gt; items; } Saga Pattern for Distributed Transactions @Component public class OrderSaga { private final PaymentService paymentService; private final InventoryService inventoryService; private final OrderService orderService; @SagaOrchestrationStart public void processOrder(CreateOrderCommand command) { // Step 1: Reserve inventory reserveInventory(command.getOrderId(), command.getItems()); } @SagaOrchestrationParticipant public void reserveInventory(Long orderId, List\u0026lt;OrderItem\u0026gt; items) { try { inventoryService.reserve(orderId, items); // Success - proceed to payment processPayment(orderId); } catch (Exception e) { // Compensation - cancel order cancelOrder(orderId); } } @SagaOrchestrationParticipant public void processPayment(Long orderId) { try { paymentService.charge(orderId); // Success - confirm order confirmOrder(orderId); } catch (Exception e) { // Compensation - release inventory and cancel order releaseInventory(orderId); cancelOrder(orderId); } } } Monitoring and Observability Metrics with Micrometer @RestController public class UserController { private final UserService userService; private final MeterRegistry meterRegistry; private final Counter userCreationCounter; public UserController(UserService userService, MeterRegistry meterRegistry) { this.userService = userService; this.meterRegistry = meterRegistry; this.userCreationCounter = Counter.builder(\u0026#34;users.created\u0026#34;) .description(\u0026#34;Number of users created\u0026#34;) .register(meterRegistry); } @PostMapping(\u0026#34;/users\u0026#34;) @Timed(name = \u0026#34;user.creation.time\u0026#34;, description = \u0026#34;Time spent creating user\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; createUser(@RequestBody CreateUserRequest request) { User user = userService.createUser(request); userCreationCounter.increment(); return ResponseEntity.ok(user); } } Health Checks @Component public class DatabaseHealthIndicator implements HealthIndicator { private final DataSource dataSource; @Override public Health health() { try (Connection connection = dataSource.getConnection()) { if (connection.isValid(1)) { return Health.up().withDetail(\u0026#34;database\u0026#34;, \u0026#34;Available\u0026#34;).build(); } } catch (SQLException e) { return Health.down(e).build(); } return Health.down().withDetail(\u0026#34;database\u0026#34;, \u0026#34;Connection failed\u0026#34;).build(); } } Security in Microservices JWT Token Validation @Component public class JwtAuthenticationFilter extends OncePerRequestFilter { private final JwtTokenProvider tokenProvider; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String token = extractToken(request); if (token != null \u0026amp;\u0026amp; tokenProvider.validateToken(token)) { Authentication auth = tokenProvider.getAuthentication(token); SecurityContextHolder.getContext().setAuthentication(auth); } filterChain.doFilter(request, response); } private String extractToken(HttpServletRequest request) { String bearerToken = request.getHeader(\u0026#34;Authorization\u0026#34;); if (bearerToken != null \u0026amp;\u0026amp; bearerToken.startsWith(\u0026#34;Bearer \u0026#34;)) { return bearerToken.substring(7); } return null; } } Deployment Strategies Docker Compose for Development version: \u0026#39;3.8\u0026#39; services: eureka-server: build: ./eureka-server ports: - \u0026#34;8761:8761\u0026#34; config-server: build: ./config-server ports: - \u0026#34;8888:8888\u0026#34; depends_on: - eureka-server user-service: build: ./user-service ports: - \u0026#34;8081:8081\u0026#34; depends_on: - eureka-server - config-server environment: - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://eureka-server:8761/eureka - SPRING_CLOUD_CONFIG_URI=http://config-server:8888 order-service: build: ./order-service ports: - \u0026#34;8082:8082\u0026#34; depends_on: - eureka-server - config-server - user-service Kubernetes Deployment apiVersion: apps/v1 kind: Deployment metadata: name: user-service spec: replicas: 3 selector: matchLabels: app: user-service template: metadata: labels: app: user-service spec: containers: - name: user-service image: user-service:latest ports: - containerPort: 8081 env: - name: SPRING_PROFILES_ACTIVE value: \u0026#34;kubernetes\u0026#34; livenessProbe: httpGet: path: /actuator/health port: 8081 initialDelaySeconds: 30 periodSeconds: 10 readinessProbe: httpGet: path: /actuator/health port: 8081 initialDelaySeconds: 5 periodSeconds: 5 --- apiVersion: v1 kind: Service metadata: name: user-service spec: selector: app: user-service ports: - port: 8081 targetPort: 8081 type: ClusterIP Best Practices Start with Modular Monolith: Don\u0026rsquo;t begin with microservices Domain-Driven Design: Align services with business capabilities API Versioning: Version your APIs to maintain backward compatibility Circuit Breakers: Implement fault tolerance patterns Centralized Logging: Use ELK stack or similar for log aggregation Monitoring: Implement comprehensive monitoring and alerting Security: Secure service-to-service communication Testing: Include contract testing between services Microservices architecture offers significant benefits but comes with complexity. Start simple, evolve gradually, and focus on observability and resilience from the beginning.\n"},{
  "section": "Blog",
  "slug": "/en/blog/database-design-patterns/",
  "title": "Database Design Patterns for Java Applications",
  "description": "Learn about efficient database design patterns and optimization techniques using JPA and Spring Data for Java applications.",
  "date": "April 5, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Database",
  "tags": "JPA, Spring Data, Database, Design Patterns",
  "content":"Solid database design is essential for efficient Java application development. Let\u0026rsquo;s explore database design patterns that satisfy both performance and maintainability using JPA and Spring Data.\nEntity Design Principles Basic Entity Structure @Entity @Table(name = \u0026#34;users\u0026#34;) @EntityListeners(AuditingEntityListener.class) @Data @NoArgsConstructor @AllArgsConstructor @Builder public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true, length = 100) private String email; @Column(nullable = false, length = 50) private String name; @Enumerated(EnumType.STRING) @Column(nullable = false) private UserStatus status; @CreatedDate @Column(nullable = false, updatable = false) private LocalDateTime createdAt; @LastModifiedDate @Column(nullable = false) private LocalDateTime updatedAt; @Version private Long version; } Inheritance Mapping Strategy // Joined Table Strategy (JOINED) @Entity @Table(name = \u0026#34;accounts\u0026#34;) @Inheritance(strategy = InheritanceType.JOINED) @DiscriminatorColumn(name = \u0026#34;account_type\u0026#34;) public abstract class Account { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String accountNumber; @Column(nullable = false, precision = 15, scale = 2) private BigDecimal balance; // Common fields } @Entity @Table(name = \u0026#34;savings_accounts\u0026#34;) @DiscriminatorValue(\u0026#34;SAVINGS\u0026#34;) public class SavingsAccount extends Account { @Column(nullable = false, precision = 5, scale = 4) private BigDecimal interestRate; private Integer minBalance; } @Entity @Table(name = \u0026#34;checking_accounts\u0026#34;) @DiscriminatorValue(\u0026#34;CHECKING\u0026#34;) public class CheckingAccount extends Account { @Column(nullable = false, precision = 10, scale = 2) private BigDecimal overdraftLimit; private Integer freeTransactions; } Association Mapping Patterns One-to-Many Association Optimization @Entity @Table(name = \u0026#34;categories\u0026#34;) public class Category { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 100) private String name; // Bidirectional association - LAZY loading for performance @OneToMany(mappedBy = \u0026#34;category\u0026#34;, fetch = FetchType.LAZY, cascade = CascadeType.ALL) @BatchSize(size = 20) // Solving N+1 problem private List\u0026lt;Product\u0026gt; products = new ArrayList\u0026lt;\u0026gt;(); // Convenience methods for associations public void addProduct(Product product) { products.add(product); product.setCategory(this); } public void removeProduct(Product product) { products.remove(product); product.setCategory(null); } } @Entity @Table(name = \u0026#34;products\u0026#34;) public class Product { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 200) private String name; @Column(nullable = false, precision = 10, scale = 2) private BigDecimal price; // Many-to-One association @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;category_id\u0026#34;, nullable = false) private Category category; } Many-to-Many Association with Additional Attributes @Entity @Table(name = \u0026#34;students\u0026#34;) public class Student { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 100) private String name; @OneToMany(mappedBy = \u0026#34;student\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) private List\u0026lt;Enrollment\u0026gt; enrollments = new ArrayList\u0026lt;\u0026gt;(); public void enrollInCourse(Course course, LocalDateTime enrollmentDate) { Enrollment enrollment = new Enrollment(this, course, enrollmentDate); enrollments.add(enrollment); course.getEnrollments().add(enrollment); } } @Entity @Table(name = \u0026#34;courses\u0026#34;) public class Course { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 200) private String title; @OneToMany(mappedBy = \u0026#34;course\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) private List\u0026lt;Enrollment\u0026gt; enrollments = new ArrayList\u0026lt;\u0026gt;(); } @Entity @Table(name = \u0026#34;enrollments\u0026#34;) public class Enrollment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;student_id\u0026#34;) private Student student; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;course_id\u0026#34;) private Course course; @Column(nullable = false) private LocalDateTime enrollmentDate; private BigDecimal grade; public Enrollment(Student student, Course course, LocalDateTime enrollmentDate) { this.student = student; this.course = course; this.enrollmentDate = enrollmentDate; } } Repository Pattern Custom Repository Implementation public interface UserRepositoryCustom { List\u0026lt;User\u0026gt; findUsersWithComplexCriteria(UserSearchCriteria criteria); Page\u0026lt;User\u0026gt; findActiveUsersWithPosts(Pageable pageable); } @Repository public class UserRepositoryImpl implements UserRepositoryCustom { @PersistenceContext private EntityManager entityManager; @Override public List\u0026lt;User\u0026gt; findUsersWithComplexCriteria(UserSearchCriteria criteria) { CriteriaBuilder cb = entityManager.getCriteriaBuilder(); CriteriaQuery\u0026lt;User\u0026gt; query = cb.createQuery(User.class); Root\u0026lt;User\u0026gt; root = query.from(User.class); List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); if (criteria.getName() != null) { predicates.add(cb.like(cb.lower(root.get(\u0026#34;name\u0026#34;)), \u0026#34;%\u0026#34; + criteria.getName().toLowerCase() + \u0026#34;%\u0026#34;)); } if (criteria.getStatus() != null) { predicates.add(cb.equal(root.get(\u0026#34;status\u0026#34;), criteria.getStatus())); } if (criteria.getCreatedAfter() != null) { predicates.add(cb.greaterThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), criteria.getCreatedAfter())); } query.where(predicates.toArray(new Predicate[0])); query.orderBy(cb.desc(root.get(\u0026#34;createdAt\u0026#34;))); return entityManager.createQuery(query) .setMaxResults(100) .getResultList(); } @Override public Page\u0026lt;User\u0026gt; findActiveUsersWithPosts(Pageable pageable) { String jpql = \u0026#34;\u0026#34;\u0026#34; SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.posts p WHERE u.status = :status ORDER BY u.createdAt DESC \u0026#34;\u0026#34;\u0026#34;; TypedQuery\u0026lt;User\u0026gt; query = entityManager.createQuery(jpql, User.class) .setParameter(\u0026#34;status\u0026#34;, UserStatus.ACTIVE) .setFirstResult((int) pageable.getOffset()) .setMaxResults(pageable.getPageSize()); List\u0026lt;User\u0026gt; users = query.getResultList(); // Count total results Long total = entityManager.createQuery( \u0026#34;SELECT COUNT(DISTINCT u) FROM User u WHERE u.status = :status\u0026#34;, Long.class) .setParameter(\u0026#34;status\u0026#34;, UserStatus.ACTIVE) .getSingleResult(); return new PageImpl\u0026lt;\u0026gt;(users, pageable, total); } } public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, UserRepositoryCustom { @Query(\u0026#34;SELECT u FROM User u WHERE u.email = :email\u0026#34;) Optional\u0026lt;User\u0026gt; findByEmail(@Param(\u0026#34;email\u0026#34;) String email); @Query(value = \u0026#34;\u0026#34;\u0026#34; SELECT u.* FROM users u WHERE u.status = :status AND u.created_at \u0026gt;= :since ORDER BY u.created_at DESC \u0026#34;\u0026#34;\u0026#34;, nativeQuery = true) List\u0026lt;User\u0026gt; findRecentActiveUsers(@Param(\u0026#34;status\u0026#34;) String status, @Param(\u0026#34;since\u0026#34;) LocalDateTime since); @Modifying @Query(\u0026#34;UPDATE User u SET u.status = :status WHERE u.id IN :ids\u0026#34;) int updateUserStatus(@Param(\u0026#34;ids\u0026#34;) List\u0026lt;Long\u0026gt; ids, @Param(\u0026#34;status\u0026#34;) UserStatus status); } Performance Optimization Patterns Pagination and Sorting @Service @Transactional(readOnly = true) public class ProductService { private final ProductRepository productRepository; public Page\u0026lt;ProductDto\u0026gt; getProducts(ProductSearchRequest request) { Pageable pageable = PageRequest.of( request.getPage(), request.getSize(), Sort.by(Sort.Direction.DESC, \u0026#34;createdAt\u0026#34;) ); Page\u0026lt;Product\u0026gt; products = productRepository.findByCategoryAndPriceRange( request.getCategoryId(), request.getMinPrice(), request.getMaxPrice(), pageable ); return products.map(this::convertToDto); } private ProductDto convertToDto(Product product) { return ProductDto.builder() .id(product.getId()) .name(product.getName()) .price(product.getPrice()) .categoryName(product.getCategory().getName()) .build(); } } Batch Processing Optimization @Service public class BatchUserService { @PersistenceContext private EntityManager entityManager; @Transactional public void batchUpdateUserStatus(List\u0026lt;Long\u0026gt; userIds, UserStatus newStatus) { final int batchSize = 100; for (int i = 0; i \u0026lt; userIds.size(); i += batchSize) { List\u0026lt;Long\u0026gt; batch = userIds.subList(i, Math.min(i + batchSize, userIds.size())); entityManager.createQuery( \u0026#34;UPDATE User u SET u.status = :status WHERE u.id IN :ids\u0026#34;) .setParameter(\u0026#34;status\u0026#34;, newStatus) .setParameter(\u0026#34;ids\u0026#34;, batch) .executeUpdate(); entityManager.flush(); entityManager.clear(); } } @Transactional public void batchInsertUsers(List\u0026lt;CreateUserRequest\u0026gt; requests) { final int batchSize = 50; for (int i = 0; i \u0026lt; requests.size(); i++) { User user = User.builder() .email(requests.get(i).getEmail()) .name(requests.get(i).getName()) .status(UserStatus.ACTIVE) .build(); entityManager.persist(user); if (i % batchSize == 0 \u0026amp;\u0026amp; i \u0026gt; 0) { entityManager.flush(); entityManager.clear(); } } } } Caching Strategy @Entity @Cacheable @org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE) public class Category { // Entity definition } @Service public class CategoryService { @Cacheable(value = \u0026#34;categories\u0026#34;, key = \u0026#34;#id\u0026#34;) public Category findById(Long id) { return categoryRepository.findById(id) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;Category not found\u0026#34;)); } @Cacheable(value = \u0026#34;categories\u0026#34;, key = \u0026#34;\u0026#39;all\u0026#39;\u0026#34;) public List\u0026lt;Category\u0026gt; findAll() { return categoryRepository.findAll(); } @CacheEvict(value = \u0026#34;categories\u0026#34;, allEntries = true) public Category save(Category category) { return categoryRepository.save(category); } } Transaction Management Declarative Transactions @Service @Transactional(readOnly = true) public class OrderService { private final OrderRepository orderRepository; private final ProductRepository productRepository; private final InventoryService inventoryService; @Transactional public Order createOrder(CreateOrderRequest request) { // Check product inventory Product product = productRepository.findById(request.getProductId()) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;Product not found\u0026#34;)); if (!inventoryService.hasStock(product.getId(), request.getQuantity())) { throw new InsufficientStockException(\u0026#34;Insufficient stock\u0026#34;); } // Create order Order order = Order.builder() .product(product) .quantity(request.getQuantity()) .totalPrice(product.getPrice().multiply(BigDecimal.valueOf(request.getQuantity()))) .status(OrderStatus.PENDING) .build(); Order savedOrder = orderRepository.save(order); // Decrease inventory inventoryService.decreaseStock(product.getId(), request.getQuantity()); return savedOrder; } @Transactional(propagation = Propagation.REQUIRES_NEW) public void processPayment(Long orderId, PaymentInfo paymentInfo) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;Order not found\u0026#34;)); try { // Payment processing logic paymentService.processPayment(paymentInfo); order.setStatus(OrderStatus.PAID); } catch (PaymentException e) { order.setStatus(OrderStatus.PAYMENT_FAILED); throw e; } finally { orderRepository.save(order); } } } Auditing Features @EntityListeners(AuditingEntityListener.class) @MappedSuperclass public abstract class BaseEntity { @CreatedDate @Column(name = \u0026#34;created_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime createdAt; @LastModifiedDate @Column(name = \u0026#34;updated_at\u0026#34;, nullable = false) private LocalDateTime updatedAt; @CreatedBy @Column(name = \u0026#34;created_by\u0026#34;, updatable = false) private String createdBy; @LastModifiedBy @Column(name = \u0026#34;updated_by\u0026#34;) private String updatedBy; } @Configuration @EnableJpaAuditing public class JpaAuditingConfig { @Bean public AuditorAware\u0026lt;String\u0026gt; auditorProvider() { return () -\u0026gt; { Authentication auth = SecurityContextHolder.getContext().getAuthentication(); if (auth != null \u0026amp;\u0026amp; auth.isAuthenticated() \u0026amp;\u0026amp; !auth.getPrincipal().equals(\u0026#34;anonymousUser\u0026#34;)) { return Optional.of(auth.getName()); } return Optional.of(\u0026#34;system\u0026#34;); }; } } Through these patterns, you can build a robust and high-performance database layer. Each pattern should be selectively applied according to specific situations to achieve optimal results.\n"},{
  "section": "Blog",
  "slug": "/en/blog/post-2/",
  "title": "Database Design Patterns for Java Applications",
  "description": "Essential database design patterns and optimization techniques for Java backend applications.",
  "date": "April 5, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Database",
  "tags": "Database, JPA, SQL, Java, Design Patterns",
  "content":"Effective database design is crucial for building scalable Java applications. Let\u0026rsquo;s explore essential patterns and techniques that every backend developer should know.\nEntity Relationship Patterns One-to-Many Relationships @Entity @Table(name = \u0026#34;categories\u0026#34;) public class Category { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String name; @OneToMany(mappedBy = \u0026#34;category\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) private List\u0026lt;Product\u0026gt; products = new ArrayList\u0026lt;\u0026gt;(); // Helper methods public void addProduct(Product product) { products.add(product); product.setCategory(this); } public void removeProduct(Product product) { products.remove(product); product.setCategory(null); } } @Entity @Table(name = \u0026#34;products\u0026#34;) public class Product { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String name; @Column(precision = 10, scale = 2) private BigDecimal price; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;category_id\u0026#34;, nullable = false) private Category category; // Constructor, getters, setters } Many-to-Many Relationships @Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE}) @JoinTable( name = \u0026#34;user_roles\u0026#34;, joinColumns = @JoinColumn(name = \u0026#34;user_id\u0026#34;), inverseJoinColumns = @JoinColumn(name = \u0026#34;role_id\u0026#34;) ) private Set\u0026lt;Role\u0026gt; roles = new HashSet\u0026lt;\u0026gt;(); public void addRole(Role role) { roles.add(role); role.getUsers().add(this); } public void removeRole(Role role) { roles.remove(role); role.getUsers().remove(this); } } @Entity @Table(name = \u0026#34;roles\u0026#34;) public class Role { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Enumerated(EnumType.STRING) @Column(nullable = false, unique = true) private RoleName name; @ManyToMany(mappedBy = \u0026#34;roles\u0026#34;) private Set\u0026lt;User\u0026gt; users = new HashSet\u0026lt;\u0026gt;(); } Repository Patterns Generic Repository public interface BaseRepository\u0026lt;T, ID\u0026gt; { Optional\u0026lt;T\u0026gt; findById(ID id); List\u0026lt;T\u0026gt; findAll(); T save(T entity); void deleteById(ID id); boolean existsById(ID id); } @NoRepositoryBean public interface CustomRepository\u0026lt;T, ID\u0026gt; extends BaseRepository\u0026lt;T, ID\u0026gt; { List\u0026lt;T\u0026gt; findAllWithPagination(int page, int size); long countAll(); List\u0026lt;T\u0026gt; findByFieldContaining(String fieldName, String value); } public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, CustomRepository\u0026lt;User, Long\u0026gt; { Optional\u0026lt;User\u0026gt; findByEmail(String email); List\u0026lt;User\u0026gt; findByRoles_Name(RoleName roleName); @Query(\u0026#34;SELECT u FROM User u WHERE u.createdAt \u0026gt;= :date\u0026#34;) List\u0026lt;User\u0026gt; findUsersCreatedAfter(@Param(\u0026#34;date\u0026#34;) LocalDateTime date); @Query(value = \u0026#34;SELECT * FROM users WHERE status = \u0026#39;ACTIVE\u0026#39; ORDER BY last_login_at DESC LIMIT :limit\u0026#34;, nativeQuery = true) List\u0026lt;User\u0026gt; findRecentActiveUsers(@Param(\u0026#34;limit\u0026#34;) int limit); } Custom Repository Implementation @Repository public class UserRepositoryImpl implements CustomRepository\u0026lt;User, Long\u0026gt; { @PersistenceContext private EntityManager entityManager; @Override public List\u0026lt;User\u0026gt; findAllWithPagination(int page, int size) { return entityManager.createQuery(\u0026#34;SELECT u FROM User u ORDER BY u.createdAt DESC\u0026#34;, User.class) .setFirstResult(page * size) .setMaxResults(size) .getResultList(); } @Override public List\u0026lt;User\u0026gt; findByFieldContaining(String fieldName, String value) { CriteriaBuilder cb = entityManager.getCriteriaBuilder(); CriteriaQuery\u0026lt;User\u0026gt; query = cb.createQuery(User.class); Root\u0026lt;User\u0026gt; root = query.from(User.class); query.select(root) .where(cb.like(cb.lower(root.get(fieldName)), \u0026#34;%\u0026#34; + value.toLowerCase() + \u0026#34;%\u0026#34;)); return entityManager.createQuery(query).getResultList(); } } Query Optimization Patterns N+1 Problem Solutions // Problem: N+1 queries public List\u0026lt;UserDTO\u0026gt; getAllUsersWithRoles() { List\u0026lt;User\u0026gt; users = userRepository.findAll(); // 1 query return users.stream() .map(user -\u0026gt; new UserDTO( user.getId(), user.getEmail(), user.getRoles() // N queries (one for each user) )) .collect(Collectors.toList()); } // Solution 1: Join Fetch @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { @Query(\u0026#34;SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.roles\u0026#34;) List\u0026lt;User\u0026gt; findAllWithRoles(); } // Solution 2: Entity Graph @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { @EntityGraph(attributePaths = {\u0026#34;roles\u0026#34;}) List\u0026lt;User\u0026gt; findAll(); } // Solution 3: Projection public interface UserProjection { Long getId(); String getEmail(); Set\u0026lt;RoleProjection\u0026gt; getRoles(); interface RoleProjection { Long getId(); String getName(); } } @Repository public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { List\u0026lt;UserProjection\u0026gt; findAllProjectedBy(); } Batch Processing @Service @Transactional public class UserService { private final UserRepository userRepository; @PersistenceContext private EntityManager entityManager; public void batchCreateUsers(List\u0026lt;CreateUserRequest\u0026gt; requests) { int batchSize = 20; for (int i = 0; i \u0026lt; requests.size(); i++) { User user = new User(requests.get(i).getEmail(), requests.get(i).getName()); entityManager.persist(user); if (i % batchSize == 0 \u0026amp;\u0026amp; i \u0026gt; 0) { entityManager.flush(); entityManager.clear(); } } entityManager.flush(); entityManager.clear(); } @Modifying @Query(\u0026#34;UPDATE User u SET u.status = :status WHERE u.id IN :ids\u0026#34;) int batchUpdateUserStatus(@Param(\u0026#34;ids\u0026#34;) List\u0026lt;Long\u0026gt; ids, @Param(\u0026#34;status\u0026#34;) UserStatus status); } Transaction Management Patterns Declarative Transactions @Service @Transactional(readOnly = true) public class OrderService { @Transactional public Order createOrder(CreateOrderRequest request) { // This method runs in a read-write transaction Order order = new Order(request.getUserId(), request.getItems()); return orderRepository.save(order); } @Transactional(propagation = Propagation.REQUIRES_NEW) public void logOrderEvent(Long orderId, String event) { // This runs in a separate transaction OrderLog log = new OrderLog(orderId, event); orderLogRepository.save(log); } @Transactional( isolation = Isolation.SERIALIZABLE, timeout = 30, rollbackFor = {BusinessException.class} ) public void processPayment(PaymentRequest request) { // High isolation level for payment processing paymentProcessor.process(request); } // Read-only method (inherited from class level) public List\u0026lt;Order\u0026gt; findOrdersByUser(Long userId) { return orderRepository.findByUserId(userId); } } Programmatic Transactions @Service public class ComplexTransactionService { private final PlatformTransactionManager transactionManager; public void complexBusinessOperation() { TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager); transactionTemplate.execute(status -\u0026gt; { try { // Business logic performOperation1(); performOperation2(); // Conditional rollback if (someCondition()) { status.setRollbackOnly(); return null; } performOperation3(); return null; } catch (Exception e) { status.setRollbackOnly(); throw new RuntimeException(\u0026#34;Transaction failed\u0026#34;, e); } }); } } Caching Strategies Entity-Level Caching @Entity @Table(name = \u0026#34;products\u0026#34;) @Cacheable @Cache(usage = CacheConcurrencyStrategy.READ_WRITE) public class Product { // Entity definition } // Application configuration @Configuration @EnableCaching public class CacheConfig { @Bean public CacheManager cacheManager() { ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager(); cacheManager.setCacheNames(Arrays.asList(\u0026#34;products\u0026#34;, \u0026#34;categories\u0026#34;, \u0026#34;users\u0026#34;)); return cacheManager; } } Query Result Caching @Repository public interface ProductRepository extends JpaRepository\u0026lt;Product, Long\u0026gt; { @QueryHints({ @QueryHint(name = \u0026#34;org.hibernate.cacheable\u0026#34;, value = \u0026#34;true\u0026#34;), @QueryHint(name = \u0026#34;org.hibernate.cacheRegion\u0026#34;, value = \u0026#34;product-queries\u0026#34;) }) @Query(\u0026#34;SELECT p FROM Product p WHERE p.category.id = :categoryId\u0026#34;) List\u0026lt;Product\u0026gt; findByCategoryId(@Param(\u0026#34;categoryId\u0026#34;) Long categoryId); } Service-Level Caching @Service public class ProductService { @Cacheable(value = \u0026#34;products\u0026#34;, key = \u0026#34;#id\u0026#34;) public Product findById(Long id) { return productRepository.findById(id) .orElseThrow(() -\u0026gt; new ProductNotFoundException(\u0026#34;Product not found\u0026#34;)); } @Cacheable(value = \u0026#34;product-lists\u0026#34;, key = \u0026#34;#categoryId + \u0026#39;_\u0026#39; + #page + \u0026#39;_\u0026#39; + #size\u0026#34;) public Page\u0026lt;Product\u0026gt; findByCategory(Long categoryId, int page, int size) { Pageable pageable = PageRequest.of(page, size); return productRepository.findByCategoryId(categoryId, pageable); } @CacheEvict(value = \u0026#34;products\u0026#34;, key = \u0026#34;#product.id\u0026#34;) public Product updateProduct(Product product) { return productRepository.save(product); } @CacheEvict(value = {\u0026#34;products\u0026#34;, \u0026#34;product-lists\u0026#34;}, allEntries = true) public void clearProductCaches() { // Clears all product-related caches } } Database Migration Patterns Flyway Migrations -- V1__Create_user_table.sql CREATE TABLE users ( id BIGSERIAL PRIMARY KEY, email VARCHAR(255) NOT NULL UNIQUE, name VARCHAR(255) NOT NULL, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); CREATE INDEX idx_users_email ON users(email); -- V2__Add_user_status.sql ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT \u0026#39;ACTIVE\u0026#39;; CREATE INDEX idx_users_status ON users(status); // Migration configuration @Configuration public class FlywayConfig { @Bean public Flyway flyway(@Qualifier(\u0026#34;dataSource\u0026#34;) DataSource dataSource) { return Flyway.configure() .dataSource(dataSource) .locations(\u0026#34;classpath:db/migration\u0026#34;) .baselineOnMigrate(true) .validateOnMigrate(true) .load(); } } Performance Monitoring Database Connection Monitoring @Component public class DatabaseMetrics { private final DataSource dataSource; private final MeterRegistry meterRegistry; public DatabaseMetrics(DataSource dataSource, MeterRegistry meterRegistry) { this.dataSource = dataSource; this.meterRegistry = meterRegistry; // Register connection pool metrics if (dataSource instanceof HikariDataSource) { HikariDataSource hikariDataSource = (HikariDataSource) dataSource; Gauge.builder(\u0026#34;database.connections.active\u0026#34;) .description(\u0026#34;Active database connections\u0026#34;) .register(meterRegistry, hikariDataSource, ds -\u0026gt; ds.getHikariPoolMXBean().getActiveConnections()); Gauge.builder(\u0026#34;database.connections.idle\u0026#34;) .description(\u0026#34;Idle database connections\u0026#34;) .register(meterRegistry, hikariDataSource, ds -\u0026gt; ds.getHikariPoolMXBean().getIdleConnections()); } } } Query Performance Monitoring @Component @Slf4j public class QueryPerformanceInterceptor implements Interceptor { private final MeterRegistry meterRegistry; @Override public boolean onLoad(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) { Timer.Sample sample = Timer.start(meterRegistry); sample.stop(Timer.builder(\u0026#34;hibernate.query.execution\u0026#34;) .tag(\u0026#34;operation\u0026#34;, \u0026#34;load\u0026#34;) .tag(\u0026#34;entity\u0026#34;, entity.getClass().getSimpleName()) .register(meterRegistry)); return false; } } These patterns provide a solid foundation for building robust, scalable database-driven Java applications. Choose the appropriate patterns based on your specific requirements and performance needs.\nNemo vel ad consectetur namut rutrum ex, venenatis sollicitudin urna. Aliquam erat volutpat. Integer eu ipsum sem. Ut bibendum lacus vestibulum maximus suscipit. Quisque vitae nibh iaculis neque blandit euismod.\nLorem ipsum dolor sit amet consectetur adipisicing elit. Nemo vel ad consectetur ut aperiam. Itaque eligendi natus aperiam? Excepturi repellendus consequatur quibusdam optio expedita praesentium est adipisci dolorem ut eius!\nCreative Design Nam ut rutrum ex, venenatis sollicitudin urna. Aliquam erat volutpat. Integer eu ipsum sem. Ut bibendum lacus vestibulum maximus suscipit. Quisque vitae nibh iaculis neque blandit euismod.\nLorem ipsum dolor sit amet consectetur adipisicing elit. Nemo vel ad consectetur ut aperiam. Itaque eligendi natus aperiam? Excepturi repellendus consequatur quibusdam optio expedita praesentium est adipisci dolorem ut eius!\nLorem ipsum dolor sit amet consectetur adipisicing elit. Nemo vel ad consectetur ut aperiam. Itaque eligendi natus aperiam? Excepturi repellendus consequatur quibusdam optio expedita praesentium est adipisci dolorem ut eius!\n"},{
  "section": "Blog",
  "slug": "/en/blog/post-1/",
  "title": "Spring Boot Best Practices for Production",
  "description": "Essential Spring Boot configuration and coding practices for production-ready applications.",
  "date": "April 4, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Backend, Java",
  "tags": "Spring Boot, Java, Backend, Best Practices",
  "content":"Building production-ready Spring Boot applications requires more than just basic functionality. Let\u0026rsquo;s explore essential practices that ensure your applications are robust, secure, and maintainable.\nApplication Configuration Profile-based Configuration # application.yml spring: profiles: active: ${SPRING_PROFILES_ACTIVE:dev} --- # Development Profile spring: config: activate: on-profile: dev datasource: url: jdbc:h2:mem:testdb driver-class-name: org.h2.Driver jpa: show-sql: true hibernate: ddl-auto: create-drop --- # Production Profile spring: config: activate: on-profile: prod datasource: url: ${DATABASE_URL} username: ${DB_USERNAME} password: ${DB_PASSWORD} hikari: maximum-pool-size: 20 minimum-idle: 5 jpa: show-sql: false hibernate: ddl-auto: validate Externalized Configuration @ConfigurationProperties(prefix = \u0026#34;app\u0026#34;) @Component public class AppProperties { private String name; private String version; private Security security = new Security(); private Database database = new Database(); // Getters and setters public static class Security { private String jwtSecret; private long jwtExpirationMs = 86400000; // 24 hours // Getters and setters } public static class Database { private int maxConnections = 20; private int connectionTimeout = 30000; // Getters and setters } } Security Implementation JWT Authentication @Component public class JwtTokenProvider { private final String jwtSecret; private final int jwtExpirationMs; public JwtTokenProvider(AppProperties appProperties) { this.jwtSecret = appProperties.getSecurity().getJwtSecret(); this.jwtExpirationMs = appProperties.getSecurity().getJwtExpirationMs(); } public String generateToken(Authentication authentication) { UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal(); Date expiryDate = new Date(System.currentTimeMillis() + jwtExpirationMs); return Jwts.builder() .setSubject(Long.toString(userPrincipal.getId())) .setIssuedAt(new Date()) .setExpiration(expiryDate) .signWith(SignatureAlgorithm.HS512, jwtSecret) .compact(); } public boolean validateToken(String authToken) { try { Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken); return true; } catch (JwtException | IllegalArgumentException e) { log.error(\u0026#34;Invalid JWT token: {}\u0026#34;, e.getMessage()); } return false; } } Security Configuration @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig { @Autowired private JwtAuthenticationEntryPoint unauthorizedHandler; @Bean public JwtAuthenticationFilter jwtAuthenticationFilter() { return new JwtAuthenticationFilter(); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.cors() .and() .csrf().disable() .exceptionHandling() .authenticationEntryPoint(unauthorizedHandler) .and() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .antMatchers(\u0026#34;/api/auth/**\u0026#34;).permitAll() .antMatchers(\u0026#34;/api/public/**\u0026#34;).permitAll() .antMatchers(HttpMethod.GET, \u0026#34;/api/posts/**\u0026#34;).permitAll() .anyRequest().authenticated(); http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); } } Error Handling Global Exception Handler @RestControllerAdvice @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(ValidationException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public ApiResponse handleValidationException(ValidationException ex) { log.warn(\u0026#34;Validation error: {}\u0026#34;, ex.getMessage()); return ApiResponse.error(\u0026#34;Validation failed\u0026#34;, ex.getMessage()); } @ExceptionHandler(ResourceNotFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ApiResponse handleResourceNotFoundException(ResourceNotFoundException ex) { log.warn(\u0026#34;Resource not found: {}\u0026#34;, ex.getMessage()); return ApiResponse.error(\u0026#34;Resource not found\u0026#34;, ex.getMessage()); } @ExceptionHandler(DataIntegrityViolationException.class) @ResponseStatus(HttpStatus.CONFLICT) public ApiResponse handleDataIntegrityViolation(DataIntegrityViolationException ex) { log.error(\u0026#34;Data integrity violation: {}\u0026#34;, ex.getMessage()); return ApiResponse.error(\u0026#34;Data conflict\u0026#34;, \u0026#34;The requested operation conflicts with existing data\u0026#34;); } @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ApiResponse handleGenericException(Exception ex) { log.error(\u0026#34;Unexpected error occurred\u0026#34;, ex); return ApiResponse.error(\u0026#34;Internal server error\u0026#34;, \u0026#34;An unexpected error occurred\u0026#34;); } } Database Optimization Connection Pool Configuration spring: datasource: hikari: maximum-pool-size: 20 minimum-idle: 5 idle-timeout: 300000 max-lifetime: 1200000 connection-timeout: 20000 validation-timeout: 5000 leak-detection-threshold: 60000 JPA Performance Tuning @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_user_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_user_status\u0026#34;, columnList = \u0026#34;status\u0026#34;) }) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, fetch = FetchType.LAZY, cascade = CascadeType.ALL) @BatchSize(size = 20) private List\u0026lt;Post\u0026gt; posts = new ArrayList\u0026lt;\u0026gt;(); // Constructor, getters, setters } @Repository public class UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { @Query(\u0026#34;SELECT u FROM User u LEFT JOIN FETCH u.posts WHERE u.id = :id\u0026#34;) Optional\u0026lt;User\u0026gt; findByIdWithPosts(@Param(\u0026#34;id\u0026#34;) Long id); @Query(value = \u0026#34;SELECT * FROM users WHERE status = :status ORDER BY created_at DESC LIMIT :limit\u0026#34;, nativeQuery = true) List\u0026lt;User\u0026gt; findActiveUsersWithLimit(@Param(\u0026#34;status\u0026#34;) String status, @Param(\u0026#34;limit\u0026#34;) int limit); } Monitoring and Observability Actuator Configuration management: endpoints: web: exposure: include: health,info,metrics,prometheus endpoint: health: show-details: when-authorized metrics: export: prometheus: enabled: true Custom Health Indicators @Component public class DatabaseHealthIndicator implements HealthIndicator { private final DataSource dataSource; public DatabaseHealthIndicator(DataSource dataSource) { this.dataSource = dataSource; } @Override public Health health() { try (Connection connection = dataSource.getConnection()) { if (connection.isValid(1)) { return Health.up() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;Available\u0026#34;) .withDetail(\u0026#34;validationQuery\u0026#34;, \u0026#34;SELECT 1\u0026#34;) .build(); } } catch (SQLException e) { return Health.down() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;Unavailable\u0026#34;) .withException(e) .build(); } return Health.down().withDetail(\u0026#34;database\u0026#34;, \u0026#34;Connection validation failed\u0026#34;).build(); } } Application Metrics @Service @Slf4j public class UserService { private final UserRepository userRepository; private final MeterRegistry meterRegistry; private final Counter userCreationCounter; private final Timer userFetchTimer; public UserService(UserRepository userRepository, MeterRegistry meterRegistry) { this.userRepository = userRepository; this.meterRegistry = meterRegistry; this.userCreationCounter = Counter.builder(\u0026#34;user.creation.count\u0026#34;) .description(\u0026#34;Number of users created\u0026#34;) .register(meterRegistry); this.userFetchTimer = Timer.builder(\u0026#34;user.fetch.time\u0026#34;) .description(\u0026#34;Time spent fetching user\u0026#34;) .register(meterRegistry); } public User createUser(CreateUserRequest request) { return userFetchTimer.recordCallable(() -\u0026gt; { User user = new User(request.getEmail(), request.getName()); User savedUser = userRepository.save(user); userCreationCounter.increment(); log.info(\u0026#34;Created user with ID: {}\u0026#34;, savedUser.getId()); return savedUser; }); } } Testing Best Practices Integration Tests @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestPropertySource(properties = { \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34; }) class UserControllerIntegrationTest { @Autowired private TestRestTemplate restTemplate; @Autowired private UserRepository userRepository; @Test void shouldCreateUser() { CreateUserRequest request = new CreateUserRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.postForEntity(\u0026#34;/api/users\u0026#34;, request, User.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED); assertThat(response.getBody().getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); assertThat(userRepository.count()).isEqualTo(1); } } Unit Tests with Mocking @ExtendWith(MockitoExtension.class) class UserServiceTest { @Mock private UserRepository userRepository; @Mock private MeterRegistry meterRegistry; @InjectMocks private UserService userService; @Test void shouldCreateUser() { // Given CreateUserRequest request = new CreateUserRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); User savedUser = new User(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); savedUser.setId(1L); when(userRepository.save(any(User.class))).thenReturn(savedUser); // When User result = userService.createUser(request); // Then assertThat(result.getId()).isEqualTo(1L); assertThat(result.getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); verify(userRepository).save(any(User.class)); } } Performance Optimization Caching Strategy @Service @EnableCaching public class UserService { @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public User findById(Long id) { return userRepository.findById(id) .orElseThrow(() -\u0026gt; new ResourceNotFoundException(\u0026#34;User not found\u0026#34;)); } @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User updateUser(User user) { return userRepository.save(user); } @CacheEvict(value = \u0026#34;users\u0026#34;, allEntries = true) public void clearUserCache() { // Cache will be cleared } } Async Processing @Service @Slf4j public class EmailService { @Async(\u0026#34;taskExecutor\u0026#34;) public CompletableFuture\u0026lt;Void\u0026gt; sendWelcomeEmail(String email, String name) { try { // Simulate email sending Thread.sleep(2000); log.info(\u0026#34;Welcome email sent to: {}\u0026#34;, email); return CompletableFuture.completedFuture(null); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } } @Configuration @EnableAsync public class AsyncConfig { @Bean(name = \u0026#34;taskExecutor\u0026#34;) public TaskExecutor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(2); executor.setMaxPoolSize(10); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;async-\u0026#34;); executor.initialize(); return executor; } } These practices ensure your Spring Boot applications are production-ready, secure, and maintainable. Start implementing them gradually and adapt based on your specific requirements.\n"}]

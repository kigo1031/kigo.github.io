[{"section":"Blog","slug":"/kigo.github.io/blog/hugo-github-pages-blog/","title":"Hugo와 GitHub Pages로 개발 블로그 시작하기","description":"Hugo 정적 사이트 생성기와 GitHub Pages를 활용해서 개발 블로그를 만들어보는 과정을 정리했습니다.","date":"2025년 8월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/banner_hu_bcd59cb0348f495e.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"193\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/banner_hu_4f2b3e25f0d34a8d.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/banner_hu_3ccee0743aef81bc.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/banner_hu_dd0fded36391e856.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"개발, 블로그","tags":"Hugo, GitHub Pages, 블로그, 정적사이트","content":"안녕하세요! 드디어 개발 블로그를 시작하게 되었습니다. 이번 포스트에서는 Hugo와 GitHub Pages를 활용해서 블로그를 만든 과정을 정리해보려고 합니다.\n왜 Hugo를 선택했을까? 블로그 플랫폼을 선택할 때 여러 옵션들을 고려했습니다:\nGatsby: React 기반이라 익숙하지만 복잡함 Jekyll: GitHub Pages의 기본 지원이지만 Ruby 환경 Hugo: Go 기반으로 빠르고 간단함 Hexo: Node.js 기반으로 친숙하지만 성능이 아쉬움 최종적으로 Hugo를 선택한 이유는:\n빠른 빌드 속도: Go 언어의 장점을 살린 초고속 빌드 간단한 설정: 복잡한 설정 없이 바로 시작 가능 풍부한 테마: 다양하고 예쁜 테마들 GitHub Pages 호환: 쉬운 배포 HugoPlate 테마 선택 여러 Hugo 테마 중에서 HugoPlate를 선택했습니다.\nHugoPlate의 장점 TailwindCSS 기반: 쉬운 스타일링 반응형 디자인: 모바일 친화적 SEO 최적화: 검색 엔진 최적화 내장 다크모드 지원: 눈에 편한 다크모드 빠른 성능: 95+ Google PageSpeed 점수 블로그 설정 과정 1. 기본 설정 # hugo.toml baseURL = \u0026#34;https://kigo1031.github.io\u0026#34; title = \u0026#34;Kigo\u0026#39;s Blog\u0026#34; defaultContentLanguage = \u0026#39;ko\u0026#39; 2. 한국어 지원 설정 # config/_default/languages.toml [ko] languageName = \u0026#34;한국어\u0026#34; languageCode = \u0026#34;ko-kr\u0026#34; contentDir = \u0026#34;content/korean\u0026#34; weight = 1 3. GitHub Actions 배포 설정 # .github/workflows/deploy.yml name: Deploy Hugo site to Pages on: push: branches: [main] jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#39;latest\u0026#39; # ... 빌드 및 배포 단계 한국어 커스터마이징 메뉴 한국어화 Home → 홈 About → 소개 Blog → 블로그 Contact → 연락처 콘텐츠 구조 content/korean/ ├── _index.md # 홈페이지 ├── about/ │ └── _index.md # 소개 페이지 ├── blog/ │ └── *.md # 블로그 포스트들 └── contact/ └── _index.md # 연락처 페이지 앞으로의 계획 이 블로그에서 다룰 예정인 주제들:\n웹 개발: React, Vue, TypeScript 등 백엔드: Node.js, Python, 데이터베이스 DevOps: Docker, CI/CD, 클라우드 개발 도구: VS Code, Git, 생산성 도구들 학습 기록: 새로운 기술 학습 후기 마무리 드디어 한국어 개발 블로그를 시작했습니다! 앞으로 꾸준히 좋은 내용들로 채워나가겠습니다.\n블로그를 보시고 궁금한 점이나 개선할 점이 있다면 언제든 연락 주세요. 함께 성장하는 개발자가 되어요! 🚀\n이 블로그는 Hugo + HugoPlate 테마 + GitHub Pages로 구성되어 있습니다.\n"},{"section":"Blog","slug":"/kigo.github.io/blog/hugo-blog-posting-guide/","title":"Hugo 블로그 포스팅 완벽 가이드 - 실제 운영 경험으로 배우는 팁들","description":"GitHub Pages와 Hugo를 사용한 블로그 운영자를 위한 실전 포스팅 가이드. 시행착오를 통해 얻은 노하우를 공유합니다.","date":"2025년 8월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"개발도구, 웹개발","tags":"Hugo, GitHub Pages, 블로그, 마크다운, 정적사이트","content":"Hugo 블로그를 운영하면서 겪었던 시행착오들을 바탕으로, 효율적인 포스팅 방법과 유용한 팁들을 공유해드립니다. 특히 GitHub Pages와 함께 사용하는 경우에 도움이 될 거예요.\n왜 Hugo인가? 처음 블로그를 시작할 때 여러 선택지가 있었습니다:\nWordPress: 무겁고 복잡 Jekyll: GitHub Pages 기본이지만 Ruby 의존성 Gatsby: React 기반이지만 오버스펙 Hugo: 빠르고 간단, Go 기반 Hugo를 선택한 이유는 속도와 단순함 때문이었습니다. 빌드 시간이 정말 빠르고, 설정이 직관적이에요.\n블로그 구조 이해하기 기본 디렉토리 구조 your-blog/ ├── content/ # 포스트들이 들어가는 곳 │ ├── korean/ │ │ └── blog/ # 한국어 포스트 │ └── english/ │ └── blog/ # 영어 포스트 ├── static/ # 이미지, CSS 등 정적 파일 │ └── images/ ├── layouts/ # 템플릿 파일들 ├── config/ # 설정 파일들 └── themes/ # 테마 폴더 중요한 설정 파일들 hugo.toml: 기본 사이트 설정 config/_default/params.toml: 세부 파라미터 config/_default/menus.ko.toml: 메뉴 구성 새 포스트 작성하기 1. Hugo 명령어로 생성 (추천) # 한국어 포스트 hugo new content/korean/blog/포스트-제목.md # 영어 포스트 hugo new content/english/blog/post-title.md 이렇게 하면 Front Matter가 자동으로 생성됩니다.\n2. 수동으로 생성 직접 파일을 만들 때는 이 템플릿을 사용하세요:\n--- title: \u0026#34;포스트 제목\u0026#34; meta_title: \u0026#34;\u0026#34; # 비워두면 title 사용 description: \u0026#34;SEO에 중요한 설명문\u0026#34; date: 2025-08-03T15:00:00+09:00 image: \u0026#34;/images/service-1.png\u0026#34; # 썸네일 categories: [\u0026#34;카테고리1\u0026#34;, \u0026#34;카테고리2\u0026#34;] author: \u0026#34;Kigo\u0026#34; tags: [\u0026#34;태그1\u0026#34;, \u0026#34;태그2\u0026#34;] draft: false # true면 미발행 --- Front Matter 최적화 팁 필수 필드들 title: \u0026#34;명확하고 검색 친화적인 제목\u0026#34; description: \u0026#34;구글 검색에서 보이는 요약문 (155자 이내)\u0026#34; date: 2025-08-03T15:00:00+09:00 # 시간대 포함 필수 categories: [\u0026#34;기존 카테고리 사용\u0026#34;] tags: [\u0026#34;관련성 높은 태그 3-5개\u0026#34;] draft: false 날짜 형식 주의사항 # ✅ 올바른 형식 date: 2025-08-03T15:00:00+09:00 # ❌ 잘못된 형식 date: 2025-08-03 date: \u0026#34;2025년 8월 3일\u0026#34; 카테고리 일관성 유지 기존 카테고리를 확인하고 일관성 있게 사용하세요:\n# 기존 카테고리 확인 find content -name \u0026#34;*.md\u0026#34; -exec grep -h \u0026#34;categories:\u0026#34; {} \\; | sort | uniq 마크다운 작성 실전 팁 1. 제목 구조 최적화 # 포스트 제목 (H1은 자동 생성되므로 사용 금지) ## 메인 섹션 (H2) ### 서브 섹션 (H3) #### 세부 내용 (H4) 2. 코드 블록 활용 ```java // 언어 지정으로 하이라이팅 활용 public class Example { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } # 터미널 명령어 hugo server -D 3. 이미지 최적화 ![의미있는 설명](/images/screenshot.png) \u0026lt;!-- 이미지 크기 조절이 필요하면 HTML 사용 --\u0026gt; \u0026lt;img src=\u0026#34;/images/large-image.png\u0026#34; alt=\u0026#34;설명\u0026#34; width=\u0026#34;600\u0026#34;\u0026gt; 4. 링크 작성법 [내부 링크](/blog/other-post/) [외부 링크](https://example.com){:target=\u0026#34;_blank\u0026#34;} 이미지 관리 전략 파일 구조 static/images/ ├── posts/ # 포스트별 이미지 │ ├── 2025-08/ │ └── hugo-guide/ ├── common/ # 공통 이미지 └── thumbnails/ # 썸네일들 이미지 최적화 # ImageMagick으로 최적화 convert original.png -quality 85 -resize 800x600 optimized.jpg # WebP 변환 (용량 절약) cwebp original.png -q 80 -o optimized.webp 개발 워크플로우 1. 개발 서버 실행 hugo server -D --navigateToChanged # -D: draft 포스트도 포함 # --navigateToChanged: 파일 변경시 자동 새로고침 2. 실시간 미리보기 파일을 저장하면 자동으로 브라우저가 새로고침됩니다. 정말 편해요!\n3. 빌드 및 배포 # 프로덕션 빌드 hugo --minify # GitHub Pages에 배포 (GitHub Actions 사용시) git add . git commit -m \u0026#34;새 포스트: Hugo 블로그 가이드\u0026#34; git push origin main 자주 하는 실수들 1. Front Matter 문법 오류 # ❌ 따옴표 불일치 title: \u0026#34;Hugo 가이드\u0026#39; # ❌ 배열 문법 오류 tags: [tag1, tag2, tag3 # ✅ 올바른 형식 title: \u0026#34;Hugo 가이드\u0026#34; tags: [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;, \u0026#34;tag3\u0026#34;] 2. 이미지 경로 오류 \u0026lt;!-- ❌ 절대 경로 --\u0026gt; ![이미지](file:///Users/name/blog/static/images/pic.png) \u0026lt;!-- ❌ 상대 경로 --\u0026gt; ![이미지](../static/images/pic.png) \u0026lt;!-- ✅ 올바른 경로 --\u0026gt; ![이미지](/images/pic.png) 3. 날짜 순서 문제 포스트가 의도한 순서로 나타나지 않으면 날짜를 확인하세요. Hugo는 날짜순으로 정렬합니다.\n성능 최적화 팁 1. 이미지 지연 로딩 테마에서 지원한다면:\n![이미지](/images/large-pic.png){: loading=\u0026#34;lazy\u0026#34;} 2. 빌드 최적화 # 빌드 시간 측정 time hugo --minify # 큰 파일들 찾기 find public -type f -size +1M -ls 3. 검색 최적화 # config/_default/params.toml [search] enable = true include_sections = [\u0026#34;blog\u0026#34;] show_description = true 유용한 Hugo 명령어들 # 새 사이트 생성 hugo new site my-blog # 테마 추가 git submodule add https://github.com/theme/repo themes/theme-name # 컨텐츠 통계 hugo list all # 빌드 정보 상세 hugo --verbose # 설정 확인 hugo config 백업 전략 1. Git 활용 # 모든 변경사항 추적 git add . git commit -m \u0026#34;포스트 추가: $(date)\u0026#34; git push 2. 자동 백업 스크립트 #!/bin/bash # backup.sh DATE=$(date +%Y%m%d) tar -czf \u0026#34;blog-backup-$DATE.tar.gz\u0026#34; content static config 트러블슈팅 빌드 에러 해결 # 상세 에러 메시지 확인 hugo --verbose --debug # 캐시 초기화 hugo --gc rm -rf public resources 템플릿 문제 # 템플릿 문법 검사 hugo --templateMetrics 마무리 Hugo 블로그는 처음에는 복잡해 보이지만, 한 번 익숙해지면 정말 효율적입니다. 특히:\n빠른 빌드 속도 - 수백 개 포스트도 몇 초 안에 유연한 구조 - 원하는 대로 커스터마이징 가능 검색 최적화 - 정적 사이트라 SEO에 유리 무료 호스팅 - GitHub Pages 완벽 호환 이 가이드가 Hugo 블로그 운영에 도움이 되길 바랍니다. 궁금한 점이 있으면 언제든 댓글로 물어보세요!\n참고 링크:\nHugo 공식 문서 GitHub Pages 가이드 마크다운 문법 가이드 "},{"section":"Blog","slug":"/kigo.github.io/blog/quarkus-cloud-native-java/","title":"Quarkus로 시작하는 Cloud Native Java 개발","description":"Kubernetes 시대의 Java 프레임워크 Quarkus 소개와 Spring Boot와의 비교","date":"2025년 8월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"웹개발","tags":"Java, Quarkus, Cloud Native, Kubernetes, GraalVM","content":"최근 클라우드 네이티브 환경에서 Java 애플리케이션의 한계점들이 많이 언급되고 있습니다. 특히 높은 메모리 사용량과 느린 시작 시간 때문에 컨테이너 환경에서는 다소 불리한 면이 있었죠. 이런 문제를 해결하기 위해 등장한 것이 바로 Quarkus입니다.\nQuarkus란? Quarkus는 Red Hat에서 개발한 Kubernetes Native Java 프레임워크입니다. \u0026ldquo;Supersonic Subatomic Java\u0026quot;라는 슬로건답게 기존 Java 애플리케이션보다 훨씬 빠른 시작 시간과 낮은 메모리 사용량을 자랑합니다.\n주요 특징 빠른 시작 시간: 밀리초 단위의 시작 시간 낮은 메모리 사용량: 기존 대비 1/10 수준 GraalVM Native Image 지원: 네이티브 컴파일 가능 개발자 친화적: Live Coding으로 즉시 반영 Spring Boot vs Quarkus 메모리 사용량 비교 # Spring Boot 애플리케이션 Memory: ~200MB # Quarkus JVM 모드 Memory: ~50MB # Quarkus Native 모드 Memory: ~20MB 시작 시간 비교 # Spring Boot Started in 3.2 seconds # Quarkus JVM 모드 Started in 1.1 seconds # Quarkus Native 모드 Started in 0.016 seconds Quarkus 프로젝트 시작하기 1. 프로젝트 생성 mvn io.quarkus.platform:quarkus-maven-plugin:3.2.4.Final:create \\ -DprojectGroupId=com.kigo.example \\ -DprojectArtifactId=quarkus-demo \\ -DclassName=\u0026#34;com.kigo.example.GreetingResource\u0026#34; \\ -Dpath=\u0026#34;/hello\u0026#34; 2. 기본 REST API 구현 @Path(\u0026#34;/hello\u0026#34;) public class GreetingResource { @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return \u0026#34;Hello from Quarkus!\u0026#34;; } } 3. 데이터베이스 연동 (Hibernate ORM with Panache) @Entity @Table(name = \u0026#34;users\u0026#34;) public class User extends PanacheEntity { public String name; public String email; public static List\u0026lt;User\u0026gt; findByName(String name) { return find(\u0026#34;name\u0026#34;, name).list(); } } 실무에서 느낀 Quarkus의 장점 1. 컨테이너 환경 최적화 Kubernetes에서 Pod 스케일링 시 빠른 시작 시간 덕분에 트래픽 급증에 더 빠르게 대응할 수 있습니다.\n# Kubernetes Deployment에서 더 적은 리소스 요청 resources: requests: memory: \u0026#34;32Mi\u0026#34; cpu: \u0026#34;100m\u0026#34; limits: memory: \u0026#34;64Mi\u0026#34; cpu: \u0026#34;200m\u0026#34; 2. 개발 생산성 향상 Live Coding 기능으로 코드 변경 시 애플리케이션 재시작 없이 즉시 반영됩니다.\n# 개발 모드로 실행 mvn quarkus:dev 3. GraalVM Native Image 네이티브 이미지로 컴파일하면 JVM 없이도 실행 가능합니다.\n# Native 이미지 빌드 mvn clean package -Pnative # 실행 파일 크기와 시작 시간 확인 ls -lh target/*-runner time ./target/quarkus-demo-1.0.0-SNAPSHOT-runner Spring Boot 개발자를 위한 Quarkus 마이그레이션 의존성 주입 // Spring Boot @Autowired private UserService userService; // Quarkus (CDI) @Inject UserService userService; Configuration // Spring Boot @Value(\u0026#34;${app.name}\u0026#34;) private String appName; // Quarkus @ConfigProperty(name = \u0026#34;app.name\u0026#34;) String appName; REST Controller // Spring Boot @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class UserController { @GetMapping(\u0026#34;/users\u0026#34;) public List\u0026lt;User\u0026gt; getUsers() { ... } } // Quarkus @Path(\u0026#34;/api/users\u0026#34;) public class UserResource { @GET public List\u0026lt;User\u0026gt; getUsers() { ... } } 언제 Quarkus를 선택해야 할까? Quarkus가 적합한 경우 마이크로서비스 아키텍처 컨테이너 기반 배포 서버리스 환경 (AWS Lambda, etc.) 리소스 제약이 있는 환경 Spring Boot가 여전히 좋은 경우 기존 Spring 생태계에 깊이 의존 대규모 모놀리식 애플리케이션 풍부한 커뮤니티 지원이 필요한 경우 성능 테스트 결과 실제 프로젝트에서 측정한 결과입니다:\n# 동일한 REST API 기준 ┌──────────────┬─────────────┬──────────────┬─────────────┐ │ │ Spring Boot │ Quarkus JVM │ Quarkus Native │ ├──────────────┼─────────────┼──────────────┼─────────────┤ │ 시작 시간 │ 3.2초 │ 1.1초 │ 0.016초 │ │ 메모리 사용량 │ 200MB │ 50MB │ 20MB │ │ 처리량(RPS) │ 1,200 │ 1,180 │ 1,100 │ └──────────────┴─────────────┴──────────────┴─────────────┘ 마치며 Quarkus는 클라우드 네이티브 시대에 맞는 Java 프레임워크입니다. Spring Boot의 완전한 대체재라기보다는, 특정 상황에서 더 나은 선택지가 될 수 있습니다.\n특히 다음과 같은 상황에서는 Quarkus 도입을 적극 고려해볼 만합니다:\n컨테이너 리소스 비용 최적화가 중요한 경우 빠른 스케일 아웃이 필요한 마이크로서비스 서버리스 환경에서의 Java 사용 앞으로 더 많은 프로젝트에서 Quarkus를 활용해보면서, 실무 적용 사례들을 계속 공유하겠습니다!\n참고 자료:\nQuarkus 공식 문서 Quarkus vs Spring Boot 벤치마크 GraalVM Native Image "},{"section":"Blog","slug":"/kigo.github.io/blog/quarkus-jpa-guide/","title":"Quarkus JPA 완전 정복 - 엔티티부터 트랜잭션까지","description":"Quarkus에서 JPA를 활용한 데이터베이스 연동부터 고급 기능까지, 백엔드 개발자가 알아야 할 모든 것을 다룹니다.","date":"2025년 8월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"웹개발","tags":"Quarkus, JPA, Database, Java, Backend, Hibernate, PostgreSQL","content":"Spring Boot에서 JPA를 사용하다 Quarkus로 넘어오면서 가장 궁금했던 것이 \u0026ldquo;데이터베이스 연동은 어떻게 하지?\u0026ldquo;였습니다. 다행히 Quarkus도 JPA를 완벽 지원하며, 오히려 더 간단하고 성능이 좋은 경우가 많습니다.\n프로젝트 설정 의존성 추가 pom.xml에 필요한 의존성을 추가합니다:\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- Quarkus JPA 확장 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.quarkus\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;quarkus-hibernate-orm-panache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- PostgreSQL 드라이버 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.quarkus\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;quarkus-jdbc-postgresql\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 개발 시 유용한 DevServices --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.quarkus\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;quarkus-devservices-postgresql\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 데이터베이스 설정 application.properties에서 데이터베이스를 설정합니다:\n# 데이터베이스 연결 설정 quarkus.datasource.db-kind=postgresql quarkus.datasource.username=postgres quarkus.datasource.password=password quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_jpa # Hibernate 설정 quarkus.hibernate-orm.database.generation=drop-and-create quarkus.hibernate-orm.log.sql=true quarkus.hibernate-orm.log.bind-parameters=true # 개발 환경에서만 사용 (운영에서는 validate 또는 none) %dev.quarkus.hibernate-orm.database.generation=drop-and-create %prod.quarkus.hibernate-orm.database.generation=validate 엔티티 정의 Quarkus에서는 표준 JPA 어노테이션을 그대로 사용할 수 있습니다:\n@Entity @Table(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @Column(nullable = false) private String name; @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List\u0026lt;Post\u0026gt; posts = new ArrayList\u0026lt;\u0026gt;(); // 기본 생성자 (JPA 필수) public User() {} public User(String email, String name) { this.email = email; this.name = name; this.createdAt = LocalDateTime.now(); } // getter/setter 생략 } @Entity @Table(name = \u0026#34;posts\u0026#34;) public class Post { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String title; @Column(columnDefinition = \u0026#34;TEXT\u0026#34;) private String content; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;user_id\u0026#34;) private User user; @Column(name = \u0026#34;created_at\u0026#34;) private LocalDateTime createdAt; public Post() {} public Post(String title, String content, User user) { this.title = title; this.content = content; this.user = user; this.createdAt = LocalDateTime.now(); } // getter/setter 생략 } Repository 패턴 vs Panache 패턴 Quarkus는 두 가지 방식을 지원합니다:\n1. 전통적인 Repository 패턴 @ApplicationScoped public class UserRepository { @Inject EntityManager em; @Transactional public User save(User user) { if (user.getId() == null) { em.persist(user); return user; } else { return em.merge(user); } } public Optional\u0026lt;User\u0026gt; findById(Long id) { return Optional.ofNullable(em.find(User.class, id)); } public Optional\u0026lt;User\u0026gt; findByEmail(String email) { try { User user = em.createQuery( \u0026#34;SELECT u FROM User u WHERE u.email = :email\u0026#34;, User.class) .setParameter(\u0026#34;email\u0026#34;, email) .getSingleResult(); return Optional.of(user); } catch (NoResultException e) { return Optional.empty(); } } public List\u0026lt;User\u0026gt; findAll() { return em.createQuery(\u0026#34;SELECT u FROM User u\u0026#34;, User.class) .getResultList(); } @Transactional public void delete(User user) { em.remove(em.merge(user)); } } 2. Panache 패턴 (권장) Panache를 사용하면 훨씬 간단해집니다:\n@Entity @Table(name = \u0026#34;users\u0026#34;) public class User extends PanacheEntity { @Column(nullable = false, unique = true) public String email; @Column(nullable = false) public String name; @Column(name = \u0026#34;created_at\u0026#34;) public LocalDateTime createdAt; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, fetch = FetchType.LAZY) public List\u0026lt;Post\u0026gt; posts = new ArrayList\u0026lt;\u0026gt;(); public User() {} public User(String email, String name) { this.email = email; this.name = name; this.createdAt = LocalDateTime.now(); } // 커스텀 쿼리 메서드 public static Optional\u0026lt;User\u0026gt; findByEmail(String email) { return find(\u0026#34;email\u0026#34;, email).firstResultOptional(); } public static List\u0026lt;User\u0026gt; findByNameContaining(String name) { return find(\u0026#34;name like ?1\u0026#34;, \u0026#34;%\u0026#34; + name + \u0026#34;%\u0026#34;).list(); } } Repository 클래스를 별도로 만들고 싶다면:\n@ApplicationScoped public class UserRepository implements PanacheRepository\u0026lt;User\u0026gt; { public Optional\u0026lt;User\u0026gt; findByEmail(String email) { return find(\u0026#34;email\u0026#34;, email).firstResultOptional(); } public List\u0026lt;User\u0026gt; findActiveUsers() { return find(\u0026#34;active = true\u0026#34;).list(); } public long countByDomain(String domain) { return count(\u0026#34;email like ?1\u0026#34;, \u0026#34;%@\u0026#34; + domain); } } 서비스 계층 구현 @ApplicationScoped public class UserService { @Inject UserRepository userRepository; @Transactional public User createUser(String email, String name) { // 이메일 중복 체크 if (userRepository.findByEmail(email).isPresent()) { throw new IllegalArgumentException(\u0026#34;이미 존재하는 이메일입니다.\u0026#34;); } User user = new User(email, name); userRepository.persist(user); return user; } public Optional\u0026lt;User\u0026gt; getUserById(Long id) { return userRepository.findByIdOptional(id); } public List\u0026lt;User\u0026gt; getAllUsers() { return userRepository.listAll(); } @Transactional public User updateUser(Long id, String name) { User user = userRepository.findById(id); if (user == null) { throw new EntityNotFoundException(\u0026#34;사용자를 찾을 수 없습니다.\u0026#34;); } user.name = name; return user; // Panache는 자동으로 변경사항을 감지 } @Transactional public void deleteUser(Long id) { if (!userRepository.deleteById(id)) { throw new EntityNotFoundException(\u0026#34;사용자를 찾을 수 없습니다.\u0026#34;); } } } REST API 구현 @Path(\u0026#34;/api/users\u0026#34;) @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public class UserResource { @Inject UserService userService; @GET public List\u0026lt;User\u0026gt; getAllUsers() { return userService.getAllUsers(); } @GET @Path(\u0026#34;/{id}\u0026#34;) public Response getUserById(@PathParam(\u0026#34;id\u0026#34;) Long id) { return userService.getUserById(id) .map(user -\u0026gt; Response.ok(user).build()) .orElse(Response.status(Response.Status.NOT_FOUND).build()); } @POST public Response createUser(CreateUserRequest request) { try { User user = userService.createUser(request.email, request.name); return Response.status(Response.Status.CREATED).entity(user).build(); } catch (IllegalArgumentException e) { return Response.status(Response.Status.BAD_REQUEST) .entity(Map.of(\u0026#34;error\u0026#34;, e.getMessage())) .build(); } } @PUT @Path(\u0026#34;/{id}\u0026#34;) public Response updateUser(@PathParam(\u0026#34;id\u0026#34;) Long id, UpdateUserRequest request) { try { User user = userService.updateUser(id, request.name); return Response.ok(user).build(); } catch (EntityNotFoundException e) { return Response.status(Response.Status.NOT_FOUND) .entity(Map.of(\u0026#34;error\u0026#34;, e.getMessage())) .build(); } } @DELETE @Path(\u0026#34;/{id}\u0026#34;) public Response deleteUser(@PathParam(\u0026#34;id\u0026#34;) Long id) { try { userService.deleteUser(id); return Response.noContent().build(); } catch (EntityNotFoundException e) { return Response.status(Response.Status.NOT_FOUND) .entity(Map.of(\u0026#34;error\u0026#34;, e.getMessage())) .build(); } } public static class CreateUserRequest { public String email; public String name; } public static class UpdateUserRequest { public String name; } } 고급 기능 1. 커스텀 쿼리 @ApplicationScoped public class PostRepository implements PanacheRepository\u0026lt;Post\u0026gt; { // JPQL 사용 public List\u0026lt;Post\u0026gt; findByTitleContaining(String keyword) { return find(\u0026#34;title like ?1\u0026#34;, \u0026#34;%\u0026#34; + keyword + \u0026#34;%\u0026#34;).list(); } // 네이티브 쿼리 사용 @Query(value = \u0026#34;SELECT * FROM posts WHERE created_at \u0026gt;= ?1\u0026#34;, nativeQuery = true) public List\u0026lt;Post\u0026gt; findRecentPosts(LocalDateTime since) { return getEntityManager() .createNativeQuery(\u0026#34;SELECT * FROM posts WHERE created_at \u0026gt;= ?1\u0026#34;, Post.class) .setParameter(1, since) .getResultList(); } // 복잡한 조건 쿼리 public List\u0026lt;Post\u0026gt; findPostsByUserAndPeriod(String userEmail, LocalDateTime startDate, LocalDateTime endDate) { return find(\u0026#34;user.email = ?1 and createdAt between ?2 and ?3\u0026#34;, userEmail, startDate, endDate).list(); } } 2. 트랜잭션 관리 @ApplicationScoped public class PostService { @Inject PostRepository postRepository; @Inject UserRepository userRepository; // 기본 트랜잭션 @Transactional public Post createPost(Long userId, String title, String content) { User user = userRepository.findById(userId); if (user == null) { throw new EntityNotFoundException(\u0026#34;사용자를 찾을 수 없습니다.\u0026#34;); } Post post = new Post(title, content, user); postRepository.persist(post); return post; } // 읽기 전용 트랜잭션 @Transactional(Transactional.TxType.SUPPORTS) public List\u0026lt;Post\u0026gt; getPostsByUser(Long userId) { return postRepository.find(\u0026#34;user.id\u0026#34;, userId).list(); } // 새 트랜잭션 생성 @Transactional(Transactional.TxType.REQUIRES_NEW) public void logActivity(String activity) { // 로그는 별도 트랜잭션에서 처리 // 메인 트랜잭션이 롤백되어도 로그는 유지됨 } // 롤백 조건 지정 @Transactional(rollbackOn = {BusinessException.class}) public void complexBusinessLogic() { // BusinessException 발생 시에만 롤백 } } 3. 페이징과 정렬 @GET public Response getUsers(@QueryParam(\u0026#34;page\u0026#34;) @DefaultValue(\u0026#34;0\u0026#34;) int page, @QueryParam(\u0026#34;size\u0026#34;) @DefaultValue(\u0026#34;10\u0026#34;) int size, @QueryParam(\u0026#34;sort\u0026#34;) @DefaultValue(\u0026#34;id\u0026#34;) String sort) { PanacheQuery\u0026lt;User\u0026gt; query = User.findAll(Sort.by(sort)); List\u0026lt;User\u0026gt; users = query.page(page, size).list(); long totalCount = query.count(); int totalPages = (int) Math.ceil((double) totalCount / size); Map\u0026lt;String, Object\u0026gt; response = Map.of( \u0026#34;users\u0026#34;, users, \u0026#34;currentPage\u0026#34;, page, \u0026#34;totalPages\u0026#34;, totalPages, \u0026#34;totalCount\u0026#34;, totalCount ); return Response.ok(response).build(); } 개발 환경 팁 DevServices 활용 개발 환경에서는 DevServices를 사용하면 별도의 데이터베이스 설치 없이 개발할 수 있습니다:\n# 개발 환경에서는 DevServices가 자동으로 PostgreSQL 컨테이너 실행 %dev.quarkus.devservices.enabled=true %test.quarkus.devservices.enabled=true # 특정 데이터베이스 버전 지정 quarkus.datasource.devservices.image-name=postgres:14 데이터 초기화 @ApplicationScoped public class DataInitializer { @Inject UserService userService; @Inject PostService postService; void onStart(@Observes StartupEvent ev) { // 개발 환경에서만 실행 if (Profile.of(\u0026#34;dev\u0026#34;).equals(Profile.getCurrent())) { initializeData(); } } @Transactional void initializeData() { // 테스트 데이터 생성 User user1 = userService.createUser(\u0026#34;john@example.com\u0026#34;, \u0026#34;John Doe\u0026#34;); User user2 = userService.createUser(\u0026#34;jane@example.com\u0026#34;, \u0026#34;Jane Smith\u0026#34;); postService.createPost(user1.id, \u0026#34;First Post\u0026#34;, \u0026#34;This is my first post\u0026#34;); postService.createPost(user2.id, \u0026#34;Another Post\u0026#34;, \u0026#34;Hello world!\u0026#34;); } } Spring Boot와의 주요 차이점 Panache 패턴: Repository 인터페이스 구현이 불필요 빠른 시작: 네이티브 이미지에서 빠른 부팅 시간 DevServices: 개발 환경 자동 구성 설정 방식: application.properties 중심 의존성 주입: CDI 기반으로 @Inject 사용 마무리 Quarkus JPA는 Spring Boot JPA와 매우 유사하면서도 더 간단하고 성능이 좋습니다. 특히 Panache 패턴을 사용하면 보일러플레이트 코드를 크게 줄일 수 있어서 개발 생산성이 향상됩니다.\n클라우드 네이티브 환경에서 빠른 시작 시간과 적은 메모리 사용량이 중요하다면 Quarkus JPA를 적극 추천합니다. 기존 JPA 지식이 있다면 러닝 커브도 거의 없어서 쉽게 적응할 수 있을 것입니다.\n다음 포스트에서는 Quarkus에서 Redis 캐싱과 메시징 시스템 연동에 대해 다뤄보겠습니다.\n"},{"section":"Blog","slug":"/kigo.github.io/blog/vscode-optimization/","title":"VS Code 개발 환경 최적화하기","description":"개발 생산성을 높이는 VS Code 설정과 확장 프로그램들을 소개합니다.","date":"2025년 8월 2일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"개발도구","tags":"VS Code, 개발환경, 생산성, 확장프로그램","content":"개발자에게 있어 에디터는 가장 중요한 도구 중 하나입니다. 오늘은 VS Code를 더욱 효율적으로 사용하는 방법들을 공유해보려고 합니다.\n필수 확장 프로그램들 1. 코드 품질 관리 ESLint: JavaScript/TypeScript 코드 품질 관리 Prettier: 코드 자동 포맷팅 SonarLint: 실시간 코드 분석 2. 개발 생산성 GitLens: Git 기능 강화 Live Server: 실시간 웹 페이지 미리보기 Auto Rename Tag: HTML 태그 자동 리네임 3. 언어별 지원 Python: Python 개발 지원 Go: Go 언어 지원 Docker: 컨테이너 개발 지원 유용한 설정들 자동 저장 및 포맷팅 { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.formatOnPaste\u0026#34;: true, \u0026#34;files.autoSave\u0026#34;: \u0026#34;afterDelay\u0026#34; } 에디터 개선 { \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.lineHeight\u0026#34;: 1.5, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Fira Code\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true } 키보드 단축키 커스터마이징 자주 사용하는 기능들을 빠르게 접근할 수 있도록 단축키를 설정해보세요:\nCtrl+Shift+P: 명령 팔레트 Ctrl+`: 터미널 토글 Alt+Up/Down: 라인 이동 테마 추천 개발하기 편안한 눈에 좋은 테마들:\nOne Dark Pro: 인기 있는 다크 테마 Material Theme: 구글 머티리얼 디자인 Dracula: 세련된 다크 테마 마무리 VS Code의 강력함은 확장성에 있습니다. 자신의 개발 스타일에 맞게 커스터마이징해서 생산성을 높여보세요!\n어떤 VS Code 팁이나 확장 프로그램을 추천하시나요? 댓글로 공유해주세요! 🚀\n"},{"section":"Blog","slug":"/kigo.github.io/blog/react-hooks-guide/","title":"React 함수형 컴포넌트와 Hooks 사용법","description":"React의 함수형 컴포넌트와 주요 Hooks들의 사용법을 예제와 함께 알아봅니다.","date":"2025년 8월 1일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"웹개발","tags":"React, Hooks, JavaScript, 프론트엔드","content":"React 16.8에서 도입된 Hooks는 함수형 컴포넌트에서도 상태 관리와 생명주기 기능을 사용할 수 있게 해주었습니다. 오늘은 주요 Hooks들의 사용법을 알아보겠습니다.\nuseState - 상태 관리 가장 기본적인 Hook으로, 함수형 컴포넌트에서 상태를 관리할 수 있습니다.\nimport React, { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;현재 카운트: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; 증가 \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count - 1)}\u0026gt; 감소 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } useEffect - 사이드 이펙트 처리 컴포넌트의 생명주기와 관련된 작업을 처리합니다.\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; function UserProfile({ userId }) { const [user, setUser] = useState(null); const [loading, setLoading] = useState(true); useEffect(() =\u0026gt; { // 사용자 정보 로드 const fetchUser = async () =\u0026gt; { setLoading(true); try { const response = await fetch(`/api/users/${userId}`); const userData = await response.json(); setUser(userData); } catch (error) { console.error(\u0026#39;사용자 정보 로드 실패:\u0026#39;, error); } finally { setLoading(false); } }; fetchUser(); }, [userId]); // userId가 변경될 때마다 실행 if (loading) return \u0026lt;div\u0026gt;로딩 중...\u0026lt;/div\u0026gt;; if (!user) return \u0026lt;div\u0026gt;사용자를 찾을 수 없습니다.\u0026lt;/div\u0026gt;; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{user.name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{user.email}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } useContext - 전역 상태 관리 컴포넌트 트리 전체에서 데이터를 공유할 때 사용합니다.\nimport React, { createContext, useContext, useState } from \u0026#39;react\u0026#39;; // 테마 컨텍스트 생성 const ThemeContext = createContext(); // 테마 제공자 컴포넌트 function ThemeProvider({ children }) { const [theme, setTheme] = useState(\u0026#39;light\u0026#39;); const toggleTheme = () =\u0026gt; { setTheme(theme === \u0026#39;light\u0026#39; ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39;); }; return ( \u0026lt;ThemeContext.Provider value={{ theme, toggleTheme }}\u0026gt; {children} \u0026lt;/ThemeContext.Provider\u0026gt; ); } // 테마를 사용하는 컴포넌트 function ThemedButton() { const { theme, toggleTheme } = useContext(ThemeContext); return ( \u0026lt;button onClick={toggleTheme} style={{ backgroundColor: theme === \u0026#39;light\u0026#39; ? \u0026#39;#fff\u0026#39; : \u0026#39;#333\u0026#39;, color: theme === \u0026#39;light\u0026#39; ? \u0026#39;#333\u0026#39; : \u0026#39;#fff\u0026#39; }} \u0026gt; {theme === \u0026#39;light\u0026#39; ? \u0026#39;다크 모드\u0026#39; : \u0026#39;라이트 모드\u0026#39;} \u0026lt;/button\u0026gt; ); } useMemo - 성능 최적화 비용이 큰 계산의 결과를 메모이제이션합니다.\nimport React, { useState, useMemo } from \u0026#39;react\u0026#39;; function ExpensiveComponent({ items }) { const [filter, setFilter] = useState(\u0026#39;\u0026#39;); // 필터링된 아이템들을 메모이제이션 const filteredItems = useMemo(() =\u0026gt; { console.log(\u0026#39;필터링 계산 실행\u0026#39;); return items.filter(item =\u0026gt; item.name.toLowerCase().includes(filter.toLowerCase()) ); }, [items, filter]); return ( \u0026lt;div\u0026gt; \u0026lt;input value={filter} onChange={(e) =\u0026gt; setFilter(e.target.value)} placeholder=\u0026#34;검색어 입력\u0026#34; /\u0026gt; \u0026lt;ul\u0026gt; {filteredItems.map(item =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } useCallback - 함수 메모이제이션 함수를 메모이제이션하여 불필요한 리렌더링을 방지합니다.\nimport React, { useState, useCallback } from \u0026#39;react\u0026#39;; function TodoList() { const [todos, setTodos] = useState([]); const [newTodo, setNewTodo] = useState(\u0026#39;\u0026#39;); // 할 일 추가 함수를 메모이제이션 const addTodo = useCallback(() =\u0026gt; { if (newTodo.trim()) { setTodos(prev =\u0026gt; [...prev, { id: Date.now(), text: newTodo, completed: false }]); setNewTodo(\u0026#39;\u0026#39;); } }, [newTodo]); // 할 일 토글 함수를 메모이제이션 const toggleTodo = useCallback((id) =\u0026gt; { setTodos(prev =\u0026gt; prev.map(todo =\u0026gt; todo.id === id ? { ...todo, completed: !todo.completed } : todo )); }, []); return ( \u0026lt;div\u0026gt; \u0026lt;input value={newTodo} onChange={(e) =\u0026gt; setNewTodo(e.target.value)} placeholder=\u0026#34;새 할 일 입력\u0026#34; /\u0026gt; \u0026lt;button onClick={addTodo}\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {todos.map(todo =\u0026gt; ( \u0026lt;TodoItem key={todo.id} todo={todo} onToggle={toggleTodo} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } 마무리 React Hooks는 함수형 컴포넌트의 가능성을 크게 확장시켜주었습니다. 각 Hook의 특성을 이해하고 적절히 사용하면 더 깔끔하고 효율적인 React 애플리케이션을 만들 수 있습니다.\n다음에는 Custom Hooks 만들기에 대해 다뤄보겠습니다! 🎣\n"},{"section":"Blog","slug":"/kigo.github.io/blog/git-branching-strategy/","title":"Git 브랜치 전략과 협업 워크플로우","description":"효과적인 Git 브랜치 전략과 팀 협업을 위한 워크플로우에 대해 알아봅니다.","date":"2025년 7월 31일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"개발도구","tags":"Git, 브랜치전략, 협업, 버전관리","content":"팀 개발에서 Git을 효과적으로 사용하는 것은 매우 중요합니다. 오늘은 대표적인 Git 브랜치 전략들과 협업 워크플로우에 대해 알아보겠습니다.\nGit Flow 전략 Git Flow는 가장 널리 사용되는 브랜치 전략 중 하나입니다.\n브랜치 구조 main: 릴리즈된 안정적인 코드 develop: 개발 중인 코드가 모이는 브랜치 feature: 새로운 기능 개발 release: 릴리즈 준비 hotfix: 긴급 버그 수정 워크플로우 예시 # 새로운 기능 개발 시작 git checkout develop git pull origin develop git checkout -b feature/user-authentication # 기능 개발 완료 후 git checkout develop git merge feature/user-authentication git branch -d feature/user-authentication git push origin develop # 릴리즈 준비 git checkout develop git checkout -b release/v1.2.0 # 버그 수정 및 버전 업데이트 git checkout main git merge release/v1.2.0 git tag v1.2.0 git checkout develop git merge release/v1.2.0 GitHub Flow 전략 GitHub Flow는 더 간단한 브랜치 전략입니다.\n특징 main 브랜치만 사용 모든 작업은 feature 브랜치에서 Pull Request를 통한 코드 리뷰 자동화된 테스트와 배포 워크플로우 # 1. 새 브랜치 생성 git checkout main git pull origin main git checkout -b feature/add-search-functionality # 2. 작업 및 커밋 git add . git commit -m \u0026#34;Add search functionality\u0026#34; git push origin feature/add-search-functionality # 3. Pull Request 생성 (GitHub에서) # 4. 코드 리뷰 및 테스트 # 5. main 브랜치에 병합 효과적인 커밋 메시지 작성 커밋 메시지 규칙 타입(범위): 제목 상세 설명 푸터 타입 종류 feat: 새로운 기능 fix: 버그 수정 docs: 문서 변경 style: 코드 스타일 변경 refactor: 코드 리팩토링 test: 테스트 추가/수정 chore: 빌드 프로세스나 도구 변경 예시 feat(auth): 사용자 로그인 기능 추가 - JWT 토큰 기반 인증 구현 - 로그인 폼 UI 개발 - 세션 관리 로직 추가 Closes #123 협업을 위한 Git 설정 유용한 Git 설정 # 사용자 정보 설정 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your.email@example.com\u0026#34; # 에디터 설정 git config --global core.editor \u0026#34;code --wait\u0026#34; # 줄바꿈 처리 (Windows) git config --global core.autocrlf true # 줄바꿈 처리 (Mac/Linux) git config --global core.autocrlf input # Push 기본 설정 git config --global push.default current # 별칭 설정 git config --global alias.st status git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.unstage \u0026#39;reset HEAD --\u0026#39; 유용한 Git 명령어 # 변경사항 임시 저장 git stash git stash pop # 특정 커밋만 가져오기 git cherry-pick \u0026lt;commit-hash\u0026gt; # 커밋 히스토리 정리 git rebase -i HEAD~3 # 파일 변경사항 부분적으로 스테이징 git add -p # 브랜치 간 차이점 확인 git diff main..feature/branch # 로그 예쁘게 보기 git log --oneline --graph --all 코드 리뷰 가이드라인 Pull Request 작성 시 명확한 제목과 설명 변경사항 요약 테스트 방법 명시 스크린샷 첨부 (UI 변경 시) 리뷰어를 위한 팁 건설적인 피드백 코드 스타일 일관성 확인 성능 및 보안 관점 검토 테스트 커버리지 확인 마무리 좋은 Git 브랜치 전략과 워크플로우는 팀의 생산성을 크게 향상시킵니다. 팀의 규모와 프로젝트 특성에 맞는 전략을 선택하고, 일관성 있게 적용하는 것이 중요합니다.\n여러분의 팀은 어떤 Git 전략을 사용하고 계신가요? 경험을 공유해주세요! 🌿\n"},{"section":"Blog","slug":"/kigo.github.io/blog/docker-development-environment/","title":"Docker로 개발 환경 구축하기","description":"Docker를 활용한 일관된 개발 환경 구축 방법과 컨테이너 기반 개발 워크플로우를 알아봅니다.","date":"2025년 7월 30일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"DevOps, 컨테이너","tags":"Docker, DevOps, 컨테이너, 개발환경","content":"개발을 하다 보면 \u0026ldquo;내 컴퓨터에서는 잘 됐는데?\u0026ldquo;라는 말을 자주 듣게 됩니다. Docker를 사용하면 이런 문제를 해결하고 일관된 개발 환경을 구축할 수 있습니다.\nDocker란? Docker는 컨테이너 기반의 가상화 플랫폼입니다. 애플리케이션과 그 실행에 필요한 모든 것을 하나의 컨테이너로 패키징할 수 있습니다.\nDocker의 장점 일관성: 어디서든 동일한 환경 격리: 각 컨테이너는 독립적으로 실행 이식성: 어느 플랫폼에서든 실행 가능 효율성: 가상머신보다 가벼움 기본 Docker 명령어 이미지 관리 # 이미지 검색 docker search nginx # 이미지 다운로드 docker pull nginx:latest # 이미지 목록 확인 docker images # 이미지 삭제 docker rmi nginx:latest 컨테이너 관리 # 컨테이너 실행 docker run -d -p 80:80 --name my-nginx nginx # 실행 중인 컨테이너 확인 docker ps # 모든 컨테이너 확인 docker ps -a # 컨테이너 중지 docker stop my-nginx # 컨테이너 삭제 docker rm my-nginx Dockerfile 작성 Node.js 애플리케이션을 위한 Dockerfile 예시:\n# 베이스 이미지 설정 FROM node:18-alpine # 작업 디렉토리 설정 WORKDIR /app # 의존성 파일 복사 COPY package*.json ./ # 의존성 설치 RUN npm ci --only=production # 앱 소스 복사 COPY . . # 포트 노출 EXPOSE 3000 # 애플리케이션 실행 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] Docker Compose로 멀티 컨테이너 관리 여러 서비스를 함께 실행할 때는 Docker Compose를 사용합니다:\n# docker-compose.yml version: \u0026#39;3.8\u0026#39; services: web: build: . ports: - \u0026#34;3000:3000\u0026#34; environment: - NODE_ENV=development volumes: - .:/app - /app/node_modules depends_on: - db db: image: postgres:14 environment: POSTGRES_DB: myapp POSTGRES_USER: user POSTGRES_PASSWORD: password volumes: - postgres_data:/var/lib/postgresql/data ports: - \u0026#34;5432:5432\u0026#34; volumes: postgres_data: Docker Compose 명령어 # 서비스 시작 docker-compose up -d # 로그 확인 docker-compose logs -f # 서비스 중지 docker-compose down # 서비스 재시작 docker-compose restart 개발 환경 구축 예시 1. 개발용 Dockerfile FROM node:18-alpine WORKDIR /app # 개발 도구 설치 RUN apk add --no-cache git COPY package*.json ./ RUN npm install COPY . . EXPOSE 3000 # 개발 서버 실행 CMD [\u0026#34;npm\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;dev\u0026#34;] 2. .dockerignore 파일 node_modules npm-debug.log .git .gitignore README.md .env .env.local Dockerfile .dockerignore 유용한 Docker 팁 볼륨 마운트 # 로컬 디렉토리를 컨테이너에 마운트 docker run -v $(pwd):/app -p 3000:3000 my-app # 데이터 볼륨 사용 docker volume create my-data docker run -v my-data:/data my-app 환경 변수 설정 # 환경 변수 전달 docker run -e NODE_ENV=production my-app # .env 파일 사용 docker run --env-file .env my-app 네트워크 설정 # 사용자 정의 네트워크 생성 docker network create my-network # 네트워크에 컨테이너 연결 docker run --network my-network my-app 마무리 Docker는 현대 개발에서 필수적인 도구가 되었습니다. 처음에는 복잡해 보일 수 있지만, 익숙해지면 개발 효율성을 크게 향상시킬 수 있습니다.\n컨테이너 기반 개발에 관심이 있으시다면 Docker부터 시작해보세요! 🐳\n"},{"section":"Blog","slug":"/kigo.github.io/blog/javascript-es6-features/","title":"JavaScript ES6+ 핵심 기능들","description":"모던 JavaScript의 핵심 기능들을 예제와 함께 알아보고, 실무에서 어떻게 활용하는지 살펴봅니다.","date":"2025년 7월 29일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"JavaScript, 프론트엔드","tags":"JavaScript, ES6, 모던자바스크립트, 프론트엔드","content":"JavaScript ES6(ECMAScript 2015)부터 많은 새로운 기능들이 추가되었습니다. 오늘은 실무에서 자주 사용되는 핵심 기능들을 알아보겠습니다.\n1. let과 const 기존의 var 대신 블록 스코프를 가지는 let과 const를 사용합니다.\n// var의 문제점 for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 3, 3, 3 } // let으로 해결 for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 0, 1, 2 } // const로 상수 선언 const API_URL = \u0026#39;https://api.example.com\u0026#39;; const config = { apiKey: \u0026#39;your-api-key\u0026#39;, timeout: 5000 }; 2. 화살표 함수 (Arrow Functions) 더 간결한 함수 문법과 this 바인딩의 차이점:\n// 기존 함수 function add(a, b) { return a + b; } // 화살표 함수 const add = (a, b) =\u0026gt; a + b; // 배열 메서드와 함께 사용 const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map(n =\u0026gt; n * 2); const evens = numbers.filter(n =\u0026gt; n % 2 === 0); const sum = numbers.reduce((acc, n) =\u0026gt; acc + n, 0); // this 바인딩의 차이 class Timer { constructor() { this.seconds = 0; } start() { // 화살표 함수는 상위 스코프의 this를 사용 setInterval(() =\u0026gt; { this.seconds++; console.log(this.seconds); }, 1000); } } 3. 템플릿 리터럴 (Template Literals) 문자열 보간과 멀티라인 문자열:\nconst name = \u0026#39;Kigo\u0026#39;; const age = 30; // 문자열 보간 const greeting = `안녕하세요, ${name}님! 나이가 ${age}세이시군요.`; // 멀티라인 문자열 const html = ` \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // 태그드 템플릿 function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#39;\u0026#39;; return result + string + value; }, \u0026#39;\u0026#39;); } const message = highlight`Hello ${name}, you are ${age} years old!`; 4. 구조 분해 할당 (Destructuring) 배열과 객체에서 값을 추출하는 간편한 방법:\n// 배열 구조 분해 const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(rest); // [3, 4, 5] // 객체 구조 분해 const user = { name: \u0026#39;Kigo\u0026#39;, age: 30, email: \u0026#39;kigo@example.com\u0026#39; }; const { name, age, email } = user; // 새로운 이름으로 할당 const { name: userName, age: userAge } = user; // 기본값 설정 const { name, country = \u0026#39;Korea\u0026#39; } = user; // 함수 매개변수에서 사용 function greet({ name, age }) { return `Hello ${name}, you are ${age} years old!`; } greet(user); 5. 스프레드 연산자 (Spread Operator) 배열과 객체를 전개하는 문법:\n// 배열 합치기 const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // 배열 복사 const original = [1, 2, 3]; const copy = [...original]; // 함수 호출에서 사용 function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 객체 합치기 const obj1 = { a: 1, b: 2 }; const obj2 = { c: 3, d: 4 }; const merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 } // 객체 속성 오버라이드 const user = { name: \u0026#39;John\u0026#39;, age: 30 }; const updatedUser = { ...user, age: 31 }; 6. 기본 매개변수 (Default Parameters) 함수 매개변수의 기본값 설정:\n// 기본 매개변수 function greet(name = \u0026#39;World\u0026#39;, punctuation = \u0026#39;!\u0026#39;) { return `Hello, ${name}${punctuation}`; } console.log(greet()); // \u0026#34;Hello, World!\u0026#34; console.log(greet(\u0026#39;Kigo\u0026#39;)); // \u0026#34;Hello, Kigo!\u0026#34; console.log(greet(\u0026#39;Kigo\u0026#39;, \u0026#39;?\u0026#39;)); // \u0026#34;Hello, Kigo?\u0026#34; // 함수를 기본값으로 사용 function getDefaultName() { return \u0026#39;Anonymous\u0026#39;; } function welcome(name = getDefaultName()) { return `Welcome, ${name}!`; } 7. 모듈 (Modules) ES6 모듈 시스템:\n// math.js export const PI = 3.14159; export function add(a, b) { return a + b; } export function multiply(a, b) { return a * b; } // 기본 내보내기 export default function subtract(a, b) { return a - b; } // main.js import subtract, { PI, add, multiply } from \u0026#39;./math.js\u0026#39;; // 모든 것을 가져오기 import * as math from \u0026#39;./math.js\u0026#39;; console.log(math.PI); console.log(math.add(2, 3)); 8. 클래스 (Classes) 객체 지향 프로그래밍을 위한 클래스 문법:\nclass Animal { constructor(name, species) { this.name = name; this.species = species; } speak() { return `${this.name} makes a sound`; } // 정적 메서드 static getKingdom() { return \u0026#39;Animalia\u0026#39;; } } class Dog extends Animal { constructor(name, breed) { super(name, \u0026#39;Canis lupus\u0026#39;); this.breed = breed; } speak() { return `${this.name} barks`; } // getter get info() { return `${this.name} is a ${this.breed}`; } // setter set nickname(nick) { this.nick = nick; } } const dog = new Dog(\u0026#39;Buddy\u0026#39;, \u0026#39;Golden Retriever\u0026#39;); console.log(dog.speak()); // \u0026#34;Buddy barks\u0026#34; console.log(dog.info); // \u0026#34;Buddy is a Golden Retriever\u0026#34; 9. Promise와 async/await 비동기 처리를 위한 현대적인 방법:\n// Promise function fetchData(url) { return new Promise((resolve, reject) =\u0026gt; { fetch(url) .then(response =\u0026gt; { if (!response.ok) { throw new Error(\u0026#39;Network response was not ok\u0026#39;); } return response.json(); }) .then(data =\u0026gt; resolve(data)) .catch(error =\u0026gt; reject(error)); }); } // async/await 사용 async function getData() { try { const data = await fetchData(\u0026#39;https://api.example.com/data\u0026#39;); console.log(data); return data; } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error); } } // 여러 비동기 작업 병렬 처리 async function fetchMultipleData() { try { const [users, posts, comments] = await Promise.all([ fetchData(\u0026#39;/api/users\u0026#39;), fetchData(\u0026#39;/api/posts\u0026#39;), fetchData(\u0026#39;/api/comments\u0026#39;) ]); return { users, posts, comments }; } catch (error) { console.error(\u0026#39;Error fetching data:\u0026#39;, error); } } 마무리 ES6+ 기능들은 JavaScript를 더욱 강력하고 표현력 있는 언어로 만들어주었습니다. 이러한 기능들을 잘 활용하면 더 깔끔하고 유지보수하기 쉬운 코드를 작성할 수 있습니다.\n모던 JavaScript의 다른 기능들도 궁금하시다면 댓글로 알려주세요! 🚀\n"},{"section":"Blog","slug":"/kigo.github.io/blog/rest-api-design/","title":"REST API 설계 베스트 프랙티스","description":"확장 가능하고 유지보수가 용이한 REST API를 설계하기 위한 핵심 원칙과 실무 가이드를 알아봅니다.","date":"2022년 4월 7일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"백엔드, API","tags":"REST API, API 설계, 백엔드, 웹 개발","content":"잘 설계된 REST API는 개발자 경험을 향상시키고 시스템의 확장성을 보장합니다. 실제 프로젝트에서 적용할 수 있는 REST API 설계 원칙과 베스트 프랙티스를 Spring Boot 예제와 함께 알아보겠습니다.\nREST API 설계 원칙 1. 리소스 중심 URL 설계 // ❌ 잘못된 예시 - 동사 사용 @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class BadUserController { @PostMapping(\u0026#34;/createUser\u0026#34;) public User createUser(@RequestBody CreateUserRequest request) { ... } @PostMapping(\u0026#34;/deleteUser/{id}\u0026#34;) public void deleteUser(@PathVariable Long id) { ... } @GetMapping(\u0026#34;/getUsersByStatus/{status}\u0026#34;) public List\u0026lt;User\u0026gt; getUsersByStatus(@PathVariable String status) { ... } } // ✅ 올바른 예시 - 명사 사용, HTTP 메서드로 동작 표현 @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) @Validated @Slf4j public class UserController { private final UserService userService; @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity\u0026lt;UserResponse\u0026gt; createUser( @Valid @RequestBody CreateUserRequest request) { User user = userService.createUser(request); UserResponse response = UserResponse.from(user); URI location = ServletUriComponentsBuilder .fromCurrentRequest() .path(\u0026#34;/{id}\u0026#34;) .buildAndExpand(user.getId()) .toUri(); return ResponseEntity.created(location).body(response); } @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserResponse\u0026gt; getUser(@PathVariable Long id) { User user = userService.findById(id); return ResponseEntity.ok(UserResponse.from(user)); } @GetMapping public ResponseEntity\u0026lt;PagedResponse\u0026lt;UserResponse\u0026gt;\u0026gt; getUsers( @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;20\u0026#34;) int size, @RequestParam(required = false) String status, @RequestParam(defaultValue = \u0026#34;createdAt\u0026#34;) String sortBy, @RequestParam(defaultValue = \u0026#34;desc\u0026#34;) String sortDir) { UserSearchCriteria criteria = UserSearchCriteria.builder() .status(status) .page(page) .size(size) .sortBy(sortBy) .sortDirection(sortDir) .build(); Page\u0026lt;User\u0026gt; users = userService.findUsers(criteria); PagedResponse\u0026lt;UserResponse\u0026gt; response = PagedResponse.of( users.map(UserResponse::from) ); return ResponseEntity.ok(response); } @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserResponse\u0026gt; updateUser( @PathVariable Long id, @Valid @RequestBody UpdateUserRequest request) { User user = userService.updateUser(id, request); return ResponseEntity.ok(UserResponse.from(user)); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) @ResponseStatus(HttpStatus.NO_CONTENT) public ResponseEntity\u0026lt;Void\u0026gt; deleteUser(@PathVariable Long id) { userService.deleteUser(id); return ResponseEntity.noContent().build(); } } 2. 중첩 리소스 설계 @RestController @RequestMapping(\u0026#34;/api/users/{userId}/posts\u0026#34;) public class UserPostController { private final PostService postService; @GetMapping public ResponseEntity\u0026lt;PagedResponse\u0026lt;PostResponse\u0026gt;\u0026gt; getUserPosts( @PathVariable Long userId, @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) int size) { Page\u0026lt;Post\u0026gt; posts = postService.findByUserId(userId, PageRequest.of(page, size, Sort.by(\u0026#34;createdAt\u0026#34;).descending())); PagedResponse\u0026lt;PostResponse\u0026gt; response = PagedResponse.of( posts.map(PostResponse::from) ); return ResponseEntity.ok(response); } @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity\u0026lt;PostResponse\u0026gt; createPost( @PathVariable Long userId, @Valid @RequestBody CreatePostRequest request) { Post post = postService.createPost(userId, request); PostResponse response = PostResponse.from(post); URI location = ServletUriComponentsBuilder .fromCurrentRequest() .path(\u0026#34;/{postId}\u0026#34;) .buildAndExpand(post.getId()) .toUri(); return ResponseEntity.created(location).body(response); } } 요청/응답 DTO 설계 요청 DTO @Data @Builder @NoArgsConstructor @AllArgsConstructor public class CreateUserRequest { @NotBlank(message = \u0026#34;이메일은 필수입니다\u0026#34;) @Email(message = \u0026#34;올바른 이메일 형식이 아닙니다\u0026#34;) @Size(max = 100, message = \u0026#34;이메일은 100자를 초과할 수 없습니다\u0026#34;) private String email; @NotBlank(message = \u0026#34;이름은 필수입니다\u0026#34;) @Size(min = 2, max = 50, message = \u0026#34;이름은 2자 이상 50자 이하여야 합니다\u0026#34;) private String name; @Size(max = 500, message = \u0026#34;소개는 500자를 초과할 수 없습니다\u0026#34;) private String bio; @Valid private CreateAddressRequest address; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) @Past(message = \u0026#34;생년월일은 과거 날짜여야 합니다\u0026#34;) private LocalDate birthDate; } @Data @Builder @NoArgsConstructor @AllArgsConstructor public class UpdateUserRequest { @Size(min = 2, max = 50, message = \u0026#34;이름은 2자 이상 50자 이하여야 합니다\u0026#34;) private String name; @Size(max = 500, message = \u0026#34;소개는 500자를 초과할 수 없습니다\u0026#34;) private String bio; @Valid private UpdateAddressRequest address; } 응답 DTO @Data @Builder @NoArgsConstructor @AllArgsConstructor public class UserResponse { private Long id; private String email; private String name; private String bio; private AddressResponse address; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate birthDate; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss\u0026#34;) private LocalDateTime createdAt; @JsonFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss\u0026#34;) private LocalDateTime updatedAt; // 관련 리소스 링크 private Map\u0026lt;String, String\u0026gt; links; public static UserResponse from(User user) { UserResponseBuilder builder = UserResponse.builder() .id(user.getId()) .email(user.getEmail()) .name(user.getName()) .bio(user.getBio()) .birthDate(user.getBirthDate()) .createdAt(user.getCreatedAt()) .updatedAt(user.getUpdatedAt()); if (user.getAddress() != null) { builder.address(AddressResponse.from(user.getAddress())); } // HATEOAS 링크 추가 Map\u0026lt;String, String\u0026gt; links = new HashMap\u0026lt;\u0026gt;(); links.put(\u0026#34;self\u0026#34;, \u0026#34;/api/users/\u0026#34; + user.getId()); links.put(\u0026#34;posts\u0026#34;, \u0026#34;/api/users/\u0026#34; + user.getId() + \u0026#34;/posts\u0026#34;); links.put(\u0026#34;profile\u0026#34;, \u0026#34;/api/users/\u0026#34; + user.getId() + \u0026#34;/profile\u0026#34;); builder.links(links); return builder.build(); } } 페이징 응답 @Data @Builder @NoArgsConstructor @AllArgsConstructor public class PagedResponse\u0026lt;T\u0026gt; { private List\u0026lt;T\u0026gt; content; private PageInfo page; private Map\u0026lt;String, String\u0026gt; links; @Data @Builder @NoArgsConstructor @AllArgsConstructor public static class PageInfo { private int number; private int size; private long totalElements; private int totalPages; private boolean first; private boolean last; private boolean hasNext; private boolean hasPrevious; } public static \u0026lt;T\u0026gt; PagedResponse\u0026lt;T\u0026gt; of(Page\u0026lt;T\u0026gt; page) { PageInfo pageInfo = PageInfo.builder() .number(page.getNumber()) .size(page.getSize()) .totalElements(page.getTotalElements()) .totalPages(page.getTotalPages()) .first(page.isFirst()) .last(page.isLast()) .hasNext(page.hasNext()) .hasPrevious(page.hasPrevious()) .build(); // 페이징 링크 생성 Map\u0026lt;String, String\u0026gt; links = createPaginationLinks(page); return PagedResponse.\u0026lt;T\u0026gt;builder() .content(page.getContent()) .page(pageInfo) .links(links) .build(); } private static Map\u0026lt;String, String\u0026gt; createPaginationLinks(Page\u0026lt;?\u0026gt; page) { Map\u0026lt;String, String\u0026gt; links = new HashMap\u0026lt;\u0026gt;(); String baseUrl = ServletUriComponentsBuilder.fromCurrentRequest() .replaceQueryParam(\u0026#34;page\u0026#34;, \u0026#34;{page}\u0026#34;) .toUriString(); links.put(\u0026#34;self\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, String.valueOf(page.getNumber()))); if (page.hasNext()) { links.put(\u0026#34;next\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, String.valueOf(page.getNumber() + 1))); } if (page.hasPrevious()) { links.put(\u0026#34;prev\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, String.valueOf(page.getNumber() - 1))); } links.put(\u0026#34;first\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, \u0026#34;0\u0026#34;)); links.put(\u0026#34;last\u0026#34;, baseUrl.replace(\u0026#34;{page}\u0026#34;, String.valueOf(page.getTotalPages() - 1))); return links; } } 에러 핸들링 표준 에러 응답 @Data @Builder @NoArgsConstructor @AllArgsConstructor public class ErrorResponse { private String error; private String message; private int status; private String path; private LocalDateTime timestamp; private List\u0026lt;FieldError\u0026gt; fieldErrors; private String correlationId; @Data @Builder @NoArgsConstructor @AllArgsConstructor public static class FieldError { private String field; private Object rejectedValue; private String message; } } @RestControllerAdvice @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public ErrorResponse handleValidationException( MethodArgumentNotValidException ex, HttpServletRequest request) { List\u0026lt;ErrorResponse.FieldError\u0026gt; fieldErrors = ex.getBindingResult() .getFieldErrors() .stream() .map(error -\u0026gt; ErrorResponse.FieldError.builder() .field(error.getField()) .rejectedValue(error.getRejectedValue()) .message(error.getDefaultMessage()) .build()) .collect(Collectors.toList()); String correlationId = request.getHeader(\u0026#34;X-Correlation-ID\u0026#34;); return ErrorResponse.builder() .error(\u0026#34;VALIDATION_FAILED\u0026#34;) .message(\u0026#34;입력값 검증에 실패했습니다\u0026#34;) .status(HttpStatus.BAD_REQUEST.value()) .path(request.getRequestURI()) .timestamp(LocalDateTime.now()) .fieldErrors(fieldErrors) .correlationId(correlationId) .build(); } @ExceptionHandler(EntityNotFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ErrorResponse handleEntityNotFoundException( EntityNotFoundException ex, HttpServletRequest request) { return ErrorResponse.builder() .error(\u0026#34;RESOURCE_NOT_FOUND\u0026#34;) .message(ex.getMessage()) .status(HttpStatus.NOT_FOUND.value()) .path(request.getRequestURI()) .timestamp(LocalDateTime.now()) .correlationId(request.getHeader(\u0026#34;X-Correlation-ID\u0026#34;)) .build(); } @ExceptionHandler(DataIntegrityViolationException.class) @ResponseStatus(HttpStatus.CONFLICT) public ErrorResponse handleDataIntegrityViolation( DataIntegrityViolationException ex, HttpServletRequest request) { String message = \u0026#34;데이터 무결성 제약조건 위반\u0026#34;; if (ex.getMessage().contains(\u0026#34;email\u0026#34;)) { message = \u0026#34;이미 존재하는 이메일입니다\u0026#34;; } return ErrorResponse.builder() .error(\u0026#34;DATA_INTEGRITY_VIOLATION\u0026#34;) .message(message) .status(HttpStatus.CONFLICT.value()) .path(request.getRequestURI()) .timestamp(LocalDateTime.now()) .correlationId(request.getHeader(\u0026#34;X-Correlation-ID\u0026#34;)) .build(); } } API 버전 관리 URL 기반 버전 관리 @RestController @RequestMapping(\u0026#34;/api/v1/users\u0026#34;) public class UserV1Controller { @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserV1Response\u0026gt; getUser(@PathVariable Long id) { // v1 구현 } } @RestController @RequestMapping(\u0026#34;/api/v2/users\u0026#34;) public class UserV2Controller { @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;UserV2Response\u0026gt; getUser(@PathVariable Long id) { // v2 구현 - 새로운 필드 추가 } } 헤더 기반 버전 관리 @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @GetMapping(value = \u0026#34;/{id}\u0026#34;, headers = \u0026#34;API-Version=v1\u0026#34;) public ResponseEntity\u0026lt;UserV1Response\u0026gt; getUserV1(@PathVariable Long id) { // v1 구현 } @GetMapping(value = \u0026#34;/{id}\u0026#34;, headers = \u0026#34;API-Version=v2\u0026#34;) public ResponseEntity\u0026lt;UserV2Response\u0026gt; getUserV2(@PathVariable Long id) { // v2 구현 } } API 문서화 OpenAPI 3.0 설정 @Configuration @OpenAPIDefinition( info = @Info( title = \u0026#34;사용자 관리 API\u0026#34;, version = \u0026#34;v1.0.0\u0026#34;, description = \u0026#34;사용자 등록, 조회, 수정, 삭제 기능을 제공하는 REST API\u0026#34;, contact = @Contact( name = \u0026#34;Kigo\u0026#34;, email = \u0026#34;support@kigo.dev\u0026#34;, url = \u0026#34;https://kigo.dev\u0026#34; ), license = @License( name = \u0026#34;MIT License\u0026#34;, url = \u0026#34;https://opensource.org/licenses/MIT\u0026#34; ) ), servers = { @Server(url = \u0026#34;https://api.kigo.dev\u0026#34;, description = \u0026#34;운영 서버\u0026#34;), @Server(url = \u0026#34;https://staging-api.kigo.dev\u0026#34;, description = \u0026#34;스테이징 서버\u0026#34;), @Server(url = \u0026#34;http://localhost:8080\u0026#34;, description = \u0026#34;로컬 개발 서버\u0026#34;) } ) public class OpenApiConfig { @Bean public OpenAPI customOpenAPI() { return new OpenAPI() .components(new Components() .addSecuritySchemes(\u0026#34;bearer-jwt\u0026#34;, new SecurityScheme() .type(SecurityScheme.Type.HTTP) .scheme(\u0026#34;bearer\u0026#34;) .bearerFormat(\u0026#34;JWT\u0026#34;) .description(\u0026#34;JWT 토큰을 입력하세요\u0026#34;))) .addSecurityItem(new SecurityRequirement().addList(\u0026#34;bearer-jwt\u0026#34;)); } } @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) @Tag(name = \u0026#34;사용자 관리\u0026#34;, description = \u0026#34;사용자 CRUD 작업을 위한 API\u0026#34;) public class UserController { @Operation( summary = \u0026#34;사용자 생성\u0026#34;, description = \u0026#34;새로운 사용자를 생성합니다.\u0026#34;, responses = { @ApiResponse( responseCode = \u0026#34;201\u0026#34;, description = \u0026#34;사용자 생성 성공\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = UserResponse.class) ) ), @ApiResponse( responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;잘못된 요청\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = ErrorResponse.class) ) ) } ) @PostMapping @ResponseStatus(HttpStatus.CREATED) public ResponseEntity\u0026lt;UserResponse\u0026gt; createUser( @Valid @RequestBody @Parameter(description = \u0026#34;사용자 생성 요청 정보\u0026#34;, required = true) CreateUserRequest request) { // 구현 } @Operation( summary = \u0026#34;사용자 목록 조회\u0026#34;, description = \u0026#34;페이징과 필터링이 적용된 사용자 목록을 조회합니다.\u0026#34; ) @GetMapping public ResponseEntity\u0026lt;PagedResponse\u0026lt;UserResponse\u0026gt;\u0026gt; getUsers( @Parameter(description = \u0026#34;페이지 번호 (0부터 시작)\u0026#34;, example = \u0026#34;0\u0026#34;) @RequestParam(defaultValue = \u0026#34;0\u0026#34;) int page, @Parameter(description = \u0026#34;페이지 크기\u0026#34;, example = \u0026#34;20\u0026#34;) @RequestParam(defaultValue = \u0026#34;20\u0026#34;) int size, @Parameter(description = \u0026#34;사용자 상태 필터\u0026#34;, example = \u0026#34;ACTIVE\u0026#34;) @RequestParam(required = false) String status) { // 구현 } } 성능 최적화 캐싱 전략 @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @GetMapping(\u0026#34;/{id}\u0026#34;) @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public ResponseEntity\u0026lt;UserResponse\u0026gt; getUser(@PathVariable Long id) { User user = userService.findById(id); return ResponseEntity .ok() .cacheControl(CacheControl.maxAge(5, TimeUnit.MINUTES)) .eTag(String.valueOf(user.getVersion())) .body(UserResponse.from(user)); } @PutMapping(\u0026#34;/{id}\u0026#34;) @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public ResponseEntity\u0026lt;UserResponse\u0026gt; updateUser( @PathVariable Long id, @RequestHeader(value = \u0026#34;If-Match\u0026#34;, required = false) String ifMatch, @Valid @RequestBody UpdateUserRequest request) { // 낙관적 잠금 확인 if (ifMatch != null) { User currentUser = userService.findById(id); if (!ifMatch.equals(String.valueOf(currentUser.getVersion()))) { return ResponseEntity.status(HttpStatus.PRECONDITION_FAILED).build(); } } User user = userService.updateUser(id, request); return ResponseEntity .ok() .eTag(String.valueOf(user.getVersion())) .body(UserResponse.from(user)); } } 압축 설정 # application.yml server: compression: enabled: true mime-types: - application/json - application/xml - text/html - text/xml - text/plain min-response-size: 1024 보안 설정 CORS 설정 @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/api/**\u0026#34;) .allowedOriginPatterns(\u0026#34;https://*.kigo.dev\u0026#34;, \u0026#34;http://localhost:*\u0026#34;) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;PATCH\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;) .allowCredentials(true) .maxAge(3600); } } 이러한 베스트 프랙티스를 통해 개발자 친화적이고 확장 가능한 REST API를 구축할 수 있습니다. 일관된 설계 원칙을 적용하고 적절한 문서화를 통해 API의 품질과 사용성을 향상시키시기 바랍니다.\n"},{"section":"Blog","slug":"/kigo.github.io/blog/microservices-architecture/","title":"Spring Boot를 활용한 마이크로서비스 아키텍처","description":"Spring Boot와 Spring Cloud를 사용하여 확장 가능한 마이크로서비스 아키텍처를 구축하는 방법을 알아봅니다.","date":"2022년 4월 6일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"백엔드, 아키텍처","tags":"Spring Boot, 마이크로서비스, Spring Cloud, 아키텍처","content":"모놀리식 애플리케이션의 한계를 넘어 확장 가능하고 유연한 시스템을 구축하기 위해 마이크로서비스 아키텍처가 주목받고 있습니다. Spring Boot와 Spring Cloud 생태계를 활용하여 실제 운영 환경에서 사용할 수 있는 마이크로서비스를 구축하는 방법을 알아보겠습니다.\n마이크로서비스 아키텍처 개요 서비스 분해 전략 # 도메인별 서비스 분리 예시 services: user-service: responsibility: \u0026#34;사용자 관리, 인증\u0026#34; database: \u0026#34;user_db\u0026#34; port: 8081 product-service: responsibility: \u0026#34;상품 관리, 카탈로그\u0026#34; database: \u0026#34;product_db\u0026#34; port: 8082 order-service: responsibility: \u0026#34;주문 처리, 결제\u0026#34; database: \u0026#34;order_db\u0026#34; port: 8083 notification-service: responsibility: \u0026#34;알림, 이메일 발송\u0026#34; database: \u0026#34;notification_db\u0026#34; port: 8084 서비스 디스커버리 Eureka 서버 설정 @SpringBootApplication @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } # application.yml (Eureka Server) server: port: 8761 eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ server: enable-self-preservation: false 서비스 등록 (클라이언트) @SpringBootApplication @EnableEurekaClient @EnableJpaAuditing public class UserServiceApplication { public static void main(String[] args) { SpringApplication.run(UserServiceApplication.class, args); } } # application.yml (User Service) server: port: 8081 spring: application: name: user-service datasource: url: jdbc:postgresql://localhost:5432/user_db username: ${DB_USERNAME:user} password: ${DB_PASSWORD:password} eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true lease-renewal-interval-in-seconds: 30 lease-expiration-duration-in-seconds: 90 API 게이트웨이 Spring Cloud Gateway 설정 @SpringBootApplication public class ApiGatewayApplication { public static void main(String[] args) { SpringApplication.run(ApiGatewayApplication.class, args); } @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return builder.routes() .route(\u0026#34;user-service\u0026#34;, r -\u0026gt; r.path(\u0026#34;/api/users/**\u0026#34;) .filters(f -\u0026gt; f .stripPrefix(1) .addRequestHeader(\u0026#34;X-Gateway-Name\u0026#34;, \u0026#34;api-gateway\u0026#34;) .circuitBreaker(c -\u0026gt; c.setName(\u0026#34;user-service-cb\u0026#34;))) .uri(\u0026#34;lb://user-service\u0026#34;)) .route(\u0026#34;product-service\u0026#34;, r -\u0026gt; r.path(\u0026#34;/api/products/**\u0026#34;) .filters(f -\u0026gt; f .stripPrefix(1) .retry(3)) .uri(\u0026#34;lb://product-service\u0026#34;)) .route(\u0026#34;order-service\u0026#34;, r -\u0026gt; r.path(\u0026#34;/api/orders/**\u0026#34;) .filters(f -\u0026gt; f .stripPrefix(1) .requestRateLimiter(c -\u0026gt; c .setRateLimiter(redisRateLimiter()) .setKeyResolver(userKeyResolver()))) .uri(\u0026#34;lb://order-service\u0026#34;)) .build(); } @Bean public RedisRateLimiter redisRateLimiter() { return new RedisRateLimiter(10, 20, 1); } @Bean public KeyResolver userKeyResolver() { return exchange -\u0026gt; exchange.getRequest() .getHeaders() .getFirst(\u0026#34;X-User-Id\u0026#34;) != null ? Mono.just(exchange.getRequest().getHeaders().getFirst(\u0026#34;X-User-Id\u0026#34;)) : Mono.just(\u0026#34;anonymous\u0026#34;); } } 글로벌 필터 @Component @Slf4j public class LoggingGlobalFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); String path = request.getPath().pathWithinApplication().value(); String method = request.getMethod().name(); String correlationId = UUID.randomUUID().toString(); log.info(\u0026#34;요청 시작 - Method: {}, Path: {}, CorrelationId: {}\u0026#34;, method, path, correlationId); // 요청에 상관관계 ID 추가 ServerHttpRequest mutatedRequest = request.mutate() .header(\u0026#34;X-Correlation-ID\u0026#34;, correlationId) .build(); ServerWebExchange mutatedExchange = exchange.mutate() .request(mutatedRequest) .build(); long startTime = System.currentTimeMillis(); return chain.filter(mutatedExchange) .doOnSuccess(aVoid -\u0026gt; { long duration = System.currentTimeMillis() - startTime; log.info(\u0026#34;요청 완료 - Path: {}, Duration: {}ms, CorrelationId: {}\u0026#34;, path, duration, correlationId); }) .doOnError(throwable -\u0026gt; { long duration = System.currentTimeMillis() - startTime; log.error(\u0026#34;요청 실패 - Path: {}, Duration: {}ms, CorrelationId: {}, Error: {}\u0026#34;, path, duration, correlationId, throwable.getMessage()); }); } @Override public int getOrder() { return -1; // 가장 먼저 실행 } } 서비스 간 통신 OpenFeign을 이용한 동기 통신 @FeignClient(name = \u0026#34;user-service\u0026#34;, fallback = UserServiceFallback.class) public interface UserServiceClient { @GetMapping(\u0026#34;/users/{userId}\u0026#34;) UserDto getUser(@PathVariable(\u0026#34;userId\u0026#34;) Long userId); @PostMapping(\u0026#34;/users\u0026#34;) UserDto createUser(@RequestBody CreateUserRequest request); @GetMapping(\u0026#34;/users/{userId}/profile\u0026#34;) UserProfileDto getUserProfile(@PathVariable(\u0026#34;userId\u0026#34;) Long userId); } @Component @Slf4j public class UserServiceFallback implements UserServiceClient { @Override public UserDto getUser(Long userId) { log.warn(\u0026#34;사용자 서비스 호출 실패, 폴백 실행 - userId: {}\u0026#34;, userId); return UserDto.builder() .id(userId) .name(\u0026#34;Unknown User\u0026#34;) .email(\u0026#34;unknown@example.com\u0026#34;) .build(); } @Override public UserDto createUser(CreateUserRequest request) { log.error(\u0026#34;사용자 생성 서비스 호출 실패\u0026#34;); throw new ServiceUnavailableException(\u0026#34;사용자 서비스를 사용할 수 없습니다\u0026#34;); } @Override public UserProfileDto getUserProfile(Long userId) { log.warn(\u0026#34;사용자 프로필 서비스 호출 실패, 기본값 반환\u0026#34;); return UserProfileDto.builder() .userId(userId) .displayName(\u0026#34;Unknown\u0026#34;) .build(); } } 비동기 메시지 통신 (RabbitMQ) @Configuration @EnableRabbit public class RabbitConfig { public static final String ORDER_EXCHANGE = \u0026#34;order.exchange\u0026#34;; public static final String ORDER_CREATED_QUEUE = \u0026#34;order.created.queue\u0026#34;; public static final String ORDER_CREATED_ROUTING_KEY = \u0026#34;order.created\u0026#34;; @Bean public TopicExchange orderExchange() { return new TopicExchange(ORDER_EXCHANGE); } @Bean public Queue orderCreatedQueue() { return QueueBuilder.durable(ORDER_CREATED_QUEUE) .withArgument(\u0026#34;x-dead-letter-exchange\u0026#34;, \u0026#34;dlx.exchange\u0026#34;) .withArgument(\u0026#34;x-dead-letter-routing-key\u0026#34;, \u0026#34;dlx.order.created\u0026#34;) .build(); } @Bean public Binding orderCreatedBinding() { return BindingBuilder .bind(orderCreatedQueue()) .to(orderExchange()) .with(ORDER_CREATED_ROUTING_KEY); } @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate template = new RabbitTemplate(connectionFactory); template.setMessageConverter(new Jackson2JsonMessageConverter()); return template; } } // 메시지 발행 (Order Service) @Service @Slf4j public class OrderEventPublisher { private final RabbitTemplate rabbitTemplate; public void publishOrderCreated(OrderCreatedEvent event) { try { rabbitTemplate.convertAndSend( RabbitConfig.ORDER_EXCHANGE, RabbitConfig.ORDER_CREATED_ROUTING_KEY, event ); log.info(\u0026#34;주문 생성 이벤트 발행 완료 - orderId: {}\u0026#34;, event.getOrderId()); } catch (Exception e) { log.error(\u0026#34;주문 생성 이벤트 발행 실패 - orderId: {}\u0026#34;, event.getOrderId(), e); throw new EventPublishException(\u0026#34;이벤트 발행에 실패했습니다\u0026#34;, e); } } } // 메시지 구독 (Notification Service) @RabbitListener(queues = RabbitConfig.ORDER_CREATED_QUEUE) @Component @Slf4j public class OrderEventListener { private final NotificationService notificationService; private final UserServiceClient userServiceClient; @RabbitHandler public void handleOrderCreated(OrderCreatedEvent event) { try { log.info(\u0026#34;주문 생성 이벤트 수신 - orderId: {}\u0026#34;, event.getOrderId()); UserDto user = userServiceClient.getUser(event.getUserId()); NotificationRequest notification = NotificationRequest.builder() .userId(event.getUserId()) .email(user.getEmail()) .type(NotificationType.ORDER_CONFIRMATION) .title(\u0026#34;주문이 접수되었습니다\u0026#34;) .content(String.format(\u0026#34;주문번호 %s가 성공적으로 접수되었습니다.\u0026#34;, event.getOrderId())) .build(); notificationService.sendNotification(notification); } catch (Exception e) { log.error(\u0026#34;주문 생성 이벤트 처리 실패 - orderId: {}\u0026#34;, event.getOrderId(), e); throw new MessageProcessingException(\u0026#34;메시지 처리에 실패했습니다\u0026#34;, e); } } } 서킷 브레이커 패턴 Resilience4j 설정 @Configuration public class ResilienceConfig { @Bean public CircuitBreaker userServiceCircuitBreaker() { return CircuitBreaker.of(\u0026#34;user-service\u0026#34;, CircuitBreakerConfig.custom() .failureRateThreshold(50) .waitDurationInOpenState(Duration.ofSeconds(30)) .slidingWindowSize(10) .minimumNumberOfCalls(5) .slowCallRateThreshold(50) .slowCallDurationThreshold(Duration.ofSeconds(2)) .build()); } @Bean public Retry userServiceRetry() { return Retry.of(\u0026#34;user-service\u0026#34;, RetryConfig.custom() .maxAttempts(3) .waitDuration(Duration.ofSeconds(1)) .retryExceptions(ConnectException.class, SocketTimeoutException.class) .build()); } @Bean public TimeLimiter userServiceTimeLimiter() { return TimeLimiter.of(\u0026#34;user-service\u0026#34;, TimeLimiterConfig.custom() .timeoutDuration(Duration.ofSeconds(3)) .build()); } } @Service public class OrderService { private final UserServiceClient userServiceClient; private final CircuitBreaker circuitBreaker; private final Retry retry; public Order createOrder(CreateOrderRequest request) { // 사용자 정보 조회 with Circuit Breaker + Retry UserDto user = Decorators.ofSupplier(() -\u0026gt; userServiceClient.getUser(request.getUserId())) .withCircuitBreaker(circuitBreaker) .withRetry(retry) .withFallback(Arrays.asList(Exception.class), ex -\u0026gt; createDefaultUser(request.getUserId())) .get(); // 주문 생성 로직 Order order = Order.builder() .userId(user.getId()) .productId(request.getProductId()) .quantity(request.getQuantity()) .status(OrderStatus.CREATED) .build(); return orderRepository.save(order); } private UserDto createDefaultUser(Long userId) { return UserDto.builder() .id(userId) .name(\u0026#34;Guest User\u0026#34;) .email(\u0026#34;guest@example.com\u0026#34;) .build(); } } 분산 설정 관리 Spring Cloud Config // Config Server @SpringBootApplication @EnableConfigServer public class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class, args); } } # Config Server - application.yml server: port: 8888 spring: cloud: config: server: git: uri: https://github.com/your-org/config-repo clone-on-start: true default-label: main encrypt: enabled: false # Config Repository - user-service.yml spring: datasource: url: jdbc:postgresql://localhost:5432/user_db username: ${DB_USERNAME} password: \u0026#39;{cipher}AQA3mHJz5RQ...\u0026#39; # 암호화된 비밀번호 # user-service-prod.yml spring: datasource: url: jdbc:postgresql://prod-db:5432/user_db hikari: maximum-pool-size: 20 minimum-idle: 5 logging: level: com.kigo.userservice: INFO 분산 추적 Sleuth + Zipkin 설정 # 각 서비스의 application.yml spring: sleuth: sampler: probability: 1.0 # 개발 환경에서는 100% 샘플링 zipkin: base-url: http://localhost:9411 enabled: true application: name: user-service @RestController @Slf4j public class UserController { private final UserService userService; private final Tracer tracer; @GetMapping(\u0026#34;/users/{id}\u0026#34;) public ResponseEntity\u0026lt;UserDto\u0026gt; getUser(@PathVariable Long id) { Span customSpan = tracer.nextSpan() .name(\u0026#34;get-user-operation\u0026#34;) .tag(\u0026#34;user.id\u0026#34;, String.valueOf(id)) .start(); try (Tracer.SpanInScope ws = tracer.withSpanInScope(customSpan)) { log.info(\u0026#34;사용자 조회 요청 - userId: {}\u0026#34;, id); UserDto user = userService.findById(id); customSpan.tag(\u0026#34;user.found\u0026#34;, \u0026#34;true\u0026#34;); return ResponseEntity.ok(user); } catch (Exception e) { customSpan.tag(\u0026#34;error\u0026#34;, e.getMessage()); throw e; } finally { customSpan.end(); } } } 모니터링과 헬스 체크 Actuator 설정 # 각 서비스의 공통 설정 management: endpoints: web: exposure: include: health,info,metrics,prometheus,refresh endpoint: health: show-details: always health: circuitbreakers: enabled: true metrics: export: prometheus: enabled: true distribution: percentiles-histogram: http.server.requests: true @Component public class CustomHealthIndicator implements HealthIndicator { private final UserRepository userRepository; @Override public Health health() { try { long userCount = userRepository.count(); if (userCount \u0026gt;= 0) { return Health.up() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;사용 가능\u0026#34;) .withDetail(\u0026#34;userCount\u0026#34;, userCount) .build(); } } catch (Exception e) { return Health.down() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;사용 불가\u0026#34;) .withException(e) .build(); } return Health.down().build(); } } 통합 테스트 @SpringBootTest @TestPropertySource(properties = { \u0026#34;spring.cloud.config.enabled=false\u0026#34;, \u0026#34;eureka.client.enabled=false\u0026#34; }) @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE) @Testcontainers class UserServiceIntegrationTest { @Container static PostgreSQLContainer\u0026lt;?\u0026gt; postgres = new PostgreSQLContainer\u0026lt;\u0026gt;(\u0026#34;postgres:13\u0026#34;) .withDatabaseName(\u0026#34;test_db\u0026#34;) .withUsername(\u0026#34;test\u0026#34;) .withPassword(\u0026#34;test\u0026#34;); @MockBean private ProductServiceClient productServiceClient; @Autowired private TestRestTemplate restTemplate; @DynamicPropertySource static void configureProperties(DynamicPropertyRegistry registry) { registry.add(\u0026#34;spring.datasource.url\u0026#34;, postgres::getJdbcUrl); registry.add(\u0026#34;spring.datasource.username\u0026#34;, postgres::getUsername); registry.add(\u0026#34;spring.datasource.password\u0026#34;, postgres::getPassword); } @Test void 사용자_생성_및_조회_통합_테스트() { // Given CreateUserRequest request = new CreateUserRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;Test User\u0026#34;); // When - 사용자 생성 ResponseEntity\u0026lt;UserDto\u0026gt; createResponse = restTemplate.postForEntity( \u0026#34;/api/users\u0026#34;, request, UserDto.class); // Then assertThat(createResponse.getStatusCode()).isEqualTo(HttpStatus.CREATED); UserDto createdUser = createResponse.getBody(); assertThat(createdUser.getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); // When - 사용자 조회 ResponseEntity\u0026lt;UserDto\u0026gt; getResponse = restTemplate.getForEntity( \u0026#34;/api/users/\u0026#34; + createdUser.getId(), UserDto.class); // Then assertThat(getResponse.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(getResponse.getBody().getId()).isEqualTo(createdUser.getId()); } } 이러한 패턴과 설정을 통해 확장 가능하고 견고한 마이크로서비스 아키텍처를 구축할 수 있습니다. 각 서비스는 독립적으로 개발, 배포, 확장이 가능하며, 장애 격리와 복원력을 갖춘 시스템을 만들 수 있습니다.\n"},{"section":"Blog","slug":"/kigo.github.io/blog/database-design-patterns/","title":"Java 애플리케이션을 위한 데이터베이스 설계 패턴","description":"JPA와 Spring Data를 활용한 효율적인 데이터베이스 설계 패턴과 최적화 기법들을 알아봅니다.","date":"2022년 4월 5일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"백엔드, 데이터베이스","tags":"JPA, Spring Data, 데이터베이스, 설계 패턴","content":"효율적인 Java 애플리케이션 개발을 위해서는 견고한 데이터베이스 설계가 필수입니다. JPA와 Spring Data를 활용하여 성능과 유지보수성을 모두 만족하는 데이터베이스 설계 패턴들을 알아보겠습니다.\n엔티티 설계 원칙 기본 엔티티 구조 @Entity @Table(name = \u0026#34;users\u0026#34;) @EntityListeners(AuditingEntityListener.class) @Data @NoArgsConstructor @AllArgsConstructor @Builder public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true, length = 100) private String email; @Column(nullable = false, length = 50) private String name; @Enumerated(EnumType.STRING) @Column(nullable = false) private UserStatus status; @CreatedDate @Column(nullable = false, updatable = false) private LocalDateTime createdAt; @LastModifiedDate @Column(nullable = false) private LocalDateTime updatedAt; @Version private Long version; } 상속 매핑 전략 // 조인 테이블 전략 (JOINED) @Entity @Table(name = \u0026#34;accounts\u0026#34;) @Inheritance(strategy = InheritanceType.JOINED) @DiscriminatorColumn(name = \u0026#34;account_type\u0026#34;) public abstract class Account { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false) private String accountNumber; @Column(nullable = false, precision = 15, scale = 2) private BigDecimal balance; // 공통 필드들 } @Entity @Table(name = \u0026#34;savings_accounts\u0026#34;) @DiscriminatorValue(\u0026#34;SAVINGS\u0026#34;) public class SavingsAccount extends Account { @Column(nullable = false, precision = 5, scale = 4) private BigDecimal interestRate; private Integer minBalance; } @Entity @Table(name = \u0026#34;checking_accounts\u0026#34;) @DiscriminatorValue(\u0026#34;CHECKING\u0026#34;) public class CheckingAccount extends Account { @Column(nullable = false, precision = 10, scale = 2) private BigDecimal overdraftLimit; private Integer freeTransactions; } 연관관계 매핑 패턴 일대다 연관관계 최적화 @Entity @Table(name = \u0026#34;categories\u0026#34;) public class Category { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 100) private String name; // 양방향 연관관계 - 성능을 위해 LAZY 로딩 @OneToMany(mappedBy = \u0026#34;category\u0026#34;, fetch = FetchType.LAZY, cascade = CascadeType.ALL) @BatchSize(size = 20) // N+1 문제 해결 private List\u0026lt;Product\u0026gt; products = new ArrayList\u0026lt;\u0026gt;(); // 연관관계 편의 메서드 public void addProduct(Product product) { products.add(product); product.setCategory(this); } public void removeProduct(Product product) { products.remove(product); product.setCategory(null); } } @Entity @Table(name = \u0026#34;products\u0026#34;) public class Product { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 200) private String name; @Column(nullable = false, precision = 10, scale = 2) private BigDecimal price; // 다대일 연관관계 @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;category_id\u0026#34;, nullable = false) private Category category; } 다대다 연관관계 with 추가 속성 @Entity @Table(name = \u0026#34;students\u0026#34;) public class Student { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 100) private String name; @OneToMany(mappedBy = \u0026#34;student\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) private List\u0026lt;Enrollment\u0026gt; enrollments = new ArrayList\u0026lt;\u0026gt;(); public void enrollInCourse(Course course, LocalDateTime enrollmentDate) { Enrollment enrollment = new Enrollment(this, course, enrollmentDate); enrollments.add(enrollment); course.getEnrollments().add(enrollment); } } @Entity @Table(name = \u0026#34;courses\u0026#34;) public class Course { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, length = 200) private String title; @OneToMany(mappedBy = \u0026#34;course\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) private List\u0026lt;Enrollment\u0026gt; enrollments = new ArrayList\u0026lt;\u0026gt;(); } @Entity @Table(name = \u0026#34;enrollments\u0026#34;) public class Enrollment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;student_id\u0026#34;) private Student student; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;course_id\u0026#34;) private Course course; @Column(nullable = false) private LocalDateTime enrollmentDate; private BigDecimal grade; public Enrollment(Student student, Course course, LocalDateTime enrollmentDate) { this.student = student; this.course = course; this.enrollmentDate = enrollmentDate; } } Repository 패턴 커스텀 Repository 구현 public interface UserRepositoryCustom { List\u0026lt;User\u0026gt; findUsersWithComplexCriteria(UserSearchCriteria criteria); Page\u0026lt;User\u0026gt; findActiveUsersWithPosts(Pageable pageable); } @Repository public class UserRepositoryImpl implements UserRepositoryCustom { @PersistenceContext private EntityManager entityManager; @Override public List\u0026lt;User\u0026gt; findUsersWithComplexCriteria(UserSearchCriteria criteria) { CriteriaBuilder cb = entityManager.getCriteriaBuilder(); CriteriaQuery\u0026lt;User\u0026gt; query = cb.createQuery(User.class); Root\u0026lt;User\u0026gt; root = query.from(User.class); List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); if (criteria.getName() != null) { predicates.add(cb.like(cb.lower(root.get(\u0026#34;name\u0026#34;)), \u0026#34;%\u0026#34; + criteria.getName().toLowerCase() + \u0026#34;%\u0026#34;)); } if (criteria.getStatus() != null) { predicates.add(cb.equal(root.get(\u0026#34;status\u0026#34;), criteria.getStatus())); } if (criteria.getCreatedAfter() != null) { predicates.add(cb.greaterThanOrEqualTo(root.get(\u0026#34;createdAt\u0026#34;), criteria.getCreatedAfter())); } query.where(predicates.toArray(new Predicate[0])); query.orderBy(cb.desc(root.get(\u0026#34;createdAt\u0026#34;))); return entityManager.createQuery(query) .setMaxResults(100) .getResultList(); } @Override public Page\u0026lt;User\u0026gt; findActiveUsersWithPosts(Pageable pageable) { String jpql = \u0026#34;\u0026#34;\u0026#34; SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.posts p WHERE u.status = :status ORDER BY u.createdAt DESC \u0026#34;\u0026#34;\u0026#34;; TypedQuery\u0026lt;User\u0026gt; query = entityManager.createQuery(jpql, User.class) .setParameter(\u0026#34;status\u0026#34;, UserStatus.ACTIVE) .setFirstResult((int) pageable.getOffset()) .setMaxResults(pageable.getPageSize()); List\u0026lt;User\u0026gt; users = query.getResultList(); // 전체 개수 조회 Long total = entityManager.createQuery( \u0026#34;SELECT COUNT(DISTINCT u) FROM User u WHERE u.status = :status\u0026#34;, Long.class) .setParameter(\u0026#34;status\u0026#34;, UserStatus.ACTIVE) .getSingleResult(); return new PageImpl\u0026lt;\u0026gt;(users, pageable, total); } } public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt;, UserRepositoryCustom { @Query(\u0026#34;SELECT u FROM User u WHERE u.email = :email\u0026#34;) Optional\u0026lt;User\u0026gt; findByEmail(@Param(\u0026#34;email\u0026#34;) String email); @Query(value = \u0026#34;\u0026#34;\u0026#34; SELECT u.* FROM users u WHERE u.status = :status AND u.created_at \u0026gt;= :since ORDER BY u.created_at DESC \u0026#34;\u0026#34;\u0026#34;, nativeQuery = true) List\u0026lt;User\u0026gt; findRecentActiveUsers(@Param(\u0026#34;status\u0026#34;) String status, @Param(\u0026#34;since\u0026#34;) LocalDateTime since); @Modifying @Query(\u0026#34;UPDATE User u SET u.status = :status WHERE u.id IN :ids\u0026#34;) int updateUserStatus(@Param(\u0026#34;ids\u0026#34;) List\u0026lt;Long\u0026gt; ids, @Param(\u0026#34;status\u0026#34;) UserStatus status); } 성능 최적화 패턴 페이징과 정렬 @Service @Transactional(readOnly = true) public class ProductService { private final ProductRepository productRepository; public Page\u0026lt;ProductDto\u0026gt; getProducts(ProductSearchRequest request) { Pageable pageable = PageRequest.of( request.getPage(), request.getSize(), Sort.by(Sort.Direction.DESC, \u0026#34;createdAt\u0026#34;) ); Page\u0026lt;Product\u0026gt; products = productRepository.findByCategoryAndPriceRange( request.getCategoryId(), request.getMinPrice(), request.getMaxPrice(), pageable ); return products.map(this::convertToDto); } private ProductDto convertToDto(Product product) { return ProductDto.builder() .id(product.getId()) .name(product.getName()) .price(product.getPrice()) .categoryName(product.getCategory().getName()) .build(); } } 배치 처리 최적화 @Service public class BatchUserService { @PersistenceContext private EntityManager entityManager; @Transactional public void batchUpdateUserStatus(List\u0026lt;Long\u0026gt; userIds, UserStatus newStatus) { final int batchSize = 100; for (int i = 0; i \u0026lt; userIds.size(); i += batchSize) { List\u0026lt;Long\u0026gt; batch = userIds.subList(i, Math.min(i + batchSize, userIds.size())); entityManager.createQuery( \u0026#34;UPDATE User u SET u.status = :status WHERE u.id IN :ids\u0026#34;) .setParameter(\u0026#34;status\u0026#34;, newStatus) .setParameter(\u0026#34;ids\u0026#34;, batch) .executeUpdate(); entityManager.flush(); entityManager.clear(); } } @Transactional public void batchInsertUsers(List\u0026lt;CreateUserRequest\u0026gt; requests) { final int batchSize = 50; for (int i = 0; i \u0026lt; requests.size(); i++) { User user = User.builder() .email(requests.get(i).getEmail()) .name(requests.get(i).getName()) .status(UserStatus.ACTIVE) .build(); entityManager.persist(user); if (i % batchSize == 0 \u0026amp;\u0026amp; i \u0026gt; 0) { entityManager.flush(); entityManager.clear(); } } } } 캐싱 전략 @Entity @Cacheable @org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE) public class Category { // 엔티티 정의 } @Service public class CategoryService { @Cacheable(value = \u0026#34;categories\u0026#34;, key = \u0026#34;#id\u0026#34;) public Category findById(Long id) { return categoryRepository.findById(id) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;카테고리를 찾을 수 없습니다\u0026#34;)); } @Cacheable(value = \u0026#34;categories\u0026#34;, key = \u0026#34;\u0026#39;all\u0026#39;\u0026#34;) public List\u0026lt;Category\u0026gt; findAll() { return categoryRepository.findAll(); } @CacheEvict(value = \u0026#34;categories\u0026#34;, allEntries = true) public Category save(Category category) { return categoryRepository.save(category); } } 트랜잭션 관리 선언적 트랜잭션 @Service @Transactional(readOnly = true) public class OrderService { private final OrderRepository orderRepository; private final ProductRepository productRepository; private final InventoryService inventoryService; @Transactional public Order createOrder(CreateOrderRequest request) { // 상품 재고 확인 Product product = productRepository.findById(request.getProductId()) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;상품을 찾을 수 없습니다\u0026#34;)); if (!inventoryService.hasStock(product.getId(), request.getQuantity())) { throw new InsufficientStockException(\u0026#34;재고가 부족합니다\u0026#34;); } // 주문 생성 Order order = Order.builder() .product(product) .quantity(request.getQuantity()) .totalPrice(product.getPrice().multiply(BigDecimal.valueOf(request.getQuantity()))) .status(OrderStatus.PENDING) .build(); Order savedOrder = orderRepository.save(order); // 재고 차감 inventoryService.decreaseStock(product.getId(), request.getQuantity()); return savedOrder; } @Transactional(propagation = Propagation.REQUIRES_NEW) public void processPayment(Long orderId, PaymentInfo paymentInfo) { Order order = orderRepository.findById(orderId) .orElseThrow(() -\u0026gt; new EntityNotFoundException(\u0026#34;주문을 찾을 수 없습니다\u0026#34;)); try { // 결제 처리 로직 paymentService.processPayment(paymentInfo); order.setStatus(OrderStatus.PAID); } catch (PaymentException e) { order.setStatus(OrderStatus.PAYMENT_FAILED); throw e; } finally { orderRepository.save(order); } } } 프로그래밍적 트랜잭션 @Service public class DataMigrationService { private final PlatformTransactionManager transactionManager; public void migrateUserData(List\u0026lt;UserData\u0026gt; userData) { TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager); transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED); for (UserData data : userData) { try { transactionTemplate.execute(status -\u0026gt; { User user = new User(data.getEmail(), data.getName()); userRepository.save(user); // 프로필 데이터 마이그레이션 Profile profile = new Profile(user, data.getProfileData()); profileRepository.save(profile); return null; }); log.info(\u0026#34;사용자 마이그레이션 완료: {}\u0026#34;, data.getEmail()); } catch (Exception e) { log.error(\u0026#34;사용자 마이그레이션 실패: {}\u0026#34;, data.getEmail(), e); // 개별 실패는 전체 마이그레이션을 중단하지 않음 } } } } 감사(Auditing) 기능 @EntityListeners(AuditingEntityListener.class) @MappedSuperclass public abstract class BaseEntity { @CreatedDate @Column(name = \u0026#34;created_at\u0026#34;, nullable = false, updatable = false) private LocalDateTime createdAt; @LastModifiedDate @Column(name = \u0026#34;updated_at\u0026#34;, nullable = false) private LocalDateTime updatedAt; @CreatedBy @Column(name = \u0026#34;created_by\u0026#34;, updatable = false) private String createdBy; @LastModifiedBy @Column(name = \u0026#34;updated_by\u0026#34;) private String updatedBy; } @Configuration @EnableJpaAuditing public class JpaAuditingConfig { @Bean public AuditorAware\u0026lt;String\u0026gt; auditorProvider() { return () -\u0026gt; { Authentication auth = SecurityContextHolder.getContext().getAuthentication(); if (auth != null \u0026amp;\u0026amp; auth.isAuthenticated() \u0026amp;\u0026amp; !auth.getPrincipal().equals(\u0026#34;anonymousUser\u0026#34;)) { return Optional.of(auth.getName()); } return Optional.of(\u0026#34;system\u0026#34;); }; } } 이러한 패턴들을 통해 견고하고 성능이 우수한 데이터베이스 계층을 구축할 수 있습니다. 각 패턴은 특정 상황에 맞게 선택적으로 적용하여 최적의 결과를 얻으시기 바랍니다.\n"},{"section":"Blog","slug":"/kigo.github.io/blog/spring-boot-best-practices/","title":"Spring Boot 프로덕션 베스트 프랙티스","description":"프로덕션 환경에서 안정적인 Spring Boot 애플리케이션을 위한 필수 설정과 코딩 관례들을 알아봅니다.","date":"2022년 4월 4일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/kigo.github.io/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/kigo.github.io\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"백엔드, Java","tags":"Spring Boot, Java, 백엔드, 베스트 프랙티스","content":"프로덕션에서 안정적인 Spring Boot 애플리케이션을 만들기 위해서는 기본 기능 구현 이상의 것들이 필요합니다. 견고하고 안전하며 유지보수가 가능한 애플리케이션을 만들기 위한 필수 관례들을 알아보겠습니다.\n애플리케이션 설정 프로파일 기반 설정 # application.yml spring: profiles: active: ${SPRING_PROFILES_ACTIVE:dev} --- # 개발 프로파일 spring: config: activate: on-profile: dev datasource: url: jdbc:h2:mem:testdb driver-class-name: org.h2.Driver jpa: show-sql: true hibernate: ddl-auto: create-drop --- # 프로덕션 프로파일 spring: config: activate: on-profile: prod datasource: url: ${DATABASE_URL} username: ${DB_USERNAME} password: ${DB_PASSWORD} hikari: maximum-pool-size: 20 minimum-idle: 5 jpa: show-sql: false hibernate: ddl-auto: validate 외부화된 설정 @ConfigurationProperties(prefix = \u0026#34;app\u0026#34;) @Component public class AppProperties { private String name; private String version; private Security security = new Security(); private Database database = new Database(); // Getters and setters public static class Security { private String jwtSecret; private long jwtExpirationMs = 86400000; // 24시간 // Getters and setters } public static class Database { private int maxConnections = 20; private int connectionTimeout = 30000; // Getters and setters } } 보안 구현 JWT 인증 @Component public class JwtTokenProvider { private final String jwtSecret; private final int jwtExpirationMs; public JwtTokenProvider(AppProperties appProperties) { this.jwtSecret = appProperties.getSecurity().getJwtSecret(); this.jwtExpirationMs = appProperties.getSecurity().getJwtExpirationMs(); } public String generateToken(Authentication authentication) { UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal(); Date expiryDate = new Date(System.currentTimeMillis() + jwtExpirationMs); return Jwts.builder() .setSubject(Long.toString(userPrincipal.getId())) .setIssuedAt(new Date()) .setExpiration(expiryDate) .signWith(SignatureAlgorithm.HS512, jwtSecret) .compact(); } public boolean validateToken(String authToken) { try { Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken); return true; } catch (JwtException | IllegalArgumentException e) { log.error(\u0026#34;유효하지 않은 JWT 토큰: {}\u0026#34;, e.getMessage()); } return false; } } 보안 설정 @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig { @Autowired private JwtAuthenticationEntryPoint unauthorizedHandler; @Bean public JwtAuthenticationFilter jwtAuthenticationFilter() { return new JwtAuthenticationFilter(); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.cors() .and() .csrf().disable() .exceptionHandling() .authenticationEntryPoint(unauthorizedHandler) .and() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .antMatchers(\u0026#34;/api/auth/**\u0026#34;).permitAll() .antMatchers(\u0026#34;/api/public/**\u0026#34;).permitAll() .antMatchers(HttpMethod.GET, \u0026#34;/api/posts/**\u0026#34;).permitAll() .anyRequest().authenticated(); http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); } } 에러 핸들링 글로벌 예외 처리기 @RestControllerAdvice @Slf4j public class GlobalExceptionHandler { @ExceptionHandler(ValidationException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public ApiResponse handleValidationException(ValidationException ex) { log.warn(\u0026#34;검증 오류: {}\u0026#34;, ex.getMessage()); return ApiResponse.error(\u0026#34;검증 실패\u0026#34;, ex.getMessage()); } @ExceptionHandler(ResourceNotFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ApiResponse handleResourceNotFoundException(ResourceNotFoundException ex) { log.warn(\u0026#34;리소스를 찾을 수 없음: {}\u0026#34;, ex.getMessage()); return ApiResponse.error(\u0026#34;리소스를 찾을 수 없음\u0026#34;, ex.getMessage()); } @ExceptionHandler(DataIntegrityViolationException.class) @ResponseStatus(HttpStatus.CONFLICT) public ApiResponse handleDataIntegrityViolation(DataIntegrityViolationException ex) { log.error(\u0026#34;데이터 무결성 위반: {}\u0026#34;, ex.getMessage()); return ApiResponse.error(\u0026#34;데이터 충돌\u0026#34;, \u0026#34;요청한 작업이 기존 데이터와 충돌합니다\u0026#34;); } @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public ApiResponse handleGenericException(Exception ex) { log.error(\u0026#34;예상치 못한 오류 발생\u0026#34;, ex); return ApiResponse.error(\u0026#34;내부 서버 오류\u0026#34;, \u0026#34;예상치 못한 오류가 발생했습니다\u0026#34;); } } 데이터베이스 최적화 커넥션 풀 설정 spring: datasource: hikari: maximum-pool-size: 20 minimum-idle: 5 idle-timeout: 300000 max-lifetime: 1200000 connection-timeout: 20000 validation-timeout: 5000 leak-detection-threshold: 60000 JPA 성능 튜닝 @Entity @Table(name = \u0026#34;users\u0026#34;, indexes = { @Index(name = \u0026#34;idx_user_email\u0026#34;, columnList = \u0026#34;email\u0026#34;), @Index(name = \u0026#34;idx_user_status\u0026#34;, columnList = \u0026#34;status\u0026#34;) }) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(nullable = false, unique = true) private String email; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, fetch = FetchType.LAZY, cascade = CascadeType.ALL) @BatchSize(size = 20) private List\u0026lt;Post\u0026gt; posts = new ArrayList\u0026lt;\u0026gt;(); // 생성자, getters, setters } @Repository public class UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { @Query(\u0026#34;SELECT u FROM User u LEFT JOIN FETCH u.posts WHERE u.id = :id\u0026#34;) Optional\u0026lt;User\u0026gt; findByIdWithPosts(@Param(\u0026#34;id\u0026#34;) Long id); @Query(value = \u0026#34;SELECT * FROM users WHERE status = :status ORDER BY created_at DESC LIMIT :limit\u0026#34;, nativeQuery = true) List\u0026lt;User\u0026gt; findActiveUsersWithLimit(@Param(\u0026#34;status\u0026#34;) String status, @Param(\u0026#34;limit\u0026#34;) int limit); } 모니터링과 관찰 가능성 Actuator 설정 management: endpoints: web: exposure: include: health,info,metrics,prometheus endpoint: health: show-details: when-authorized metrics: export: prometheus: enabled: true 커스텀 헬스 인디케이터 @Component public class DatabaseHealthIndicator implements HealthIndicator { private final DataSource dataSource; public DatabaseHealthIndicator(DataSource dataSource) { this.dataSource = dataSource; } @Override public Health health() { try (Connection connection = dataSource.getConnection()) { if (connection.isValid(1)) { return Health.up() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;사용 가능\u0026#34;) .withDetail(\u0026#34;validationQuery\u0026#34;, \u0026#34;SELECT 1\u0026#34;) .build(); } } catch (SQLException e) { return Health.down() .withDetail(\u0026#34;database\u0026#34;, \u0026#34;사용 불가\u0026#34;) .withException(e) .build(); } return Health.down().withDetail(\u0026#34;database\u0026#34;, \u0026#34;연결 검증 실패\u0026#34;).build(); } } 애플리케이션 메트릭 @Service @Slf4j public class UserService { private final UserRepository userRepository; private final MeterRegistry meterRegistry; private final Counter userCreationCounter; private final Timer userFetchTimer; public UserService(UserRepository userRepository, MeterRegistry meterRegistry) { this.userRepository = userRepository; this.meterRegistry = meterRegistry; this.userCreationCounter = Counter.builder(\u0026#34;user.creation.count\u0026#34;) .description(\u0026#34;생성된 사용자 수\u0026#34;) .register(meterRegistry); this.userFetchTimer = Timer.builder(\u0026#34;user.fetch.time\u0026#34;) .description(\u0026#34;사용자 조회 소요 시간\u0026#34;) .register(meterRegistry); } public User createUser(CreateUserRequest request) { return userFetchTimer.recordCallable(() -\u0026gt; { User user = new User(request.getEmail(), request.getName()); User savedUser = userRepository.save(user); userCreationCounter.increment(); log.info(\u0026#34;사용자 생성 완료 ID: {}\u0026#34;, savedUser.getId()); return savedUser; }); } } 테스트 베스트 프랙티스 통합 테스트 @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @TestPropertySource(properties = { \u0026#34;spring.datasource.url=jdbc:h2:mem:testdb\u0026#34;, \u0026#34;spring.jpa.hibernate.ddl-auto=create-drop\u0026#34; }) class UserControllerIntegrationTest { @Autowired private TestRestTemplate restTemplate; @Autowired private UserRepository userRepository; @Test void 사용자_생성_테스트() { CreateUserRequest request = new CreateUserRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;테스트 사용자\u0026#34;); ResponseEntity\u0026lt;User\u0026gt; response = restTemplate.postForEntity(\u0026#34;/api/users\u0026#34;, request, User.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED); assertThat(response.getBody().getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); assertThat(userRepository.count()).isEqualTo(1); } } 목킹을 활용한 단위 테스트 @ExtendWith(MockitoExtension.class) class UserServiceTest { @Mock private UserRepository userRepository; @Mock private MeterRegistry meterRegistry; @InjectMocks private UserService userService; @Test void 사용자_생성_성공_테스트() { // Given CreateUserRequest request = new CreateUserRequest(\u0026#34;test@example.com\u0026#34;, \u0026#34;테스트 사용자\u0026#34;); User savedUser = new User(\u0026#34;test@example.com\u0026#34;, \u0026#34;테스트 사용자\u0026#34;); savedUser.setId(1L); when(userRepository.save(any(User.class))).thenReturn(savedUser); // When User result = userService.createUser(request); // Then assertThat(result.getId()).isEqualTo(1L); assertThat(result.getEmail()).isEqualTo(\u0026#34;test@example.com\u0026#34;); verify(userRepository).save(any(User.class)); } } 성능 최적화 캐싱 전략 @Service @EnableCaching public class UserService { @Cacheable(value = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public User findById(Long id) { return userRepository.findById(id) .orElseThrow(() -\u0026gt; new ResourceNotFoundException(\u0026#34;사용자를 찾을 수 없습니다\u0026#34;)); } @CacheEvict(value = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User updateUser(User user) { return userRepository.save(user); } @CacheEvict(value = \u0026#34;users\u0026#34;, allEntries = true) public void clearUserCache() { // 캐시가 클리어됩니다 } } 비동기 처리 @Service @Slf4j public class EmailService { @Async(\u0026#34;taskExecutor\u0026#34;) public CompletableFuture\u0026lt;Void\u0026gt; sendWelcomeEmail(String email, String name) { try { // 이메일 발송 시뮬레이션 Thread.sleep(2000); log.info(\u0026#34;환영 이메일 발송 완료: {}\u0026#34;, email); return CompletableFuture.completedFuture(null); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return CompletableFuture.failedFuture(e); } } } @Configuration @EnableAsync public class AsyncConfig { @Bean(name = \u0026#34;taskExecutor\u0026#34;) public TaskExecutor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(2); executor.setMaxPoolSize(10); executor.setQueueCapacity(100); executor.setThreadNamePrefix(\u0026#34;async-\u0026#34;); executor.initialize(); return executor; } } 이러한 관례들을 통해 Spring Boot 애플리케이션이 프로덕션에서 안전하고 유지보수 가능하도록 보장할 수 있습니다. 점진적으로 구현하면서 특정 요구사항에 맞게 조정하시기 바랍니다.\n"}]
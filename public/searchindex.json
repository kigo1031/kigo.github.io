[{
  "section": "Blog",
  "slug": "/blog/vscode-optimization/",
  "title": "VS Code 개발 환경 최적화하기",
  "description": "개발 생산성을 높이는 VS Code 설정과 확장 프로그램들을 소개합니다.",
  "date": "2025년 8월 2일",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "개발도구",
  "tags": "VS Code, 개발환경, 생산성, 확장프로그램",
  "content":"개발자에게 있어 에디터는 가장 중요한 도구 중 하나입니다. 오늘은 VS Code를 더욱 효율적으로 사용하는 방법들을 공유해보려고 합니다.\n필수 확장 프로그램들 1. 코드 품질 관리 ESLint: JavaScript/TypeScript 코드 품질 관리 Prettier: 코드 자동 포맷팅 SonarLint: 실시간 코드 분석 2. 개발 생산성 GitLens: Git 기능 강화 Live Server: 실시간 웹 페이지 미리보기 Auto Rename Tag: HTML 태그 자동 리네임 3. 언어별 지원 Python: Python 개발 지원 Go: Go 언어 지원 Docker: 컨테이너 개발 지원 유용한 설정들 자동 저장 및 포맷팅 { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.formatOnPaste\u0026#34;: true, \u0026#34;files.autoSave\u0026#34;: \u0026#34;afterDelay\u0026#34; } 에디터 개선 { \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.lineHeight\u0026#34;: 1.5, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Fira Code\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true } 키보드 단축키 커스터마이징 자주 사용하는 기능들을 빠르게 접근할 수 있도록 단축키를 설정해보세요:\nCtrl+Shift+P: 명령 팔레트 Ctrl+`: 터미널 토글 Alt+Up/Down: 라인 이동 테마 추천 개발하기 편안한 눈에 좋은 테마들:\nOne Dark Pro: 인기 있는 다크 테마 Material Theme: 구글 머티리얼 디자인 Dracula: 세련된 다크 테마 마무리 VS Code의 강력함은 확장성에 있습니다. 자신의 개발 스타일에 맞게 커스터마이징해서 생산성을 높여보세요!\n어떤 VS Code 팁이나 확장 프로그램을 추천하시나요? 댓글로 공유해주세요! 🚀\n"},{
  "section": "Blog",
  "slug": "/blog/react-hooks-guide/",
  "title": "React 함수형 컴포넌트와 Hooks 사용법",
  "description": "React의 함수형 컴포넌트와 주요 Hooks들의 사용법을 예제와 함께 알아봅니다.",
  "date": "2025년 8월 1일",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "웹개발",
  "tags": "React, Hooks, JavaScript, 프론트엔드",
  "content":"React 16.8에서 도입된 Hooks는 함수형 컴포넌트에서도 상태 관리와 생명주기 기능을 사용할 수 있게 해주었습니다. 오늘은 주요 Hooks들의 사용법을 알아보겠습니다.\nuseState - 상태 관리 가장 기본적인 Hook으로, 함수형 컴포넌트에서 상태를 관리할 수 있습니다.\nimport React, { useState } from \u0026#39;react\u0026#39;; function Counter() { const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;현재 카운트: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; 증가 \u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count - 1)}\u0026gt; 감소 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } useEffect - 사이드 이펙트 처리 컴포넌트의 생명주기와 관련된 작업을 처리합니다.\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39;; function UserProfile({ userId }) { const [user, setUser] = useState(null); const [loading, setLoading] = useState(true); useEffect(() =\u0026gt; { // 사용자 정보 로드 const fetchUser = async () =\u0026gt; { setLoading(true); try { const response = await fetch(`/api/users/${userId}`); const userData = await response.json(); setUser(userData); } catch (error) { console.error(\u0026#39;사용자 정보 로드 실패:\u0026#39;, error); } finally { setLoading(false); } }; fetchUser(); }, [userId]); // userId가 변경될 때마다 실행 if (loading) return \u0026lt;div\u0026gt;로딩 중...\u0026lt;/div\u0026gt;; if (!user) return \u0026lt;div\u0026gt;사용자를 찾을 수 없습니다.\u0026lt;/div\u0026gt;; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{user.name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{user.email}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } useContext - 전역 상태 관리 컴포넌트 트리 전체에서 데이터를 공유할 때 사용합니다.\nimport React, { createContext, useContext, useState } from \u0026#39;react\u0026#39;; // 테마 컨텍스트 생성 const ThemeContext = createContext(); // 테마 제공자 컴포넌트 function ThemeProvider({ children }) { const [theme, setTheme] = useState(\u0026#39;light\u0026#39;); const toggleTheme = () =\u0026gt; { setTheme(theme === \u0026#39;light\u0026#39; ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39;); }; return ( \u0026lt;ThemeContext.Provider value={{ theme, toggleTheme }}\u0026gt; {children} \u0026lt;/ThemeContext.Provider\u0026gt; ); } // 테마를 사용하는 컴포넌트 function ThemedButton() { const { theme, toggleTheme } = useContext(ThemeContext); return ( \u0026lt;button onClick={toggleTheme} style={{ backgroundColor: theme === \u0026#39;light\u0026#39; ? \u0026#39;#fff\u0026#39; : \u0026#39;#333\u0026#39;, color: theme === \u0026#39;light\u0026#39; ? \u0026#39;#333\u0026#39; : \u0026#39;#fff\u0026#39; }} \u0026gt; {theme === \u0026#39;light\u0026#39; ? \u0026#39;다크 모드\u0026#39; : \u0026#39;라이트 모드\u0026#39;} \u0026lt;/button\u0026gt; ); } useMemo - 성능 최적화 비용이 큰 계산의 결과를 메모이제이션합니다.\nimport React, { useState, useMemo } from \u0026#39;react\u0026#39;; function ExpensiveComponent({ items }) { const [filter, setFilter] = useState(\u0026#39;\u0026#39;); // 필터링된 아이템들을 메모이제이션 const filteredItems = useMemo(() =\u0026gt; { console.log(\u0026#39;필터링 계산 실행\u0026#39;); return items.filter(item =\u0026gt; item.name.toLowerCase().includes(filter.toLowerCase()) ); }, [items, filter]); return ( \u0026lt;div\u0026gt; \u0026lt;input value={filter} onChange={(e) =\u0026gt; setFilter(e.target.value)} placeholder=\u0026#34;검색어 입력\u0026#34; /\u0026gt; \u0026lt;ul\u0026gt; {filteredItems.map(item =\u0026gt; ( \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } useCallback - 함수 메모이제이션 함수를 메모이제이션하여 불필요한 리렌더링을 방지합니다.\nimport React, { useState, useCallback } from \u0026#39;react\u0026#39;; function TodoList() { const [todos, setTodos] = useState([]); const [newTodo, setNewTodo] = useState(\u0026#39;\u0026#39;); // 할 일 추가 함수를 메모이제이션 const addTodo = useCallback(() =\u0026gt; { if (newTodo.trim()) { setTodos(prev =\u0026gt; [...prev, { id: Date.now(), text: newTodo, completed: false }]); setNewTodo(\u0026#39;\u0026#39;); } }, [newTodo]); // 할 일 토글 함수를 메모이제이션 const toggleTodo = useCallback((id) =\u0026gt; { setTodos(prev =\u0026gt; prev.map(todo =\u0026gt; todo.id === id ? { ...todo, completed: !todo.completed } : todo )); }, []); return ( \u0026lt;div\u0026gt; \u0026lt;input value={newTodo} onChange={(e) =\u0026gt; setNewTodo(e.target.value)} placeholder=\u0026#34;새 할 일 입력\u0026#34; /\u0026gt; \u0026lt;button onClick={addTodo}\u0026gt;추가\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {todos.map(todo =\u0026gt; ( \u0026lt;TodoItem key={todo.id} todo={todo} onToggle={toggleTodo} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } 마무리 React Hooks는 함수형 컴포넌트의 가능성을 크게 확장시켜주었습니다. 각 Hook의 특성을 이해하고 적절히 사용하면 더 깔끔하고 효율적인 React 애플리케이션을 만들 수 있습니다.\n다음에는 Custom Hooks 만들기에 대해 다뤄보겠습니다! 🎣\n"},{
  "section": "Blog",
  "slug": "/blog/git-branching-strategy/",
  "title": "Git 브랜치 전략과 협업 워크플로우",
  "description": "효과적인 Git 브랜치 전략과 팀 협업을 위한 워크플로우에 대해 알아봅니다.",
  "date": "2025년 7월 31일",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_27471e8e98afa409.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"342\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_bd1ed0c875bd33b1.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-3_hu_b2893b5db59d1966.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-3_hu_23f4ddf402f13c4c.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "개발도구",
  "tags": "Git, 브랜치전략, 협업, 버전관리",
  "content":"팀 개발에서 Git을 효과적으로 사용하는 것은 매우 중요합니다. 오늘은 대표적인 Git 브랜치 전략들과 협업 워크플로우에 대해 알아보겠습니다.\nGit Flow 전략 Git Flow는 가장 널리 사용되는 브랜치 전략 중 하나입니다.\n브랜치 구조 main: 릴리즈된 안정적인 코드 develop: 개발 중인 코드가 모이는 브랜치 feature: 새로운 기능 개발 release: 릴리즈 준비 hotfix: 긴급 버그 수정 워크플로우 예시 # 새로운 기능 개발 시작 git checkout develop git pull origin develop git checkout -b feature/user-authentication # 기능 개발 완료 후 git checkout develop git merge feature/user-authentication git branch -d feature/user-authentication git push origin develop # 릴리즈 준비 git checkout develop git checkout -b release/v1.2.0 # 버그 수정 및 버전 업데이트 git checkout main git merge release/v1.2.0 git tag v1.2.0 git checkout develop git merge release/v1.2.0 GitHub Flow 전략 GitHub Flow는 더 간단한 브랜치 전략입니다.\n특징 main 브랜치만 사용 모든 작업은 feature 브랜치에서 Pull Request를 통한 코드 리뷰 자동화된 테스트와 배포 워크플로우 # 1. 새 브랜치 생성 git checkout main git pull origin main git checkout -b feature/add-search-functionality # 2. 작업 및 커밋 git add . git commit -m \u0026#34;Add search functionality\u0026#34; git push origin feature/add-search-functionality # 3. Pull Request 생성 (GitHub에서) # 4. 코드 리뷰 및 테스트 # 5. main 브랜치에 병합 효과적인 커밋 메시지 작성 커밋 메시지 규칙 타입(범위): 제목 상세 설명 푸터 타입 종류 feat: 새로운 기능 fix: 버그 수정 docs: 문서 변경 style: 코드 스타일 변경 refactor: 코드 리팩토링 test: 테스트 추가/수정 chore: 빌드 프로세스나 도구 변경 예시 feat(auth): 사용자 로그인 기능 추가 - JWT 토큰 기반 인증 구현 - 로그인 폼 UI 개발 - 세션 관리 로직 추가 Closes #123 협업을 위한 Git 설정 유용한 Git 설정 # 사용자 정보 설정 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your.email@example.com\u0026#34; # 에디터 설정 git config --global core.editor \u0026#34;code --wait\u0026#34; # 줄바꿈 처리 (Windows) git config --global core.autocrlf true # 줄바꿈 처리 (Mac/Linux) git config --global core.autocrlf input # Push 기본 설정 git config --global push.default current # 별칭 설정 git config --global alias.st status git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.unstage \u0026#39;reset HEAD --\u0026#39; 유용한 Git 명령어 # 변경사항 임시 저장 git stash git stash pop # 특정 커밋만 가져오기 git cherry-pick \u0026lt;commit-hash\u0026gt; # 커밋 히스토리 정리 git rebase -i HEAD~3 # 파일 변경사항 부분적으로 스테이징 git add -p # 브랜치 간 차이점 확인 git diff main..feature/branch # 로그 예쁘게 보기 git log --oneline --graph --all 코드 리뷰 가이드라인 Pull Request 작성 시 명확한 제목과 설명 변경사항 요약 테스트 방법 명시 스크린샷 첨부 (UI 변경 시) 리뷰어를 위한 팁 건설적인 피드백 코드 스타일 일관성 확인 성능 및 보안 관점 검토 테스트 커버리지 확인 마무리 좋은 Git 브랜치 전략과 워크플로우는 팀의 생산성을 크게 향상시킵니다. 팀의 규모와 프로젝트 특성에 맞는 전략을 선택하고, 일관성 있게 적용하는 것이 중요합니다.\n여러분의 팀은 어떤 Git 전략을 사용하고 계신가요? 경험을 공유해주세요! 🌿\n"},{
  "section": "Blog",
  "slug": "/blog/docker-development-environment/",
  "title": "Docker로 개발 환경 구축하기",
  "description": "Docker를 활용한 일관된 개발 환경 구축 방법과 컨테이너 기반 개발 워크플로우를 알아봅니다.",
  "date": "2025년 7월 30일",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_39d919d488f78836.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"389\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_3c8c21727167d1e5.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-1_hu_cf913ce2207036d4.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-1_hu_7b95820fe4006b37.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "DevOps, 컨테이너",
  "tags": "Docker, DevOps, 컨테이너, 개발환경",
  "content":"개발을 하다 보면 \u0026ldquo;내 컴퓨터에서는 잘 됐는데?\u0026ldquo;라는 말을 자주 듣게 됩니다. Docker를 사용하면 이런 문제를 해결하고 일관된 개발 환경을 구축할 수 있습니다.\nDocker란? Docker는 컨테이너 기반의 가상화 플랫폼입니다. 애플리케이션과 그 실행에 필요한 모든 것을 하나의 컨테이너로 패키징할 수 있습니다.\nDocker의 장점 일관성: 어디서든 동일한 환경 격리: 각 컨테이너는 독립적으로 실행 이식성: 어느 플랫폼에서든 실행 가능 효율성: 가상머신보다 가벼움 기본 Docker 명령어 이미지 관리 # 이미지 검색 docker search nginx # 이미지 다운로드 docker pull nginx:latest # 이미지 목록 확인 docker images # 이미지 삭제 docker rmi nginx:latest 컨테이너 관리 # 컨테이너 실행 docker run -d -p 80:80 --name my-nginx nginx # 실행 중인 컨테이너 확인 docker ps # 모든 컨테이너 확인 docker ps -a # 컨테이너 중지 docker stop my-nginx # 컨테이너 삭제 docker rm my-nginx Dockerfile 작성 Node.js 애플리케이션을 위한 Dockerfile 예시:\n# 베이스 이미지 설정 FROM node:18-alpine # 작업 디렉토리 설정 WORKDIR /app # 의존성 파일 복사 COPY package*.json ./ # 의존성 설치 RUN npm ci --only=production # 앱 소스 복사 COPY . . # 포트 노출 EXPOSE 3000 # 애플리케이션 실행 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] Docker Compose로 멀티 컨테이너 관리 여러 서비스를 함께 실행할 때는 Docker Compose를 사용합니다:\n# docker-compose.yml version: \u0026#39;3.8\u0026#39; services: web: build: . ports: - \u0026#34;3000:3000\u0026#34; environment: - NODE_ENV=development volumes: - .:/app - /app/node_modules depends_on: - db db: image: postgres:14 environment: POSTGRES_DB: myapp POSTGRES_USER: user POSTGRES_PASSWORD: password volumes: - postgres_data:/var/lib/postgresql/data ports: - \u0026#34;5432:5432\u0026#34; volumes: postgres_data: Docker Compose 명령어 # 서비스 시작 docker-compose up -d # 로그 확인 docker-compose logs -f # 서비스 중지 docker-compose down # 서비스 재시작 docker-compose restart 개발 환경 구축 예시 1. 개발용 Dockerfile FROM node:18-alpine WORKDIR /app # 개발 도구 설치 RUN apk add --no-cache git COPY package*.json ./ RUN npm install COPY . . EXPOSE 3000 # 개발 서버 실행 CMD [\u0026#34;npm\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;dev\u0026#34;] 2. .dockerignore 파일 node_modules npm-debug.log .git .gitignore README.md .env .env.local Dockerfile .dockerignore 유용한 Docker 팁 볼륨 마운트 # 로컬 디렉토리를 컨테이너에 마운트 docker run -v $(pwd):/app -p 3000:3000 my-app # 데이터 볼륨 사용 docker volume create my-data docker run -v my-data:/data my-app 환경 변수 설정 # 환경 변수 전달 docker run -e NODE_ENV=production my-app # .env 파일 사용 docker run --env-file .env my-app 네트워크 설정 # 사용자 정의 네트워크 생성 docker network create my-network # 네트워크에 컨테이너 연결 docker run --network my-network my-app 마무리 Docker는 현대 개발에서 필수적인 도구가 되었습니다. 처음에는 복잡해 보일 수 있지만, 익숙해지면 개발 효율성을 크게 향상시킬 수 있습니다.\n컨테이너 기반 개발에 관심이 있으시다면 Docker부터 시작해보세요! 🐳\n"},{
  "section": "Blog",
  "slug": "/blog/javascript-es6-features/",
  "title": "JavaScript ES6+ 핵심 기능들",
  "description": "모던 JavaScript의 핵심 기능들을 예제와 함께 알아보고, 실무에서 어떻게 활용하는지 살펴봅니다.",
  "date": "2025년 7월 29일",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_5ab6ae2b6c8dafe9.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"403\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_fb276b12568d006b.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/service-2_hu_19c4114772326a2.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/service-2_hu_e30126b8e54b22d4.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "JavaScript, 프론트엔드",
  "tags": "JavaScript, ES6, 모던자바스크립트, 프론트엔드",
  "content":"JavaScript ES6(ECMAScript 2015)부터 많은 새로운 기능들이 추가되었습니다. 오늘은 실무에서 자주 사용되는 핵심 기능들을 알아보겠습니다.\n1. let과 const 기존의 var 대신 블록 스코프를 가지는 let과 const를 사용합니다.\n// var의 문제점 for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 3, 3, 3 } // let으로 해결 for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 0, 1, 2 } // const로 상수 선언 const API_URL = \u0026#39;https://api.example.com\u0026#39;; const config = { apiKey: \u0026#39;your-api-key\u0026#39;, timeout: 5000 }; 2. 화살표 함수 (Arrow Functions) 더 간결한 함수 문법과 this 바인딩의 차이점:\n// 기존 함수 function add(a, b) { return a + b; } // 화살표 함수 const add = (a, b) =\u0026gt; a + b; // 배열 메서드와 함께 사용 const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map(n =\u0026gt; n * 2); const evens = numbers.filter(n =\u0026gt; n % 2 === 0); const sum = numbers.reduce((acc, n) =\u0026gt; acc + n, 0); // this 바인딩의 차이 class Timer { constructor() { this.seconds = 0; } start() { // 화살표 함수는 상위 스코프의 this를 사용 setInterval(() =\u0026gt; { this.seconds++; console.log(this.seconds); }, 1000); } } 3. 템플릿 리터럴 (Template Literals) 문자열 보간과 멀티라인 문자열:\nconst name = \u0026#39;Kigo\u0026#39;; const age = 30; // 문자열 보간 const greeting = `안녕하세요, ${name}님! 나이가 ${age}세이시군요.`; // 멀티라인 문자열 const html = ` \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;${name}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Age: ${age}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `; // 태그드 템플릿 function highlight(strings, ...values) { return strings.reduce((result, string, i) =\u0026gt; { const value = values[i] ? `\u0026lt;mark\u0026gt;${values[i]}\u0026lt;/mark\u0026gt;` : \u0026#39;\u0026#39;; return result + string + value; }, \u0026#39;\u0026#39;); } const message = highlight`Hello ${name}, you are ${age} years old!`; 4. 구조 분해 할당 (Destructuring) 배열과 객체에서 값을 추출하는 간편한 방법:\n// 배열 구조 분해 const [first, second, ...rest] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(rest); // [3, 4, 5] // 객체 구조 분해 const user = { name: \u0026#39;Kigo\u0026#39;, age: 30, email: \u0026#39;kigo@example.com\u0026#39; }; const { name, age, email } = user; // 새로운 이름으로 할당 const { name: userName, age: userAge } = user; // 기본값 설정 const { name, country = \u0026#39;Korea\u0026#39; } = user; // 함수 매개변수에서 사용 function greet({ name, age }) { return `Hello ${name}, you are ${age} years old!`; } greet(user); 5. 스프레드 연산자 (Spread Operator) 배열과 객체를 전개하는 문법:\n// 배열 합치기 const arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6] // 배열 복사 const original = [1, 2, 3]; const copy = [...original]; // 함수 호출에서 사용 function sum(a, b, c) { return a + b + c; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 객체 합치기 const obj1 = { a: 1, b: 2 }; const obj2 = { c: 3, d: 4 }; const merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 } // 객체 속성 오버라이드 const user = { name: \u0026#39;John\u0026#39;, age: 30 }; const updatedUser = { ...user, age: 31 }; 6. 기본 매개변수 (Default Parameters) 함수 매개변수의 기본값 설정:\n// 기본 매개변수 function greet(name = \u0026#39;World\u0026#39;, punctuation = \u0026#39;!\u0026#39;) { return `Hello, ${name}${punctuation}`; } console.log(greet()); // \u0026#34;Hello, World!\u0026#34; console.log(greet(\u0026#39;Kigo\u0026#39;)); // \u0026#34;Hello, Kigo!\u0026#34; console.log(greet(\u0026#39;Kigo\u0026#39;, \u0026#39;?\u0026#39;)); // \u0026#34;Hello, Kigo?\u0026#34; // 함수를 기본값으로 사용 function getDefaultName() { return \u0026#39;Anonymous\u0026#39;; } function welcome(name = getDefaultName()) { return `Welcome, ${name}!`; } 7. 모듈 (Modules) ES6 모듈 시스템:\n// math.js export const PI = 3.14159; export function add(a, b) { return a + b; } export function multiply(a, b) { return a * b; } // 기본 내보내기 export default function subtract(a, b) { return a - b; } // main.js import subtract, { PI, add, multiply } from \u0026#39;./math.js\u0026#39;; // 모든 것을 가져오기 import * as math from \u0026#39;./math.js\u0026#39;; console.log(math.PI); console.log(math.add(2, 3)); 8. 클래스 (Classes) 객체 지향 프로그래밍을 위한 클래스 문법:\nclass Animal { constructor(name, species) { this.name = name; this.species = species; } speak() { return `${this.name} makes a sound`; } // 정적 메서드 static getKingdom() { return \u0026#39;Animalia\u0026#39;; } } class Dog extends Animal { constructor(name, breed) { super(name, \u0026#39;Canis lupus\u0026#39;); this.breed = breed; } speak() { return `${this.name} barks`; } // getter get info() { return `${this.name} is a ${this.breed}`; } // setter set nickname(nick) { this.nick = nick; } } const dog = new Dog(\u0026#39;Buddy\u0026#39;, \u0026#39;Golden Retriever\u0026#39;); console.log(dog.speak()); // \u0026#34;Buddy barks\u0026#34; console.log(dog.info); // \u0026#34;Buddy is a Golden Retriever\u0026#34; 9. Promise와 async/await 비동기 처리를 위한 현대적인 방법:\n// Promise function fetchData(url) { return new Promise((resolve, reject) =\u0026gt; { fetch(url) .then(response =\u0026gt; { if (!response.ok) { throw new Error(\u0026#39;Network response was not ok\u0026#39;); } return response.json(); }) .then(data =\u0026gt; resolve(data)) .catch(error =\u0026gt; reject(error)); }); } // async/await 사용 async function getData() { try { const data = await fetchData(\u0026#39;https://api.example.com/data\u0026#39;); console.log(data); return data; } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error); } } // 여러 비동기 작업 병렬 처리 async function fetchMultipleData() { try { const [users, posts, comments] = await Promise.all([ fetchData(\u0026#39;/api/users\u0026#39;), fetchData(\u0026#39;/api/posts\u0026#39;), fetchData(\u0026#39;/api/comments\u0026#39;) ]); return { users, posts, comments }; } catch (error) { console.error(\u0026#39;Error fetching data:\u0026#39;, error); } } 마무리 ES6+ 기능들은 JavaScript를 더욱 강력하고 표현력 있는 언어로 만들어주었습니다. 이러한 기능들을 잘 활용하면 더 깔끔하고 유지보수하기 쉬운 코드를 작성할 수 있습니다.\n모던 JavaScript의 다른 기능들도 궁금하시다면 댓글로 알려주세요! 🚀\n"}]
